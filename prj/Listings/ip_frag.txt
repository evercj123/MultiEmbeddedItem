; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\ip_frag.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ip_frag.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\ip_frag.crf ..\lwip\src\core\ipv4\ip_frag.c]
                          THUMB

                          AREA ||i.ip_frag||, CODE, READONLY, ALIGN=2

                  ip_frag PROC
;;;666    err_t 
;;;667    ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;668    {
000004  b08a              SUB      sp,sp,#0x28
000006  4604              MOV      r4,r0
;;;669      struct pbuf *rambuf;
;;;670    #if IP_FRAG_USES_STATIC_BUF
;;;671      struct pbuf *header;
;;;672    #else
;;;673    #if !LWIP_NETIF_TX_SINGLE_PBUF
;;;674      struct pbuf *newpbuf;
;;;675    #endif
;;;676      struct ip_hdr *original_iphdr;
;;;677    #endif
;;;678      struct ip_hdr *iphdr;
;;;679      u16_t nfb;
;;;680      u16_t left, cop;
;;;681      u16_t mtu = netif->mtu;
000008  980b              LDR      r0,[sp,#0x2c]
;;;682      u16_t ofo, omf;
;;;683      u16_t last;
;;;684      u16_t poff = IP_HLEN;
00000a  2514              MOVS     r5,#0x14
;;;685      u16_t tmp;
;;;686    #if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
;;;687      u16_t newpbuflen = 0;
00000c  2600              MOVS     r6,#0
00000e  8c07              LDRH     r7,[r0,#0x20]         ;681
;;;688      u16_t left_to_copy;
;;;689    #endif
;;;690    
;;;691      /* Get a RAM based MTU sized pbuf */
;;;692    #if IP_FRAG_USES_STATIC_BUF
;;;693      /* When using a static buffer, we use a PBUF_REF, which we will
;;;694       * use to reference the packet (without link header).
;;;695       * Layer and length is irrelevant.
;;;696       */
;;;697      rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
;;;698      if (rambuf == NULL) {
;;;699        LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
;;;700        return ERR_MEM;
;;;701      }
;;;702      rambuf->tot_len = rambuf->len = mtu;
;;;703      rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
;;;704    
;;;705      /* Copy the IP header in it */
;;;706      iphdr = (struct ip_hdr *)rambuf->payload;
;;;707      SMEMCPY(iphdr, p->payload, IP_HLEN);
;;;708    #else /* IP_FRAG_USES_STATIC_BUF */
;;;709      original_iphdr = (struct ip_hdr *)p->payload;
000010  6860              LDR      r0,[r4,#4]
;;;710      iphdr = original_iphdr;
;;;711    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;712    
;;;713      /* Save original offset */
;;;714      tmp = ntohs(IPH_OFFSET(iphdr));
000012  9006              STR      r0,[sp,#0x18]
000014  88c0              LDRH     r0,[r0,#6]
000016  f7fffffe          BL       lwip_ntohs
;;;715      ofo = tmp & IP_OFFMASK;
00001a  f3c0010c          UBFX     r1,r0,#0,#13
;;;716      omf = tmp & IP_MF;
00001e  f4005000          AND      r0,r0,#0x2000
;;;717    
;;;718      left = p->tot_len - IP_HLEN;
000022  9103              STR      r1,[sp,#0xc]
000024  9008              STR      r0,[sp,#0x20]
000026  8920              LDRH     r0,[r4,#8]
000028  3814              SUBS     r0,r0,#0x14
00002a  3f14              SUBS     r7,r7,#0x14
00002c  fa1ff980          UXTH     r9,r0
;;;719    
;;;720      nfb = (mtu - IP_HLEN) / 8;
000030  17f8              ASRS     r0,r7,#31
000032  eb077050          ADD      r0,r7,r0,LSR #29
000036  f3c000cf          UBFX     r0,r0,#3,#16
;;;721    
;;;722      while (left) {
00003a  9707              STR      r7,[sp,#0x1c]
00003c  9004              STR      r0,[sp,#0x10]
00003e  e08d              B        |L1.348|
                  |L1.64|
;;;723        last = (left <= mtu - IP_HLEN);
000040  9907              LDR      r1,[sp,#0x1c]
000042  4589              CMP      r9,r1
000044  dc01              BGT      |L1.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L1.76|
                  |L1.74|
00004a  2000              MOVS     r0,#0
                  |L1.76|
;;;724    
;;;725        /* Set new offset and MF flag */
;;;726        tmp = omf | (IP_OFFMASK & (ofo));
00004c  9903              LDR      r1,[sp,#0xc]
00004e  9a08              LDR      r2,[sp,#0x20]
000050  f3c1010c          UBFX     r1,r1,#0,#13
000054  4311              ORRS     r1,r1,r2
;;;727        if (!last) {
000056  9105              STR      r1,[sp,#0x14]
000058  b180              CBZ      r0,|L1.124|
;;;728          tmp = tmp | IP_MF;
;;;729        }
;;;730    
;;;731        /* Fill this fragment */
;;;732        cop = last ? left : nfb * 8;
00005a  4648              MOV      r0,r9
                  |L1.92|
00005c  fa1ffb80          UXTH     r11,r0
;;;733    
;;;734    #if IP_FRAG_USES_STATIC_BUF
;;;735        poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
;;;736    #else /* IP_FRAG_USES_STATIC_BUF */
;;;737    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;738        rambuf = pbuf_alloc(PBUF_IP, cop, PBUF_RAM);
;;;739        if (rambuf == NULL) {
;;;740          return ERR_MEM;
;;;741        }
;;;742        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;743          (rambuf->len == rambuf->tot_len) && (rambuf->next == NULL));
;;;744        poff += pbuf_copy_partial(p, rambuf->payload, cop, poff);
;;;745        /* make room for the IP header */
;;;746        if(pbuf_header(rambuf, IP_HLEN)) {
;;;747          pbuf_free(rambuf);
;;;748          return ERR_MEM;
;;;749        }
;;;750        /* fill in the IP header */
;;;751        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;752        iphdr = rambuf->payload;
;;;753    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;754        /* When not using a static buffer, create a chain of pbufs.
;;;755         * The first will be a PBUF_RAM holding the link and IP header.
;;;756         * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
;;;757         * but limited to the size of an mtu.
;;;758         */
;;;759        rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
000060  2200              MOVS     r2,#0
000062  2114              MOVS     r1,#0x14
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       pbuf_alloc
;;;760        if (rambuf == NULL) {
00006a  9002              STR      r0,[sp,#8]
00006c  b160              CBZ      r0,|L1.136|
;;;761          return ERR_MEM;
;;;762        }
;;;763        LWIP_ASSERT("this needs a pbuf in one piece!",
00006e  8960              LDRH     r0,[r4,#0xa]
000070  2814              CMP      r0,#0x14
000072  d20e              BCS      |L1.146|
000074  a040              ADR      r0,|L1.376|
000076  f7fffffe          BL       __2printf
                  |L1.122|
00007a  e7fe              B        |L1.122|
                  |L1.124|
00007c  f4415000          ORR      r0,r1,#0x2000         ;728
000080  9005              STR      r0,[sp,#0x14]         ;732
000082  9804              LDR      r0,[sp,#0x10]         ;732
000084  00c0              LSLS     r0,r0,#3              ;732
000086  e7e9              B        |L1.92|
                  |L1.136|
000088  f04f30ff          MOV      r0,#0xffffffff        ;761
                  |L1.140|
;;;764                    (p->len >= (IP_HLEN)));
;;;765        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;766        iphdr = (struct ip_hdr *)rambuf->payload;
;;;767    
;;;768        /* Can just adjust p directly for needed offset. */
;;;769        p->payload = (u8_t *)p->payload + poff;
;;;770        p->len -= poff;
;;;771    
;;;772        left_to_copy = cop;
;;;773        while (left_to_copy) {
;;;774          struct pbuf_custom_ref *pcr;
;;;775          newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
;;;776          /* Is this pbuf already empty? */
;;;777          if (!newpbuflen) {
;;;778            p = p->next;
;;;779            continue;
;;;780          }
;;;781          pcr = ip_frag_alloc_pbuf_custom_ref();
;;;782          if (pcr == NULL) {
;;;783            pbuf_free(rambuf);
;;;784            return ERR_MEM;
;;;785          }
;;;786          /* Mirror this pbuf, although we might not need all of it. */
;;;787          newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
;;;788          if (newpbuf == NULL) {
;;;789            ip_frag_free_pbuf_custom_ref(pcr);
;;;790            pbuf_free(rambuf);
;;;791            return ERR_MEM;
;;;792          }
;;;793          pbuf_ref(p);
;;;794          pcr->original = p;
;;;795          pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
;;;796    
;;;797          /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
;;;798           * so that it is removed when pbuf_dechain is later called on rambuf.
;;;799           */
;;;800          pbuf_cat(rambuf, newpbuf);
;;;801          left_to_copy -= newpbuflen;
;;;802          if (left_to_copy) {
;;;803            p = p->next;
;;;804          }
;;;805        }
;;;806        poff = newpbuflen;
;;;807    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;808    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;809    
;;;810        /* Correct header */
;;;811        IPH_OFFSET_SET(iphdr, htons(tmp));
;;;812        IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
;;;813        IPH_CHKSUM_SET(iphdr, 0);
;;;814        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;815    
;;;816    #if IP_FRAG_USES_STATIC_BUF
;;;817        if (last) {
;;;818          pbuf_realloc(rambuf, left + IP_HLEN);
;;;819        }
;;;820    
;;;821        /* This part is ugly: we alloc a RAM based pbuf for 
;;;822         * the link level header for each chunk and then 
;;;823         * free it.A PBUF_ROM style pbuf for which pbuf_header
;;;824         * worked would make things simpler.
;;;825         */
;;;826        header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
;;;827        if (header != NULL) {
;;;828          pbuf_chain(header, rambuf);
;;;829          netif->output(netif, header, dest);
;;;830          IPFRAG_STATS_INC(ip_frag.xmit);
;;;831          snmp_inc_ipfragcreates();
;;;832          pbuf_free(header);
;;;833        } else {
;;;834          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
;;;835          pbuf_free(rambuf);
;;;836          return ERR_MEM;
;;;837        }
;;;838    #else /* IP_FRAG_USES_STATIC_BUF */
;;;839        /* No need for separate header pbuf - we allowed room for it in rambuf
;;;840         * when allocated.
;;;841         */
;;;842        netif->output(netif, rambuf, dest);
;;;843        IPFRAG_STATS_INC(ip_frag.xmit);
;;;844    
;;;845        /* Unfortunately we can't reuse rambuf - the hardware may still be
;;;846         * using the buffer. Instead we free it (and the ensuing chain) and
;;;847         * recreate it next time round the loop. If we're lucky the hardware
;;;848         * will have already sent the packet, the free will really free, and
;;;849         * there will be zero memory penalty.
;;;850         */
;;;851        
;;;852        pbuf_free(rambuf);
;;;853    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;854        left -= cop;
;;;855        ofo += nfb;
;;;856      }
;;;857    #if IP_FRAG_USES_STATIC_BUF
;;;858      pbuf_free(rambuf);
;;;859    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;860      snmp_inc_ipfragoks();
;;;861      return ERR_OK;
;;;862    }
00008c  b00d              ADD      sp,sp,#0x34
00008e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.146|
000092  9802              LDR      r0,[sp,#8]            ;765
000094  2214              MOVS     r2,#0x14              ;765
000096  9906              LDR      r1,[sp,#0x18]         ;765
000098  6840              LDR      r0,[r0,#4]            ;765
00009a  f7fffffe          BL       __aeabi_memcpy
00009e  9802              LDR      r0,[sp,#8]            ;766
0000a0  f8d0a004          LDR      r10,[r0,#4]           ;769
0000a4  6860              LDR      r0,[r4,#4]            ;769
0000a6  4428              ADD      r0,r0,r5              ;769
0000a8  6060              STR      r0,[r4,#4]            ;770
0000aa  8960              LDRH     r0,[r4,#0xa]          ;770
0000ac  1b40              SUBS     r0,r0,r5              ;770
0000ae  8160              STRH     r0,[r4,#0xa]          ;770
0000b0  465d              MOV      r5,r11                ;772
0000b2  e026              B        |L1.258|
                  |L1.180|
0000b4  8966              LDRH     r6,[r4,#0xa]          ;775
0000b6  42ae              CMP      r6,r5                 ;775
0000b8  d900              BLS      |L1.188|
0000ba  462e              MOV      r6,r5                 ;775
                  |L1.188|
0000bc  b306              CBZ      r6,|L1.256|
0000be  2006              MOVS     r0,#6                 ;777
0000c0  f7fffffe          BL       memp_malloc
0000c4  0007              MOVS     r7,r0                 ;777
0000c6  d04f              BEQ      |L1.360|
0000c8  6860              LDR      r0,[r4,#4]            ;787
0000ca  e9cd0600          STRD     r0,r6,[sp,#0]         ;787
0000ce  463b              MOV      r3,r7                 ;787
0000d0  2202              MOVS     r2,#2                 ;787
0000d2  4631              MOV      r1,r6                 ;787
0000d4  2003              MOVS     r0,#3                 ;787
0000d6  f7fffffe          BL       pbuf_alloced_custom
0000da  ea5f0800          MOVS     r8,r0                 ;787
0000de  d047              BEQ      |L1.368|
0000e0  4620              MOV      r0,r4                 ;793
0000e2  f7fffffe          BL       pbuf_ref
0000e6  482c              LDR      r0,|L1.408|
0000e8  e9c70404          STRD     r0,r4,[r7,#0x10]      ;795
0000ec  4641              MOV      r1,r8                 ;800
0000ee  9802              LDR      r0,[sp,#8]            ;800
0000f0  f7fffffe          BL       pbuf_cat
0000f4  1ba8              SUBS     r0,r5,r6              ;801
0000f6  0405              LSLS     r5,r0,#16             ;801
0000f8  0c2d              LSRS     r5,r5,#16             ;801
0000fa  d004              BEQ      |L1.262|
0000fc  6824              LDR      r4,[r4,#0]            ;803
0000fe  e7d9              B        |L1.180|
                  |L1.256|
000100  6824              LDR      r4,[r4,#0]            ;778
                  |L1.258|
000102  2d00              CMP      r5,#0                 ;773
000104  d1d6              BNE      |L1.180|
                  |L1.262|
000106  4635              MOV      r5,r6                 ;806
000108  9805              LDR      r0,[sp,#0x14]         ;811
00010a  f7fffffe          BL       lwip_htons
00010e  f8aa0006          STRH     r0,[r10,#6]           ;811
000112  f10b0014          ADD      r0,r11,#0x14          ;812
000116  b280              UXTH     r0,r0                 ;812
000118  f7fffffe          BL       lwip_htons
00011c  f8aa0002          STRH     r0,[r10,#2]           ;812
000120  2100              MOVS     r1,#0                 ;813
000122  f8aa100a          STRH     r1,[r10,#0xa]         ;813
000126  2114              MOVS     r1,#0x14              ;814
000128  4650              MOV      r0,r10                ;814
00012a  f7fffffe          BL       inet_chksum
00012e  f8aa000a          STRH     r0,[r10,#0xa]         ;814
000132  980b              LDR      r0,[sp,#0x2c]         ;842
000134  9a0c              LDR      r2,[sp,#0x30]         ;842
000136  9902              LDR      r1,[sp,#8]            ;842
000138  6943              LDR      r3,[r0,#0x14]         ;842
00013a  4798              BLX      r3                    ;842
00013c  4917              LDR      r1,|L1.412|
00013e  8e08              LDRH     r0,[r1,#0x30]         ;843  ; lwip_stats
000140  1c40              ADDS     r0,r0,#1              ;843
000142  8608              STRH     r0,[r1,#0x30]         ;843
000144  9802              LDR      r0,[sp,#8]            ;852
000146  f7fffffe          BL       pbuf_free
00014a  eba9000b          SUB      r0,r9,r11             ;854
00014e  fa1ff980          UXTH     r9,r0                 ;854
000152  e9dd0103          LDRD     r0,r1,[sp,#0xc]       ;854
000156  4408              ADD      r0,r0,r1              ;855
000158  b280              UXTH     r0,r0                 ;855
00015a  9003              STR      r0,[sp,#0xc]          ;855
                  |L1.348|
00015c  f1b90f00          CMP      r9,#0                 ;722
000160  f47faf6e          BNE      |L1.64|
000164  2000              MOVS     r0,#0                 ;861
000166  e791              B        |L1.140|
                  |L1.360|
000168  9802              LDR      r0,[sp,#8]            ;783
00016a  f7fffffe          BL       pbuf_free
00016e  e78b              B        |L1.136|
                  |L1.368|
000170  4638              MOV      r0,r7                 ;789
000172  f7fffffe          BL       ip_frag_free_pbuf_custom_ref
000176  e7f7              B        |L1.360|
;;;863    #endif /* IP_FRAG */
                          ENDP

                  |L1.376|
000178  74686973          DCB      "this needs a pbuf in one piece!",0
00017c  206e6565
000180  64732061
000184  20706275
000188  6620696e
00018c  206f6e65
000190  20706965
000194  63652100
                  |L1.408|
                          DCD      ipfrag_free_pbuf_custom
                  |L1.412|
                          DCD      lwip_stats

                          AREA ||i.ip_frag_free_pbuf_custom_ref||, CODE, READONLY, ALIGN=2

                  ip_frag_free_pbuf_custom_ref PROC
;;;630    static void
;;;631    ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
000000  b510              PUSH     {r4,lr}
;;;632    {
000002  b128              CBZ      r0,|L2.16|
;;;633      LWIP_ASSERT("p != NULL", p != NULL);
;;;634      memp_free(MEMP_FRAG_PBUF, p);
000004  4601              MOV      r1,r0
000006  e8bd4010          POP      {r4,lr}
00000a  2006              MOVS     r0,#6
00000c  f7ffbffe          B.W      memp_free
                  |L2.16|
000010  a001              ADR      r0,|L2.24|
000012  f7fffffe          BL       __2printf
                  |L2.22|
000016  e7fe              B        |L2.22|
;;;635    }
;;;636    
                          ENDP

                  |L2.24|
000018  7020213d          DCB      "p != NULL",0
00001c  204e554c
000020  4c00    
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||i.ip_reass||, CODE, READONLY, ALIGN=2

                  ip_reass PROC
;;;475    struct pbuf *
;;;476    ip_reass(struct pbuf *p)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;477    {
;;;478      struct pbuf *r;
;;;479      struct ip_hdr *fraghdr;
;;;480      struct ip_reassdata *ipr;
;;;481      struct ip_reass_helper *iprh;
;;;482      u16_t offset, len;
;;;483      u8_t clen;
;;;484      struct ip_reassdata *ipr_prev = NULL;
;;;485    
;;;486      IPFRAG_STATS_INC(ip_frag.recv);
000004  4f70              LDR      r7,|L3.456|
000006  f04f0800          MOV      r8,#0                 ;484
00000a  8e78              LDRH     r0,[r7,#0x32]  ; lwip_stats
00000c  1c40              ADDS     r0,r0,#1
00000e  8678              STRH     r0,[r7,#0x32]
;;;487      snmp_inc_ipreasmreqds();
;;;488    
;;;489      fraghdr = (struct ip_hdr*)p->payload;
000010  9800              LDR      r0,[sp,#0]
;;;490    
;;;491      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
000012  6844              LDR      r4,[r0,#4]
000014  7820              LDRB     r0,[r4,#0]
000016  f000000f          AND      r0,r0,#0xf
00001a  2805              CMP      r0,#5
00001c  d005              BEQ      |L3.42|
;;;492        LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
;;;493        IPFRAG_STATS_INC(ip_frag.err);
00001e  f8b70044          LDRH     r0,[r7,#0x44]  ; lwip_stats
000022  1c40              ADDS     r0,r0,#1
000024  f8a70044          STRH     r0,[r7,#0x44]
;;;494        goto nullreturn;
000028  e0c5              B        |L3.438|
                  |L3.42|
;;;495      }
;;;496    
;;;497      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
00002a  88e0              LDRH     r0,[r4,#6]
00002c  f7fffffe          BL       lwip_ntohs
000030  04c0              LSLS     r0,r0,#19
000032  ea4f4b10          LSR      r11,r0,#16
;;;498      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000036  8860              LDRH     r0,[r4,#2]
000038  f7fffffe          BL       lwip_ntohs
00003c  7821              LDRB     r1,[r4,#0]
00003e  f001010f          AND      r1,r1,#0xf
000042  4249              RSBS     r1,r1,#0
000044  eb000081          ADD      r0,r0,r1,LSL #2
000048  fa1ffa80          UXTH     r10,r0
;;;499    
;;;500      /* Check if we are allowed to enqueue more datagrams. */
;;;501      clen = pbuf_clen(p);
00004c  9800              LDR      r0,[sp,#0]
00004e  f7fffffe          BL       pbuf_clen
;;;502      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
000052  4d5e              LDR      r5,|L3.460|
000054  4606              MOV      r6,r0                 ;501
000056  8828              LDRH     r0,[r5,#0]  ; ip_reass_pbufcount
000058  4430              ADD      r0,r0,r6
00005a  280a              CMP      r0,#0xa
00005c  d90c              BLS      |L3.120|
;;;503    #if IP_REASS_FREE_OLDEST
;;;504        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
00005e  4631              MOV      r1,r6
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       ip_reass_remove_oldest_datagram
000066  b118              CBZ      r0,|L3.112|
;;;505            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
000068  8828              LDRH     r0,[r5,#0]  ; ip_reass_pbufcount
00006a  4430              ADD      r0,r0,r6
00006c  280a              CMP      r0,#0xa
00006e  d903              BLS      |L3.120|
                  |L3.112|
;;;506    #endif /* IP_REASS_FREE_OLDEST */
;;;507        {
;;;508          /* No datagram could be freed and still too many pbufs enqueued */
;;;509          LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
;;;510            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;511          IPFRAG_STATS_INC(ip_frag.memerr);
000070  8fb8              LDRH     r0,[r7,#0x3c]  ; lwip_stats
000072  1c40              ADDS     r0,r0,#1
000074  87b8              STRH     r0,[r7,#0x3c]
;;;512          /* @todo: send ICMP time exceeded here? */
;;;513          /* drop this pbuf */
;;;514          goto nullreturn;
000076  e09e              B        |L3.438|
                  |L3.120|
;;;515        }
;;;516      }
;;;517    
;;;518      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;519       * remembering the previous in the queue for later dequeueing. */
;;;520      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
000078  46a9              MOV      r9,r5
00007a  686d              LDR      r5,[r5,#4]  ; reassdatagrams
00007c  e019              B        |L3.178|
                  |L3.126|
;;;521        /* Check if the incoming fragment matches the one currently present
;;;522           in the reassembly buffer. If so, we proceed with copying the
;;;523           fragment into the buffer. */
;;;524        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
00007e  6968              LDR      r0,[r5,#0x14]
000080  68e1              LDR      r1,[r4,#0xc]
000082  4288              CMP      r0,r1
000084  d113              BNE      |L3.174|
000086  69a8              LDR      r0,[r5,#0x18]
000088  6921              LDR      r1,[r4,#0x10]
00008a  4288              CMP      r0,r1
00008c  d10f              BNE      |L3.174|
00008e  89a8              LDRH     r0,[r5,#0xc]
000090  88a1              LDRH     r1,[r4,#4]
000092  4288              CMP      r0,r1
000094  d10b              BNE      |L3.174|
;;;525          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
;;;526            ntohs(IPH_ID(fraghdr))));
;;;527          IPFRAG_STATS_INC(ip_frag.cachehit);
000096  f8b70046          LDRH     r0,[r7,#0x46]  ; lwip_stats
00009a  1c40              ADDS     r0,r0,#1
00009c  f8a70046          STRH     r0,[r7,#0x46]
;;;528          break;
0000a0  b14d              CBZ      r5,|L3.182|
;;;529        }
;;;530        ipr_prev = ipr;
;;;531      }
;;;532    
;;;533      if (ipr == NULL) {
;;;534      /* Enqueue a new datagram into the datagram queue */
;;;535        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
;;;536        /* Bail if unable to enqueue */
;;;537        if(ipr == NULL) {
;;;538          goto nullreturn;
;;;539        }
;;;540      } else {
;;;541        if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
0000a2  88e0              LDRH     r0,[r4,#6]
0000a4  f7fffffe          BL       lwip_ntohs
0000a8  04c0              LSLS     r0,r0,#19
0000aa  d02b              BEQ      |L3.260|
0000ac  e035              B        |L3.282|
                  |L3.174|
0000ae  46a8              MOV      r8,r5                 ;530
0000b0  682d              LDR      r5,[r5,#0]            ;520
                  |L3.178|
0000b2  2d00              CMP      r5,#0                 ;520
0000b4  d1e3              BNE      |L3.126|
                  |L3.182|
0000b6  2005              MOVS     r0,#5                 ;520
0000b8  f7fffffe          BL       memp_malloc
0000bc  0005              MOVS     r5,r0                 ;520
0000be  d10a              BNE      |L3.214|
0000c0  4631              MOV      r1,r6                 ;520
0000c2  4620              MOV      r0,r4                 ;520
0000c4  f7fffffe          BL       ip_reass_remove_oldest_datagram
0000c8  42b0              CMP      r0,r6                 ;520
0000ca  db16              BLT      |L3.250|
0000cc  2005              MOVS     r0,#5                 ;520
0000ce  f7fffffe          BL       memp_malloc
0000d2  0005              MOVS     r5,r0                 ;520
0000d4  d011              BEQ      |L3.250|
                  |L3.214|
0000d6  2120              MOVS     r1,#0x20              ;520
0000d8  f7fffffe          BL       __aeabi_memclr4
0000dc  2003              MOVS     r0,#3                 ;520
0000de  77e8              STRB     r0,[r5,#0x1f]         ;520
0000e0  f8d91004          LDR      r1,[r9,#4]            ;520  ; reassdatagrams
0000e4  6029              STR      r1,[r5,#0]            ;520
0000e6  2214              MOVS     r2,#0x14              ;520
0000e8  4621              MOV      r1,r4                 ;520
0000ea  f1050008          ADD      r0,r5,#8              ;520
0000ee  f8c95004          STR      r5,[r9,#4]            ;520  ; reassdatagrams
0000f2  f7fffffe          BL       __aeabi_memcpy
                  |L3.246|
0000f6  b3e5              CBZ      r5,|L3.370|
0000f8  e00f              B        |L3.282|
                  |L3.250|
0000fa  8fb8              LDRH     r0,[r7,#0x3c]         ;537  ; lwip_stats
0000fc  1c40              ADDS     r0,r0,#1              ;537
0000fe  87b8              STRH     r0,[r7,#0x3c]         ;537
000100  2500              MOVS     r5,#0                 ;537
000102  e7f8              B        |L3.246|
                  |L3.260|
;;;542          ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
000104  89e8              LDRH     r0,[r5,#0xe]
000106  f7fffffe          BL       lwip_ntohs
00010a  04c0              LSLS     r0,r0,#19
00010c  d005              BEQ      |L3.282|
;;;543          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;544           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;545           * of the first fragment (for ICMP time exceeded and later, for copying
;;;546           * all options, if supported)*/
;;;547          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
00010e  2214              MOVS     r2,#0x14
000110  4621              MOV      r1,r4
000112  f1050008          ADD      r0,r5,#8
000116  f7fffffe          BL       __aeabi_memcpy
                  |L3.282|
;;;548        }
;;;549      }
;;;550      /* Track the current number of pbufs current 'in-flight', in order to limit 
;;;551      the number of fragments that may be enqueued at any one time */
;;;552      ip_reass_pbufcount += clen;
00011a  f8b90000          LDRH     r0,[r9,#0]  ; ip_reass_pbufcount
00011e  464f              MOV      r7,r9
000120  4430              ADD      r0,r0,r6
000122  f8a90000          STRH     r0,[r9,#0]
;;;553    
;;;554      /* At this point, we have either created a new entry or pointing 
;;;555       * to an existing one */
;;;556    
;;;557      /* check for 'no more fragments', and update queue entry*/
;;;558      if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
000126  79a0              LDRB     r0,[r4,#6]
000128  0680              LSLS     r0,r0,#26
00012a  d406              BMI      |L3.314|
;;;559        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
00012c  7fa8              LDRB     r0,[r5,#0x1e]
00012e  f0400001          ORR      r0,r0,#1
000132  77a8              STRB     r0,[r5,#0x1e]
;;;560        ipr->datagram_len = offset + len;
000134  eb0b000a          ADD      r0,r11,r10
000138  83a8              STRH     r0,[r5,#0x1c]
                  |L3.314|
;;;561        LWIP_DEBUGF(IP_REASS_DEBUG,
;;;562         ("ip_reass: last fragment seen, total len %"S16_F"\n",
;;;563          ipr->datagram_len));
;;;564      }
;;;565      /* find the right place to insert this pbuf */
;;;566      /* @todo: trim pbufs if fragments are overlapping */
;;;567      if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
00013a  4628              MOV      r0,r5
00013c  9900              LDR      r1,[sp,#0]
00013e  f7fffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
000142  2800              CMP      r0,#0
000144  d035              BEQ      |L3.434|
;;;568        /* the totally last fragment (flag more fragments = 0) was received at least
;;;569         * once AND all fragments are received */
;;;570        ipr->datagram_len += IP_HLEN;
000146  8ba8              LDRH     r0,[r5,#0x1c]
;;;571    
;;;572        /* save the second pbuf before copying the header over the pointer */
;;;573        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
;;;574    
;;;575        /* copy the original ip header back to the first pbuf */
;;;576        fraghdr = (struct ip_hdr*)(ipr->p->payload);
;;;577        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
000148  2214              MOVS     r2,#0x14
00014a  3014              ADDS     r0,r0,#0x14           ;570
00014c  83a8              STRH     r0,[r5,#0x1c]         ;570
00014e  6868              LDR      r0,[r5,#4]            ;573
000150  f1050108          ADD      r1,r5,#8
000154  6846              LDR      r6,[r0,#4]            ;573
000156  4630              MOV      r0,r6
000158  6834              LDR      r4,[r6,#0]            ;573
00015a  f7fffffe          BL       __aeabi_memcpy
;;;578        IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
00015e  8ba8              LDRH     r0,[r5,#0x1c]
000160  f7fffffe          BL       lwip_htons
000164  8070              STRH     r0,[r6,#2]
;;;579        IPH_OFFSET_SET(fraghdr, 0);
000166  2000              MOVS     r0,#0
000168  80f0              STRH     r0,[r6,#6]
;;;580        IPH_CHKSUM_SET(fraghdr, 0);
00016a  8170              STRH     r0,[r6,#0xa]
;;;581        /* @todo: do we need to set calculate the correct checksum? */
;;;582        IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
00016c  2114              MOVS     r1,#0x14
00016e  4630              MOV      r0,r6
000170  e000              B        |L3.372|
                  |L3.370|
000172  e020              B        |L3.438|
                  |L3.372|
000174  f7fffffe          BL       inet_chksum
000178  8170              STRH     r0,[r6,#0xa]
;;;583    
;;;584        p = ipr->p;
;;;585    
;;;586        /* chain together the pbufs contained within the reass_data list. */
;;;587        while(r != NULL) {
;;;588          iprh = (struct ip_reass_helper*)r->payload;
;;;589    
;;;590          /* hide the ip header for every succeding fragment */
;;;591          pbuf_header(r, -IP_HLEN);
00017a  f06f0a13          MVN      r10,#0x13
00017e  f8d59004          LDR      r9,[r5,#4]            ;587
000182  e009              B        |L3.408|
                  |L3.388|
000184  4651              MOV      r1,r10
000186  4620              MOV      r0,r4
000188  6866              LDR      r6,[r4,#4]
00018a  f7fffffe          BL       pbuf_header
;;;592          pbuf_cat(p, r);
00018e  4621              MOV      r1,r4
000190  4648              MOV      r0,r9
000192  f7fffffe          BL       pbuf_cat
;;;593          r = iprh->next_pbuf;
000196  6834              LDR      r4,[r6,#0]
                  |L3.408|
000198  2c00              CMP      r4,#0                 ;587
00019a  d1f3              BNE      |L3.388|
;;;594        }
;;;595        /* release the sources allocate for the fragment queue entry */
;;;596        ip_reass_dequeue_datagram(ipr, ipr_prev);
00019c  4641              MOV      r1,r8
00019e  4628              MOV      r0,r5
0001a0  f7fffffe          BL       ip_reass_dequeue_datagram
;;;597    
;;;598        /* and adjust the number of pbufs currently queued for reassembly. */
;;;599        ip_reass_pbufcount -= pbuf_clen(p);
0001a4  4648              MOV      r0,r9
0001a6  f7fffffe          BL       pbuf_clen
0001aa  8839              LDRH     r1,[r7,#0]  ; ip_reass_pbufcount
0001ac  1a08              SUBS     r0,r1,r0
0001ae  8038              STRH     r0,[r7,#0]
;;;600    
;;;601        /* Return the pbuf chain */
;;;602        return p;
0001b0  4648              MOV      r0,r9
                  |L3.434|
;;;603      }
;;;604      /* the datagram is not (yet?) reassembled completely */
;;;605      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;606      return NULL;
;;;607    
;;;608    nullreturn:
;;;609      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
;;;610      IPFRAG_STATS_INC(ip_frag.drop);
;;;611      pbuf_free(p);
;;;612      return NULL;
;;;613    }
0001b2  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.438|
0001b6  8ef8              LDRH     r0,[r7,#0x36]         ;610  ; lwip_stats
0001b8  1c40              ADDS     r0,r0,#1              ;610
0001ba  86f8              STRH     r0,[r7,#0x36]         ;610
0001bc  9800              LDR      r0,[sp,#0]            ;611
0001be  f7fffffe          BL       pbuf_free
0001c2  2000              MOVS     r0,#0                 ;612
0001c4  e7f5              B        |L3.434|
;;;614    #endif /* IP_REASSEMBLY */
                          ENDP

0001c6  0000              DCW      0x0000
                  |L3.456|
                          DCD      lwip_stats
                  |L3.460|
                          DCD      ||.data||

                          AREA ||i.ip_reass_chain_frag_into_datagram_and_validate||, CODE, READONLY, ALIGN=2

                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;330    static int
;;;331    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;332    {
;;;333      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
;;;334      struct pbuf *q;
;;;335      u16_t offset,len;
;;;336      struct ip_hdr *fraghdr;
;;;337      int valid = 1;
;;;338    
;;;339      /* Extract length and fragment offset from current fragment */
;;;340      fraghdr = (struct ip_hdr*)new_p->payload; 
;;;341      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000004  f8d18004          LDR      r8,[r1,#4]
000008  4606              MOV      r6,r0                 ;332
00000a  460f              MOV      r7,r1                 ;332
00000c  2400              MOVS     r4,#0                 ;333
00000e  2501              MOVS     r5,#1                 ;337
000010  f8b80002          LDRH     r0,[r8,#2]
000014  f7fffffe          BL       lwip_ntohs
000018  4601              MOV      r1,r0
00001a  f8980000          LDRB     r0,[r8,#0]
00001e  f000000f          AND      r0,r0,#0xf
000022  4240              RSBS     r0,r0,#0
000024  eb010980          ADD      r9,r1,r0,LSL #2
;;;342      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000028  f8b80006          LDRH     r0,[r8,#6]
00002c  f7fffffe          BL       lwip_ntohs
000030  04c0              LSLS     r0,r0,#19
000032  0c03              LSRS     r3,r0,#16
;;;343    
;;;344      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;345       * and setup the embedded helper structure. */
;;;346      /* make sure the struct ip_reass_helper fits into the IP header */
;;;347      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
;;;348                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;349      iprh = (struct ip_reass_helper*)new_p->payload;
;;;350      iprh->next_pbuf = NULL;
000034  6878              LDR      r0,[r7,#4]
000036  2100              MOVS     r1,#0
000038  6001              STR      r1,[r0,#0]
;;;351      iprh->start = offset;
;;;352      iprh->end = offset + len;
00003a  eb030109          ADD      r1,r3,r9
00003e  8083              STRH     r3,[r0,#4]            ;351
000040  fa1ff881          UXTH     r8,r1
000044  f8a08006          STRH     r8,[r0,#6]
;;;353    
;;;354      /* Iterate through until we either get to the end of the list (append),
;;;355       * or we find on with a larger offset (insert). */
;;;356      for (q = ipr->p; q != NULL;) {
000048  6872              LDR      r2,[r6,#4]
00004a  e01d              B        |L4.136|
                  |L4.76|
;;;357        iprh_tmp = (struct ip_reass_helper*)q->payload;
;;;358        if (iprh->start < iprh_tmp->start) {
00004c  6851              LDR      r1,[r2,#4]
00004e  f8b1c004          LDRH     r12,[r1,#4]
000052  4563              CMP      r3,r12
000054  d20d              BCS      |L4.114|
;;;359          /* the new pbuf should be inserted before this */
;;;360          iprh->next_pbuf = q;
000056  6002              STR      r2,[r0,#0]
;;;361          if (iprh_prev != NULL) {
000058  b144              CBZ      r4,|L4.108|
;;;362            /* not the fragment with the lowest offset */
;;;363    #if IP_REASS_CHECK_OVERLAP
;;;364            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
00005a  f8b4c006          LDRH     r12,[r4,#6]
00005e  4563              CMP      r3,r12
000060  d35c              BCC      |L4.284|
000062  8889              LDRH     r1,[r1,#4]
000064  4588              CMP      r8,r1
000066  d859              BHI      |L4.284|
;;;365              /* fragment overlaps with previous or following, throw away */
;;;366              goto freepbuf;
;;;367            }
;;;368    #endif /* IP_REASS_CHECK_OVERLAP */
;;;369            iprh_prev->next_pbuf = new_p;
000068  6027              STR      r7,[r4,#0]
00006a  e000              B        |L4.110|
                  |L4.108|
;;;370          } else {
;;;371            /* fragment with the lowest offset */
;;;372            ipr->p = new_p;
00006c  6077              STR      r7,[r6,#4]
                  |L4.110|
;;;373          }
;;;374          break;
;;;375        } else if(iprh->start == iprh_tmp->start) {
;;;376          /* received the same datagram twice: no need to keep the datagram */
;;;377          goto freepbuf;
;;;378    #if IP_REASS_CHECK_OVERLAP
;;;379        } else if(iprh->start < iprh_tmp->end) {
;;;380          /* overlap: no need to keep the new datagram */
;;;381          goto freepbuf;
;;;382    #endif /* IP_REASS_CHECK_OVERLAP */
;;;383        } else {
;;;384          /* Check if the fragments received so far have no wholes. */
;;;385          if (iprh_prev != NULL) {
;;;386            if (iprh_prev->end != iprh_tmp->start) {
;;;387              /* There is a fragment missing between the current
;;;388               * and the previous fragment */
;;;389              valid = 0;
;;;390            }
;;;391          }
;;;392        }
;;;393        q = iprh_tmp->next_pbuf;
;;;394        iprh_prev = iprh_tmp;
;;;395      }
;;;396    
;;;397      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;398      if (q == NULL) {
00006e  b16a              CBZ      r2,|L4.140|
000070  e022              B        |L4.184|
                  |L4.114|
000072  d053              BEQ      |L4.284|
000074  88ca              LDRH     r2,[r1,#6]            ;379
000076  4293              CMP      r3,r2                 ;379
000078  d350              BCC      |L4.284|
00007a  b11c              CBZ      r4,|L4.132|
00007c  88e2              LDRH     r2,[r4,#6]            ;386
00007e  4562              CMP      r2,r12                ;386
000080  d000              BEQ      |L4.132|
000082  2500              MOVS     r5,#0                 ;389
                  |L4.132|
000084  680a              LDR      r2,[r1,#0]            ;393
000086  460c              MOV      r4,r1                 ;394
                  |L4.136|
000088  2a00              CMP      r2,#0                 ;356
00008a  d1df              BNE      |L4.76|
                  |L4.140|
;;;399        if (iprh_prev != NULL) {
00008c  b16c              CBZ      r4,|L4.170|
;;;400          /* this is (for now), the fragment with the highest offset:
;;;401           * chain it to the last fragment */
;;;402    #if IP_REASS_CHECK_OVERLAP
;;;403          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
00008e  88e1              LDRH     r1,[r4,#6]
000090  8882              LDRH     r2,[r0,#4]
000092  4291              CMP      r1,r2
000094  d903              BLS      |L4.158|
000096  a027              ADR      r0,|L4.308|
000098  f7fffffe          BL       __2printf
                  |L4.156|
00009c  e7fe              B        |L4.156|
                  |L4.158|
;;;404    #endif /* IP_REASS_CHECK_OVERLAP */
;;;405          iprh_prev->next_pbuf = new_p;
00009e  6027              STR      r7,[r4,#0]
;;;406          if (iprh_prev->end != iprh->start) {
0000a0  8882              LDRH     r2,[r0,#4]
0000a2  4291              CMP      r1,r2
0000a4  d008              BEQ      |L4.184|
;;;407            valid = 0;
0000a6  2500              MOVS     r5,#0
0000a8  e006              B        |L4.184|
                  |L4.170|
;;;408          }
;;;409        } else {
;;;410    #if IP_REASS_CHECK_OVERLAP
;;;411          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
0000aa  6871              LDR      r1,[r6,#4]
0000ac  b119              CBZ      r1,|L4.182|
0000ae  a029              ADR      r0,|L4.340|
0000b0  f7fffffe          BL       __2printf
                  |L4.180|
0000b4  e7fe              B        |L4.180|
                  |L4.182|
;;;412            ipr->p == NULL);
;;;413    #endif /* IP_REASS_CHECK_OVERLAP */
;;;414          /* this is the first fragment we ever received for this ip datagram */
;;;415          ipr->p = new_p;
0000b6  6077              STR      r7,[r6,#4]
                  |L4.184|
;;;416        }
;;;417      }
;;;418    
;;;419      /* At this point, the validation part begins: */
;;;420      /* If we already received the last fragment */
;;;421      if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
0000b8  7fb1              LDRB     r1,[r6,#0x1e]
0000ba  07c9              LSLS     r1,r1,#31
0000bc  d02c              BEQ      |L4.280|
;;;422        /* and had no wholes so far */
;;;423        if (valid) {
0000be  2d00              CMP      r5,#0
0000c0  d027              BEQ      |L4.274|
;;;424          /* then check if the rest of the fragments is here */
;;;425          /* Check if the queue starts with the first datagram */
;;;426          if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
0000c2  6874              LDR      r4,[r6,#4]
0000c4  6863              LDR      r3,[r4,#4]
0000c6  8899              LDRH     r1,[r3,#4]
0000c8  b939              CBNZ     r1,|L4.218|
                  |L4.202|
;;;427            valid = 0;
;;;428          } else {
;;;429            /* and check that there are no wholes after this datagram */
;;;430            iprh_prev = iprh;
;;;431            q = iprh->next_pbuf;
0000ca  6801              LDR      r1,[r0,#0]
0000cc  4602              MOV      r2,r0                 ;430
;;;432            while (q != NULL) {
0000ce  b131              CBZ      r1,|L4.222|
;;;433              iprh = (struct ip_reass_helper*)q->payload;
;;;434              if (iprh_prev->end != iprh->start) {
0000d0  6848              LDR      r0,[r1,#4]
0000d2  88d1              LDRH     r1,[r2,#6]
0000d4  8882              LDRH     r2,[r0,#4]
0000d6  4291              CMP      r1,r2
0000d8  d0f7              BEQ      |L4.202|
                  |L4.218|
;;;435                valid = 0;
0000da  2500              MOVS     r5,#0
;;;436                break;
0000dc  e019              B        |L4.274|
                  |L4.222|
;;;437              }
;;;438              iprh_prev = iprh;
;;;439              q = iprh->next_pbuf;
;;;440            }
;;;441            /* if still valid, all fragments are received
;;;442             * (because to the MF==0 already arrived */
;;;443            if (valid) {
0000de  b1c5              CBZ      r5,|L4.274|
;;;444              LWIP_ASSERT("sanity check", ipr->p != NULL);
0000e0  b12c              CBZ      r4,|L4.238|
;;;445              LWIP_ASSERT("sanity check",
0000e2  4283              CMP      r3,r0
0000e4  d107              BNE      |L4.246|
0000e6  a029              ADR      r0,|L4.396|
0000e8  f7fffffe          BL       __2printf
                  |L4.236|
0000ec  e7fe              B        |L4.236|
                  |L4.238|
0000ee  a027              ADR      r0,|L4.396|
0000f0  f7fffffe          BL       __2printf
                  |L4.244|
0000f4  e7fe              B        |L4.244|
                  |L4.246|
;;;446                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;447              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
0000f6  6801              LDR      r1,[r0,#0]
0000f8  b119              CBZ      r1,|L4.258|
0000fa  a028              ADR      r0,|L4.412|
0000fc  f7fffffe          BL       __2printf
                  |L4.256|
000100  e7fe              B        |L4.256|
                  |L4.258|
;;;448                iprh->next_pbuf == NULL);
;;;449              LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
000102  88d0              LDRH     r0,[r2,#6]
000104  8bb1              LDRH     r1,[r6,#0x1c]
000106  4288              CMP      r0,r1
000108  d003              BEQ      |L4.274|
00010a  a02d              ADR      r0,|L4.448|
00010c  f7fffffe          BL       __2printf
                  |L4.272|
000110  e7fe              B        |L4.272|
                  |L4.274|
;;;450                iprh->end == ipr->datagram_len);
;;;451            }
;;;452          }
;;;453        }
;;;454        /* If valid is 0 here, there are some fragments missing in the middle
;;;455         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;456         * no more fragments are received... */
;;;457        return valid;
000112  4628              MOV      r0,r5
                  |L4.276|
;;;458      }
;;;459      /* If we come here, not all fragments were received, yet! */
;;;460      return 0; /* not yet valid! */
;;;461    #if IP_REASS_CHECK_OVERLAP
;;;462    freepbuf:
;;;463      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;464      pbuf_free(new_p);
;;;465      return 0;
;;;466    #endif /* IP_REASS_CHECK_OVERLAP */
;;;467    }
000114  e8bd87f0          POP      {r4-r10,pc}
                  |L4.280|
000118  2000              MOVS     r0,#0                 ;460
00011a  e7fb              B        |L4.276|
                  |L4.284|
00011c  4638              MOV      r0,r7                 ;463
00011e  f7fffffe          BL       pbuf_clen
000122  4601              MOV      r1,r0                 ;463
000124  4832              LDR      r0,|L4.496|
000126  8802              LDRH     r2,[r0,#0]            ;463  ; ip_reass_pbufcount
000128  1a51              SUBS     r1,r2,r1              ;463
00012a  8001              STRH     r1,[r0,#0]            ;463
00012c  4638              MOV      r0,r7                 ;464
00012e  f7fffffe          BL       pbuf_free
000132  e7f1              B        |L4.280|
;;;468    
                          ENDP

                  |L4.308|
000134  63686563          DCB      "check fragments don't overlap",0
000138  6b206672
00013c  61676d65
000140  6e747320
000144  646f6e27
000148  74206f76
00014c  65726c61
000150  7000    
000152  00                DCB      0
000153  00                DCB      0
                  |L4.340|
000154  6e6f2070          DCB      "no previous fragment, this must be the first fragment!",0
000158  72657669
00015c  6f757320
000160  66726167
000164  6d656e74
000168  2c207468
00016c  6973206d
000170  75737420
000174  62652074
000178  68652066
00017c  69727374
000180  20667261
000184  676d656e
000188  742100  
00018b  00                DCB      0
                  |L4.396|
00018c  73616e69          DCB      "sanity check",0
000190  74792063
000194  6865636b
000198  00      
000199  00                DCB      0
00019a  00                DCB      0
00019b  00                DCB      0
                  |L4.412|
00019c  76616c69          DCB      "validate_datagram:next_pbuf!=NULL",0
0001a0  64617465
0001a4  5f646174
0001a8  61677261
0001ac  6d3a6e65
0001b0  78745f70
0001b4  62756621
0001b8  3d4e554c
0001bc  4c00    
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L4.448|
0001c0  76616c69          DCB      "validate_datagram:datagram end!=datagram len",0
0001c4  64617465
0001c8  5f646174
0001cc  61677261
0001d0  6d3a6461
0001d4  74616772
0001d8  616d2065
0001dc  6e64213d
0001e0  64617461
0001e4  6772616d
0001e8  206c656e
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L4.496|
                          DCD      ||.data||

                          AREA ||i.ip_reass_dequeue_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_dequeue_datagram PROC
;;;303    static void
;;;304    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  4a0a              LDR      r2,|L5.44|
;;;305    {
000002  b510              PUSH     {r4,lr}
;;;306      
;;;307      /* dequeue the reass struct  */
;;;308      if (reassdatagrams == ipr) {
000004  6853              LDR      r3,[r2,#4]  ; reassdatagrams
000006  4283              CMP      r3,r0
000008  d102              BNE      |L5.16|
;;;309        /* it was the first in the list */
;;;310        reassdatagrams = ipr->next;
00000a  6801              LDR      r1,[r0,#0]
00000c  6051              STR      r1,[r2,#4]  ; reassdatagrams
00000e  e002              B        |L5.22|
                  |L5.16|
;;;311      } else {
;;;312        /* it wasn't the first, so it must have a valid 'prev' */
;;;313        LWIP_ASSERT("sanity check linked list", prev != NULL);
000010  b139              CBZ      r1,|L5.34|
;;;314        prev->next = ipr->next;
000012  6802              LDR      r2,[r0,#0]
000014  600a              STR      r2,[r1,#0]
                  |L5.22|
;;;315      }
;;;316    
;;;317      /* now we can free the ip_reass struct */
;;;318      memp_free(MEMP_REASSDATA, ipr);
000016  4601              MOV      r1,r0
000018  e8bd4010          POP      {r4,lr}
00001c  2005              MOVS     r0,#5
00001e  f7ffbffe          B.W      memp_free
                  |L5.34|
000022  a003              ADR      r0,|L5.48|
000024  f7fffffe          BL       __2printf
                  |L5.40|
000028  e7fe              B        |L5.40|
;;;319    }
;;;320    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      ||.data||
                  |L5.48|
000030  73616e69          DCB      "sanity check linked list",0
000034  74792063
000038  6865636b
00003c  206c696e
000040  6b656420
000044  6c697374
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.ip_reass_free_complete_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_free_complete_datagram PROC
;;;157    static int
;;;158    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;159    {
000004  4606              MOV      r6,r0
;;;160      u16_t pbufs_freed = 0;
000006  2500              MOVS     r5,#0
000008  460f              MOV      r7,r1                 ;159
;;;161      u8_t clen;
;;;162      struct pbuf *p;
;;;163      struct ip_reass_helper *iprh;
;;;164    
;;;165      LWIP_ASSERT("prev != ipr", prev != ipr);
00000a  42b1              CMP      r1,r6
00000c  d103              BNE      |L6.22|
00000e  a029              ADR      r0,|L6.180|
000010  f7fffffe          BL       __2printf
                  |L6.20|
000014  e7fe              B        |L6.20|
                  |L6.22|
;;;166      if (prev != NULL) {
000016  b137              CBZ      r7,|L6.38|
;;;167        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
000018  6838              LDR      r0,[r7,#0]
00001a  42b0              CMP      r0,r6
00001c  d003              BEQ      |L6.38|
00001e  a028              ADR      r0,|L6.192|
000020  f7fffffe          BL       __2printf
                  |L6.36|
000024  e7fe              B        |L6.36|
                  |L6.38|
;;;168      }
;;;169    
;;;170      snmp_inc_ipreasmfails();
;;;171    #if LWIP_ICMP
;;;172      iprh = (struct ip_reass_helper *)ipr->p->payload;
000026  6874              LDR      r4,[r6,#4]
;;;173      if (iprh->start == 0) {
;;;174        /* The first fragment was received, send ICMP time exceeded. */
;;;175        /* First, de-queue the first pbuf from r->p. */
;;;176        p = ipr->p;
;;;177        ipr->p = iprh->next_pbuf;
;;;178        /* Then, copy the original header into it. */
;;;179        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
;;;180        icmp_time_exceeded(p, ICMP_TE_FRAG);
;;;181        clen = pbuf_clen(p);
;;;182        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000028  f44f3880          MOV      r8,#0x10000
00002c  6860              LDR      r0,[r4,#4]            ;173
00002e  8881              LDRH     r1,[r0,#4]            ;173
000030  b9c1              CBNZ     r1,|L6.100|
000032  6800              LDR      r0,[r0,#0]            ;177
000034  6070              STR      r0,[r6,#4]            ;179
000036  2214              MOVS     r2,#0x14              ;179
000038  f1060108          ADD      r1,r6,#8              ;179
00003c  6860              LDR      r0,[r4,#4]            ;179
00003e  f7fffffe          BL       __aeabi_memcpy
000042  2101              MOVS     r1,#1                 ;180
000044  4620              MOV      r0,r4                 ;180
000046  f7fffffe          BL       icmp_time_exceeded
00004a  4620              MOV      r0,r4                 ;181
00004c  f7fffffe          BL       pbuf_clen
000050  4540              CMP      r0,r8
000052  d303              BCC      |L6.92|
000054  a01f              ADR      r0,|L6.212|
000056  f7fffffe          BL       __2printf
                  |L6.90|
00005a  e7fe              B        |L6.90|
                  |L6.92|
;;;183        pbufs_freed += clen;
00005c  4605              MOV      r5,r0
;;;184        pbuf_free(p);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       pbuf_free
                  |L6.100|
000064  46c1              MOV      r9,r8                 ;182
;;;185      }
;;;186    #endif /* LWIP_ICMP */
;;;187    
;;;188      /* First, free all received pbufs.  The individual pbufs need to be released 
;;;189         separately as they have not yet been chained */
;;;190      p = ipr->p;
;;;191      while (p != NULL) {
000066  6874              LDR      r4,[r6,#4]
000068  e010              B        |L6.140|
                  |L6.106|
;;;192        struct pbuf *pcur;
;;;193        iprh = (struct ip_reass_helper *)p->payload;
;;;194        pcur = p;
;;;195        /* get the next pointer before freeing */
;;;196        p = iprh->next_pbuf;
00006a  6860              LDR      r0,[r4,#4]
00006c  46a0              MOV      r8,r4                 ;194
00006e  6804              LDR      r4,[r0,#0]
;;;197        clen = pbuf_clen(pcur);
000070  4640              MOV      r0,r8
000072  f7fffffe          BL       pbuf_clen
;;;198        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000076  4428              ADD      r0,r0,r5
000078  4548              CMP      r0,r9
00007a  d303              BCC      |L6.132|
00007c  a015              ADR      r0,|L6.212|
00007e  f7fffffe          BL       __2printf
                  |L6.130|
000082  e7fe              B        |L6.130|
                  |L6.132|
;;;199        pbufs_freed += clen;
000084  b285              UXTH     r5,r0
;;;200        pbuf_free(pcur);
000086  4640              MOV      r0,r8
000088  f7fffffe          BL       pbuf_free
                  |L6.140|
00008c  2c00              CMP      r4,#0                 ;191
00008e  d1ec              BNE      |L6.106|
;;;201      }
;;;202      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;203      ip_reass_dequeue_datagram(ipr, prev);
000090  4639              MOV      r1,r7
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       ip_reass_dequeue_datagram
;;;204      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
000098  4916              LDR      r1,|L6.244|
00009a  8808              LDRH     r0,[r1,#0]  ; ip_reass_pbufcount
00009c  42a8              CMP      r0,r5
00009e  d203              BCS      |L6.168|
0000a0  a015              ADR      r0,|L6.248|
0000a2  f7fffffe          BL       __2printf
                  |L6.166|
0000a6  e7fe              B        |L6.166|
                  |L6.168|
;;;205      ip_reass_pbufcount -= pbufs_freed;
0000a8  1b40              SUBS     r0,r0,r5
0000aa  8008              STRH     r0,[r1,#0]
;;;206    
;;;207      return pbufs_freed;
0000ac  4628              MOV      r0,r5
;;;208    }
0000ae  e8bd87f0          POP      {r4-r10,pc}
;;;209    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L6.180|
0000b4  70726576          DCB      "prev != ipr",0
0000b8  20213d20
0000bc  69707200
                  |L6.192|
0000c0  70726576          DCB      "prev->next == ipr",0
0000c4  2d3e6e65
0000c8  7874203d
0000cc  3d206970
0000d0  7200    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L6.212|
0000d4  70627566          DCB      "pbufs_freed + clen <= 0xffff",0
0000d8  735f6672
0000dc  65656420
0000e0  2b20636c
0000e4  656e203c
0000e8  3d203078
0000ec  66666666
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L6.244|
                          DCD      ||.data||
                  |L6.248|
0000f8  69705f72          DCB      "ip_reass_pbufcount >= clen",0
0000fc  65617373
000100  5f706275
000104  66636f75
000108  6e74203e
00010c  3d20636c
000110  656e00  
000113  00                DCB      0

                          AREA ||i.ip_reass_remove_oldest_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_remove_oldest_datagram PROC
;;;220    static int
;;;221    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;222    {
;;;223      /* @todo Can't we simply remove the last datagram in the
;;;224       *       linked list behind reassdatagrams?
;;;225       */
;;;226      struct ip_reassdata *r, *oldest, *prev;
;;;227      int pbufs_freed = 0, pbufs_freed_current;
;;;228      int other_datagrams;
;;;229    
;;;230      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;231       * but don't free the datagram that 'fraghdr' belongs to! */
;;;232      do {
;;;233        oldest = NULL;
;;;234        prev = NULL;
;;;235        other_datagrams = 0;
;;;236        r = reassdatagrams;
000004  f8df8068          LDR      r8,|L7.112|
000008  460f              MOV      r7,r1                 ;222
00000a  4605              MOV      r5,r0                 ;222
00000c  2600              MOVS     r6,#0                 ;227
                  |L7.14|
00000e  2200              MOVS     r2,#0                 ;233
000010  4613              MOV      r3,r2                 ;234
000012  4614              MOV      r4,r2                 ;235
;;;237        while (r != NULL) {
000014  f8d80004          LDR      r0,[r8,#4]  ; reassdatagrams
000018  e01a              B        |L7.80|
                  |L7.26|
;;;238          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f8d5c00c          LDR      r12,[r5,#0xc]
000020  4561              CMP      r1,r12
000022  d109              BNE      |L7.56|
000024  6981              LDR      r1,[r0,#0x18]
000026  f8d5c010          LDR      r12,[r5,#0x10]
00002a  4561              CMP      r1,r12
00002c  d104              BNE      |L7.56|
00002e  8981              LDRH     r1,[r0,#0xc]
000030  f8b5c004          LDRH     r12,[r5,#4]
000034  4561              CMP      r1,r12
000036  d007              BEQ      |L7.72|
                  |L7.56|
000038  1c64              ADDS     r4,r4,#1
;;;239            /* Not the same datagram as fraghdr */
;;;240            other_datagrams++;
;;;241            if (oldest == NULL) {
00003a  b122              CBZ      r2,|L7.70|
;;;242              oldest = r;
;;;243            } else if (r->timer <= oldest->timer) {
00003c  7fc1              LDRB     r1,[r0,#0x1f]
00003e  f892c01f          LDRB     r12,[r2,#0x1f]
000042  4561              CMP      r1,r12
000044  d800              BHI      |L7.72|
                  |L7.70|
;;;244              /* older than the previous oldest */
;;;245              oldest = r;
000046  4602              MOV      r2,r0
                  |L7.72|
;;;246            }
;;;247          }
;;;248          if (r->next != NULL) {
000048  6801              LDR      r1,[r0,#0]
00004a  b101              CBZ      r1,|L7.78|
;;;249            prev = r;
00004c  4603              MOV      r3,r0
                  |L7.78|
00004e  4608              MOV      r0,r1
                  |L7.80|
000050  2800              CMP      r0,#0                 ;237
000052  d1e2              BNE      |L7.26|
;;;250          }
;;;251          r = r->next;
;;;252        }
;;;253        if (oldest != NULL) {
000054  b122              CBZ      r2,|L7.96|
;;;254          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
000056  4619              MOV      r1,r3
000058  4610              MOV      r0,r2
00005a  f7fffffe          BL       ip_reass_free_complete_datagram
;;;255          pbufs_freed += pbufs_freed_current;
00005e  4406              ADD      r6,r6,r0
                  |L7.96|
;;;256        }
;;;257      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
000060  42be              CMP      r6,r7
000062  da01              BGE      |L7.104|
000064  2c01              CMP      r4,#1
000066  dcd2              BGT      |L7.14|
                  |L7.104|
;;;258      return pbufs_freed;
000068  4630              MOV      r0,r6
;;;259    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;260    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

00006e  0000              DCW      0x0000
                  |L7.112|
                          DCD      ||.data||

                          AREA ||i.ip_reass_tmr||, CODE, READONLY, ALIGN=2

                  ip_reass_tmr PROC
;;;121    void
;;;122    ip_reass_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;123    {
;;;124      struct ip_reassdata *r, *prev = NULL;
;;;125    
;;;126      r = reassdatagrams;
000002  4809              LDR      r0,|L8.40|
000004  2500              MOVS     r5,#0                 ;124
000006  6844              LDR      r4,[r0,#4]            ;123  ; reassdatagrams
000008  e00b              B        |L8.34|
                  |L8.10|
;;;127      while (r != NULL) {
;;;128        /* Decrement the timer. Once it reaches 0,
;;;129         * clean up the incomplete fragment assembly */
;;;130        if (r->timer > 0) {
00000a  7fe0              LDRB     r0,[r4,#0x1f]
00000c  b120              CBZ      r0,|L8.24|
00000e  1e40              SUBS     r0,r0,#1
;;;131          r->timer--;
000010  77e0              STRB     r0,[r4,#0x1f]
;;;132          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
;;;133          prev = r;
000012  4625              MOV      r5,r4
;;;134          r = r->next;
000014  6824              LDR      r4,[r4,#0]
000016  e004              B        |L8.34|
                  |L8.24|
;;;135        } else {
;;;136          /* reassembly timed out */
;;;137          struct ip_reassdata *tmp;
;;;138          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
;;;139          tmp = r;
;;;140          /* get the next pointer before freeing */
;;;141          r = r->next;
000018  4620              MOV      r0,r4
00001a  6824              LDR      r4,[r4,#0]
;;;142          /* free the helper struct and all enqueued pbufs */
;;;143          ip_reass_free_complete_datagram(tmp, prev);
00001c  4629              MOV      r1,r5
00001e  f7fffffe          BL       ip_reass_free_complete_datagram
                  |L8.34|
000022  2c00              CMP      r4,#0                 ;127
000024  d1f1              BNE      |L8.10|
;;;144         }
;;;145       }
;;;146    }
000026  bd70              POP      {r4-r6,pc}
;;;147    
                          ENDP

                  |L8.40|
                          DCD      ||.data||

                          AREA ||i.ipfrag_free_pbuf_custom||, CODE, READONLY, ALIGN=2

                  ipfrag_free_pbuf_custom PROC
;;;639    static void
;;;640    ipfrag_free_pbuf_custom(struct pbuf *p)
000000  b510              PUSH     {r4,lr}
;;;641    {
000002  0004              MOVS     r4,r0
000004  d008              BEQ      |L9.24|
;;;642      struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
;;;643      LWIP_ASSERT("pcr != NULL", pcr != NULL);
;;;644      LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
;;;645      if (pcr->original != NULL) {
000006  6960              LDR      r0,[r4,#0x14]
000008  b108              CBZ      r0,|L9.14|
;;;646        pbuf_free(pcr->original);
00000a  f7fffffe          BL       pbuf_free
                  |L9.14|
;;;647      }
;;;648      ip_frag_free_pbuf_custom_ref(pcr);
00000e  4620              MOV      r0,r4
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      ip_frag_free_pbuf_custom_ref
                  |L9.24|
000018  a001              ADR      r0,|L9.32|
00001a  f7fffffe          BL       __2printf
                  |L9.30|
00001e  e7fe              B        |L9.30|
;;;649    }
;;;650    #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
                          ENDP

                  |L9.32|
000020  70637220          DCB      "pcr != NULL",0
000024  213d204e
000028  554c4c00

                          AREA ||.data||, DATA, ALIGN=2

                  ip_reass_pbufcount
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  reassdatagrams
                          DCD      0x00000000
