; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\ethernetif.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ethernetif.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\ethernetif.crf ..\lwip\src\netif\ethernetif.c]
                          THUMB

                          AREA ||i.PacketReceive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  PacketReceive PROC
;;;137    static unsigned char  MyRecvbuf[1500]; 
;;;138    struct pbuf *PacketReceive(struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;139    {
;;;140    	struct pbuf *p = NULL;	
;;;141    	unsigned int recvlen = 0;
;;;142    	unsigned int i = 0;
000004  2500              MOVS     r5,#0
;;;143    	struct pbuf *q = NULL;
;;;144        
;;;145    	recvlen = enc28j60PacketReceive(1500, MyRecvbuf);
000006  4913              LDR      r1,|L1.84|
000008  f24050dc          MOV      r0,#0x5dc
00000c  f7fffffe          BL       enc28j60PacketReceive
000010  1e06              SUBS     r6,r0,#0
;;;146    
;;;147    	if(!recvlen)	       //接收数据长度为0，直接返回空
000012  d017              BEQ      |L1.68|
;;;148    	{
;;;149    	    return NULL;
;;;150    	}
;;;151    	
;;;152    	//申请内核pbuf空间，为RAM类型
;;;153    	p = pbuf_alloc(PBUF_RAW, recvlen, PBUF_RAM);
000014  b2b1              UXTH     r1,r6
000016  2200              MOVS     r2,#0
000018  2003              MOVS     r0,#3
00001a  f7fffffe          BL       pbuf_alloc
00001e  0007              MOVS     r7,r0
;;;154    	
;;;155    	if(!p)			       //申请失败，则返回空
000020  d012              BEQ      |L1.72|
000022  f8df8030          LDR      r8,|L1.84|
;;;156    	{
;;;157    	    LWIP_PLATFORM_DIAG(("PacketReceive: pbuf_alloc fail ,len=%"U32_F"\n\t", recvlen));
;;;158    		return NULL;
;;;159    	 }
;;;160        //申请成功，拷贝数据到pbuf中
;;;161    	q = p;
000026  4604              MOV      r4,r0
                  |L1.40|
;;;162    		
;;;163    	while(q != NULL)
;;;164    	{   
;;;165    		memcpy(q->payload,&MyRecvbuf[i],q->len);
000028  eb080105          ADD      r1,r8,r5
00002c  8962              LDRH     r2,[r4,#0xa]
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       __aeabi_memcpy
;;;166    		i += q->len;
000034  8960              LDRH     r0,[r4,#0xa]
;;;167    		q = q->next;
000036  6824              LDR      r4,[r4,#0]
000038  4405              ADD      r5,r5,r0              ;166
;;;168    		if(i >= recvlen)  break;
00003a  42b5              CMP      r5,r6
00003c  d201              BCS      |L1.66|
00003e  2c00              CMP      r4,#0                 ;163
000040  d1f2              BNE      |L1.40|
                  |L1.66|
;;;169    	}
;;;170    		
;;;171    	return p;
000042  4638              MOV      r0,r7
                  |L1.68|
;;;172    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L1.72|
000048  4631              MOV      r1,r6                 ;157
00004a  a003              ADR      r0,|L1.88|
00004c  f7fffffe          BL       __2printf
000050  2000              MOVS     r0,#0                 ;158
000052  e7f7              B        |L1.68|
;;;173    
                          ENDP

                  |L1.84|
                          DCD      ||.bss||+0x5dc
                  |L1.88|
000058  5061636b          DCB      "PacketReceive: pbuf_alloc fail ,len=%u\n\t",0
00005c  65745265
000060  63656976
000064  653a2070
000068  6275665f
00006c  616c6c6f
000070  63206661
000074  696c202c
000078  6c656e3d
00007c  25750a09
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.PacketSend||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  PacketSend PROC
;;;100    static unsigned char  MySendbuf[1500]; 
;;;101    static err_t PacketSend (struct pbuf *p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;102    {
000004  4606              MOV      r6,r0
;;;103    	struct pbuf *q = NULL;
;;;104    	unsigned int templen = 0;
000006  2500              MOVS     r5,#0
;;;105    
;;;106    	for(q = p;q!=NULL;q = q->next)
000008  4604              MOV      r4,r0
;;;107    	{
;;;108    		memcpy(&MySendbuf[templen],q->payload,q->len);	 //将pbuf中的数据拷贝到全局数组MyDatabuf中
;;;109    		templen += 	q->len ;
;;;110    
;;;111    		if(templen > 1500 || templen > p->tot_len)	 	//有效性校验，防止数据溢出
;;;112    		{
;;;113    			LWIP_PLATFORM_DIAG(("PacketSend: error,tmplen=%"U32_F",tot_len=%"U32_F"\n\t", templen, p->tot_len));
;;;114    			return ERR_BUF;
00000a  f06f0901          MVN      r9,#1
00000e  4f13              LDR      r7,|L2.92|
000010  f24058dc          MOV      r8,#0x5dc             ;111
000014  e010              B        |L2.56|
                  |L2.22|
000016  8962              LDRH     r2,[r4,#0xa]          ;108
000018  1978              ADDS     r0,r7,r5              ;108
00001a  6861              LDR      r1,[r4,#4]            ;108
00001c  f7fffffe          BL       __aeabi_memcpy
000020  8960              LDRH     r0,[r4,#0xa]          ;109
000022  4405              ADD      r5,r5,r0              ;109
000024  4545              CMP      r5,r8                 ;111
000026  d802              BHI      |L2.46|
000028  8930              LDRH     r0,[r6,#8]            ;111
00002a  42a8              CMP      r0,r5                 ;111
00002c  d203              BCS      |L2.54|
                  |L2.46|
00002e  8932              LDRH     r2,[r6,#8]            ;113
000030  4629              MOV      r1,r5                 ;113
000032  a00b              ADR      r0,|L2.96|
000034  e00e              B        |L2.84|
                  |L2.54|
000036  6824              LDR      r4,[r4,#0]            ;106
                  |L2.56|
000038  2c00              CMP      r4,#0                 ;106
00003a  d1ec              BNE      |L2.22|
;;;115    		}
;;;116    	}
;;;117    	
;;;118    	//拷贝完毕，下面进行数据的发送工作
;;;119    	if(templen == p->tot_len)
00003c  8932              LDRH     r2,[r6,#8]
00003e  42aa              CMP      r2,r5
000040  d106              BNE      |L2.80|
;;;120    	{
;;;121    		enc28j60PacketSend(templen, MySendbuf);		   //调用网卡发送函数
000042  4906              LDR      r1,|L2.92|
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       enc28j60PacketSend
;;;122    		return ERR_OK; 
00004a  2000              MOVS     r0,#0
                  |L2.76|
;;;123    	}
;;;124    	
;;;125    	LWIP_PLATFORM_DIAG(("PacketSend: length mismatch ,tmplen=%"U32_F",tot_len=%"U32_F"\n\t", templen, p->tot_len));
;;;126    	return ERR_BUF;
;;;127    }
00004c  e8bd87f0          POP      {r4-r10,pc}
                  |L2.80|
000050  4629              MOV      r1,r5                 ;125
000052  a00e              ADR      r0,|L2.140|
                  |L2.84|
000054  f7fffffe          BL       __2printf
000058  4648              MOV      r0,r9                 ;126
00005a  e7f7              B        |L2.76|
;;;128    /****************************************************************************
                          ENDP

                  |L2.92|
                          DCD      ||.bss||
                  |L2.96|
000060  5061636b          DCB      "PacketSend: error,tmplen=%u,tot_len=%u\n\t",0
000064  65745365
000068  6e643a20
00006c  6572726f
000070  722c746d
000074  706c656e
000078  3d25752c
00007c  746f745f
000080  6c656e3d
000084  25750a09
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L2.140|
00008c  5061636b          DCB      "PacketSend: length mismatch ,tmplen=%u,tot_len=%u\n\t",0
000090  65745365
000094  6e643a20
000098  6c656e67
00009c  7468206d
0000a0  69736d61
0000a4  74636820
0000a8  2c746d70
0000ac  6c656e3d
0000b0  25752c74
0000b4  6f745f6c
0000b8  656e3d25
0000bc  750a0900

                          AREA ||i.ethernetif_init||, CODE, READONLY, ALIGN=2

                  ethernetif_init PROC
;;;318    err_t
;;;319    ethernetif_init(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;320    {
000002  0004              MOVS     r4,r0
000004  d036              BEQ      |L3.116|
;;;321      struct ethernetif *ethernetif;
;;;322    
;;;323      LWIP_ASSERT("netif != NULL", (netif != NULL));
;;;324        
;;;325      ethernetif = mem_malloc(sizeof(struct ethernetif));
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       mem_malloc
;;;326      if (ethernetif == NULL) {
00000c  b388              CBZ      r0,|L3.114|
;;;327        LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
;;;328        return ERR_MEM;
;;;329      }
;;;330    
;;;331    #if LWIP_NETIF_HOSTNAME
;;;332      /* Initialize interface hostname */
;;;333      netif->hostname = "lwip";
;;;334    #endif /* LWIP_NETIF_HOSTNAME */
;;;335    
;;;336      /*
;;;337       * Initialize the snmp variables and counters inside the struct netif.
;;;338       * The last argument should be replaced with your link speed, in units
;;;339       * of bits per second.
;;;340       */
;;;341      NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);
;;;342    
;;;343      netif->state = ethernetif;
;;;344      netif->name[0] = IFNAME0;
00000e  2165              MOVS     r1,#0x65
000010  61e0              STR      r0,[r4,#0x1c]
000012  f884102a          STRB     r1,[r4,#0x2a]
;;;345      netif->name[1] = IFNAME1;
000016  216e              MOVS     r1,#0x6e
000018  f884102b          STRB     r1,[r4,#0x2b]
;;;346      /* We directly use etharp_output() here to save a function call.
;;;347       * You can instead declare your own function an call etharp_output()
;;;348       * from it if you have to do some checks before sending (e.g. if link
;;;349       * is available...) */
;;;350      netif->output = etharp_output;
00001c  4919              LDR      r1,|L3.132|
;;;351      netif->linkoutput = low_level_output;
00001e  6161              STR      r1,[r4,#0x14]
000020  4919              LDR      r1,|L3.136|
;;;352      
;;;353      ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
000022  61a1              STR      r1,[r4,#0x18]
000024  f1040123          ADD      r1,r4,#0x23
000028  6001              STR      r1,[r0,#0]
00002a  2006              MOVS     r0,#6
00002c  f8840022          STRB     r0,[r4,#0x22]
000030  4816              LDR      r0,|L3.140|
000032  7801              LDRB     r1,[r0,#0]  ; MyMacID
000034  f8841023          STRB     r1,[r4,#0x23]
000038  7841              LDRB     r1,[r0,#1]  ; MyMacID
00003a  f8841024          STRB     r1,[r4,#0x24]
00003e  7881              LDRB     r1,[r0,#2]  ; MyMacID
000040  f8841025          STRB     r1,[r4,#0x25]
000044  78c1              LDRB     r1,[r0,#3]  ; MyMacID
000046  f8841026          STRB     r1,[r4,#0x26]
00004a  7901              LDRB     r1,[r0,#4]  ; MyMacID
00004c  f8841027          STRB     r1,[r4,#0x27]
000050  7940              LDRB     r0,[r0,#5]  ; MyMacID
000052  f8840028          STRB     r0,[r4,#0x28]
000056  f24050dc          MOV      r0,#0x5dc
00005a  8420              STRH     r0,[r4,#0x20]
00005c  2032              MOVS     r0,#0x32
00005e  f8840029          STRB     r0,[r4,#0x29]
000062  480a              LDR      r0,|L3.140|
000064  f7fffffe          BL       mymacinit
;;;354      
;;;355      /* initialize the hardware */
;;;356      low_level_init(netif);
;;;357    
;;;358      /*driver init ok,we set link up*/
;;;359      netif_set_link_up(netif );
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       netif_set_link_up
;;;360      
;;;361      return ERR_OK;
00006e  2000              MOVS     r0,#0
                  |L3.112|
;;;362    }
000070  bd10              POP      {r4,pc}
                  |L3.114|
000072  e003              B        |L3.124|
                  |L3.116|
000074  a006              ADR      r0,|L3.144|
000076  f7fffffe          BL       __2printf
                  |L3.122|
00007a  e7fe              B        |L3.122|
                  |L3.124|
00007c  f04f30ff          MOV      r0,#0xffffffff        ;328
000080  e7f6              B        |L3.112|
;;;363    #endif /* 0 */
                          ENDP

000082  0000              DCW      0x0000
                  |L3.132|
                          DCD      etharp_output
                  |L3.136|
                          DCD      low_level_output
                  |L3.140|
                          DCD      ||.data||
                  |L3.144|
000090  6e657469          DCB      "netif != NULL",0
000094  6620213d
000098  204e554c
00009c  4c00    
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.low_level_output||, CODE, READONLY, ALIGN=1

                  low_level_output PROC
;;;218    static err_t
;;;219    low_level_output(struct netif *netif, struct pbuf *p)
000000  4608              MOV      r0,r1
;;;220    {
;;;221    	//struct ethernetif *ethernetif = netif->state;
;;;222      /* Interrupts are disabled through this whole thing to support multi-threading
;;;223    	   transmit calls. Also this function might be called from an ISR. */
;;;224    	return PacketSend(p);	                // 调用网卡发送函数发送一帧数据
000002  f7ffbffe          B.W      PacketSend
;;;225    }
;;;226    
                          ENDP


                          AREA ||i.process_mac||, CODE, READONLY, ALIGN=2

                  process_mac PROC
;;;296    
;;;297    void process_mac(void)
000000  b570              PUSH     {r4-r6,lr}
                  |L5.2|
;;;298    {
;;;299       s32_t ret = 0;
;;;300       do
;;;301       {
;;;302           ret = ethernetif_input(&enc28j60_netif);
000002  4810              LDR      r0,|L5.68|
000004  4604              MOV      r4,r0
000006  f7fffffe          BL       PacketReceive
00000a  0005              MOVS     r5,r0
00000c  d00b              BEQ      |L5.38|
00000e  6868              LDR      r0,[r5,#4]
000010  8980              LDRH     r0,[r0,#0xc]
000012  f7fffffe          BL       lwip_htons
000016  f5b06f00          CMP      r0,#0x800
00001a  d006              BEQ      |L5.42|
00001c  f5a06000          SUB      r0,r0,#0x800
000020  3806              SUBS     r0,#6
000022  d107              BNE      |L5.52|
000024  e001              B        |L5.42|
                  |L5.38|
000026  2000              MOVS     r0,#0
000028  e008              B        |L5.60|
                  |L5.42|
00002a  6922              LDR      r2,[r4,#0x10]
00002c  4621              MOV      r1,r4
00002e  4628              MOV      r0,r5
000030  4790              BLX      r2
000032  b110              CBZ      r0,|L5.58|
                  |L5.52|
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       pbuf_free
                  |L5.58|
00003a  2001              MOVS     r0,#1
                  |L5.60|
;;;303    
;;;304       }while(ret);
00003c  2800              CMP      r0,#0
00003e  d1e0              BNE      |L5.2|
;;;305    }
000040  bd70              POP      {r4-r6,pc}
;;;306    /**
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      enc28j60_netif

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  MySendbuf
                          %        1500
                  MyRecvbuf
                          %        1500

                          AREA ||.data||, DATA, ALIGN=0

                  MyMacID
000000  04023500          DCB      0x04,0x02,0x35,0x00
000004  0001              DCB      0x00,0x01
