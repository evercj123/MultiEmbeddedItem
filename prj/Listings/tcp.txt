; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\tcp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\tcp.crf ..\lwip\src\core\tcp.c]
                          THUMB

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                  tcp_abandon PROC
;;;356    void
;;;357    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;358    {
000004  4604              MOV      r4,r0
;;;359      u32_t seqno, ackno;
;;;360    #if LWIP_CALLBACK_API  
;;;361      tcp_err_fn errf;
;;;362    #endif /* LWIP_CALLBACK_API */
;;;363      void *errf_arg;
;;;364    
;;;365      /* pcb->state LISTEN not allowed here */
;;;366      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
000006  7e00              LDRB     r0,[r0,#0x18]
000008  4688              MOV      r8,r1                 ;358
00000a  2801              CMP      r0,#1
00000c  d036              BEQ      |L1.124|
;;;367        pcb->state != LISTEN);
;;;368      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;369         are in an active state, call the receive function associated with
;;;370         the PCB with a NULL argument, and send an RST to the remote end. */
;;;371      if (pcb->state == TIME_WAIT) {
00000e  280a              CMP      r0,#0xa
000010  d038              BEQ      |L1.132|
;;;372        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
;;;373        memp_free(MEMP_TCP_PCB, pcb);
;;;374      } else {
;;;375        seqno = pcb->snd_nxt;
;;;376        ackno = pcb->rcv_nxt;
;;;377    #if LWIP_CALLBACK_API
;;;378        errf = pcb->errf;
;;;379    #endif /* LWIP_CALLBACK_API */
;;;380        errf_arg = pcb->callback_arg;
;;;381        TCP_PCB_REMOVE_ACTIVE(pcb);
000012  4621              MOV      r1,r4
000014  4822              LDR      r0,|L1.160|
000016  f8d49050          LDR      r9,[r4,#0x50]
00001a  6aa7              LDR      r7,[r4,#0x28]
00001c  6926              LDR      r6,[r4,#0x10]
00001e  f8d4508c          LDR      r5,[r4,#0x8c]
000022  f7fffffe          BL       tcp_pcb_remove
000026  491e              LDR      r1,|L1.160|
000028  2001              MOVS     r0,#1
00002a  3918              SUBS     r1,r1,#0x18
00002c  7008              STRB     r0,[r1,#0]
;;;382        if (pcb->unacked != NULL) {
00002e  6f20              LDR      r0,[r4,#0x70]
000030  b108              CBZ      r0,|L1.54|
;;;383          tcp_segs_free(pcb->unacked);
000032  f7fffffe          BL       tcp_segs_free
                  |L1.54|
;;;384        }
;;;385        if (pcb->unsent != NULL) {
000036  6ee0              LDR      r0,[r4,#0x6c]
000038  b108              CBZ      r0,|L1.62|
;;;386          tcp_segs_free(pcb->unsent);
00003a  f7fffffe          BL       tcp_segs_free
                  |L1.62|
;;;387        }
;;;388    #if TCP_QUEUE_OOSEQ    
;;;389        if (pcb->ooseq != NULL) {
00003e  6f60              LDR      r0,[r4,#0x74]
000040  b108              CBZ      r0,|L1.70|
;;;390          tcp_segs_free(pcb->ooseq);
000042  f7fffffe          BL       tcp_segs_free
                  |L1.70|
;;;391        }
;;;392    #endif /* TCP_QUEUE_OOSEQ */
;;;393        if (reset) {
000046  f1b80f00          CMP      r8,#0
00004a  d009              BEQ      |L1.96|
;;;394          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
;;;395          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
00004c  8ba1              LDRH     r1,[r4,#0x1c]
00004e  8b60              LDRH     r0,[r4,#0x1a]
000050  e9cd0100          STRD     r0,r1,[sp,#0]
000054  1d23              ADDS     r3,r4,#4
000056  4622              MOV      r2,r4
000058  4639              MOV      r1,r7
00005a  4648              MOV      r0,r9
00005c  f7fffffe          BL       tcp_rst
                  |L1.96|
;;;396        }
;;;397        memp_free(MEMP_TCP_PCB, pcb);
000060  4621              MOV      r1,r4
000062  2002              MOVS     r0,#2
000064  f7fffffe          BL       memp_free
;;;398        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
000068  2d00              CMP      r5,#0
00006a  d016              BEQ      |L1.154|
00006c  b002              ADD      sp,sp,#8
00006e  4630              MOV      r0,r6
000070  46ac              MOV      r12,r5
000072  e8bd47f0          POP      {r4-r10,lr}
000076  f06f0109          MVN      r1,#9
00007a  4760              BX       r12
                  |L1.124|
00007c  a009              ADR      r0,|L1.164|
00007e  f7fffffe          BL       __2printf
                  |L1.130|
000082  e7fe              B        |L1.130|
                  |L1.132|
000084  4806              LDR      r0,|L1.160|
000086  4621              MOV      r1,r4                 ;372
000088  1d00              ADDS     r0,r0,#4              ;372
00008a  f7fffffe          BL       tcp_pcb_remove
00008e  4621              MOV      r1,r4                 ;373
000090  e8bd47fc          POP      {r2-r10,lr}           ;373
000094  2002              MOVS     r0,#2                 ;373
000096  f7ffbffe          B.W      memp_free
                  |L1.154|
;;;399      }
;;;400    }
00009a  e8bd87fc          POP      {r2-r10,pc}
;;;401    
                          ENDP

00009e  0000              DCW      0x0000
                  |L1.160|
                          DCD      ||.data||+0x18
                  |L1.164|
0000a4  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
0000a8  74206361
0000ac  6c6c2074
0000b0  63705f61
0000b4  626f7274
0000b8  2f746370
0000bc  5f616261
0000c0  6e646f6e
0000c4  20666f72
0000c8  206c6973
0000cc  74656e2d
0000d0  70636273
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i.tcp_abort||, CODE, READONLY, ALIGN=1

                  tcp_abort PROC
;;;412    void
;;;413    tcp_abort(struct tcp_pcb *pcb)
000000  2101              MOVS     r1,#1
;;;414    {
;;;415      tcp_abandon(pcb, 1);
000002  f7ffbffe          B.W      tcp_abandon
;;;416    }
;;;417    
                          ENDP


                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=1

                  tcp_accept PROC
;;;1435   void
;;;1436   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000000  6141              STR      r1,[r0,#0x14]
;;;1437   {
;;;1438     /* This function is allowed to be called for both listen pcbs and
;;;1439        connection pcbs. */
;;;1440     pcb->accept = accept;
;;;1441   }
000002  4770              BX       lr
;;;1442   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=1

                  tcp_accept_null PROC
;;;493    static err_t
;;;494    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  f06f0009          MVN      r0,#9
;;;495    {
;;;496      LWIP_UNUSED_ARG(arg);
;;;497      LWIP_UNUSED_ARG(pcb);
;;;498      LWIP_UNUSED_ARG(err);
;;;499    
;;;500      return ERR_ABRT;
;;;501    }
000004  4770              BX       lr
;;;502    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;1277   struct tcp_pcb *
;;;1278   tcp_alloc(u8_t prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1279   {
000004  4604              MOV      r4,r0
;;;1280     struct tcp_pcb *pcb;
;;;1281     u32_t iss;
;;;1282     
;;;1283     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       memp_malloc
00000c  4d3d              LDR      r5,|L5.260|
00000e  0006              MOVS     r6,r0
;;;1284     if (pcb == NULL) {
000010  d142              BNE      |L5.152|
000012  2300              MOVS     r3,#0
000014  461a              MOV      r2,r3
000016  68ee              LDR      r6,[r5,#0xc]
000018  69e8              LDR      r0,[r5,#0x1c]  ; tcp_tw_pcbs
00001a  e006              B        |L5.42|
                  |L5.28|
00001c  6a41              LDR      r1,[r0,#0x24]
00001e  1a71              SUBS     r1,r6,r1
000020  4299              CMP      r1,r3
000022  d301              BCC      |L5.40|
000024  460b              MOV      r3,r1
000026  4602              MOV      r2,r0
                  |L5.40|
000028  68c0              LDR      r0,[r0,#0xc]
                  |L5.42|
00002a  2800              CMP      r0,#0
00002c  d1f6              BNE      |L5.28|
00002e  b112              CBZ      r2,|L5.54|
000030  4610              MOV      r0,r2
000032  f7fffffe          BL       tcp_abort
                  |L5.54|
;;;1285       /* Try killing oldest connection in TIME-WAIT. */
;;;1286       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
;;;1287       tcp_kill_timewait();
;;;1288       /* Try to allocate a tcp_pcb again. */
;;;1289       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       memp_malloc
;;;1290       if (pcb == NULL) {
;;;1291         /* Try killing active connections with lower priority than the new one. */
;;;1292         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
;;;1293         tcp_kill_prio(prio);
;;;1294         /* Try to allocate a tcp_pcb again. */
;;;1295         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
;;;1296         if (pcb != NULL) {
;;;1297           /* adjust err stats: memp_malloc failed twice before */
;;;1298           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
00003c  f8df80c8          LDR      r8,|L5.264|
000040  0006              MOVS     r6,r0                 ;1289
000042  d124              BNE      |L5.142|
000044  267f              MOVS     r6,#0x7f              ;1290
000046  2700              MOVS     r7,#0                 ;1290
000048  463b              MOV      r3,r7                 ;1290
00004a  f8d5c00c          LDR      r12,[r5,#0xc]         ;1293
00004e  69a8              LDR      r0,[r5,#0x18]         ;1293  ; tcp_active_pcbs
000050  e00d              B        |L5.110|
                  |L5.82|
000052  7e41              LDRB     r1,[r0,#0x19]         ;1293
000054  42a1              CMP      r1,r4                 ;1293
000056  d809              BHI      |L5.108|
000058  42b1              CMP      r1,r6                 ;1293
00005a  d807              BHI      |L5.108|
00005c  6a42              LDR      r2,[r0,#0x24]         ;1293
00005e  ebac0202          SUB      r2,r12,r2             ;1293
000062  42ba              CMP      r2,r7                 ;1293
000064  d302              BCC      |L5.108|
000066  4617              MOV      r7,r2                 ;1293
000068  4603              MOV      r3,r0                 ;1293
00006a  460e              MOV      r6,r1                 ;1293
                  |L5.108|
00006c  68c0              LDR      r0,[r0,#0xc]          ;1293
                  |L5.110|
00006e  2800              CMP      r0,#0                 ;1293
000070  d1ef              BNE      |L5.82|
000072  b113              CBZ      r3,|L5.122|
000074  4618              MOV      r0,r3                 ;1293
000076  f7fffffe          BL       tcp_abort
                  |L5.122|
00007a  2002              MOVS     r0,#2                 ;1295
00007c  f7fffffe          BL       memp_malloc
000080  0006              MOVS     r6,r0                 ;1295
000082  d03c              BEQ      |L5.254|
000084  f8b810e2          LDRH     r1,[r8,#0xe2]  ; lwip_stats
000088  1e49              SUBS     r1,r1,#1
00008a  f8a810e2          STRH     r1,[r8,#0xe2]
                  |L5.142|
;;;1299         }
;;;1300       }
;;;1301       if (pcb != NULL) {
;;;1302         /* adjust err stats: timewait PCB was freed above */
;;;1303         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
00008e  f8b810e2          LDRH     r1,[r8,#0xe2]  ; lwip_stats
000092  1e49              SUBS     r1,r1,#1
000094  f8a810e2          STRH     r1,[r8,#0xe2]
                  |L5.152|
;;;1304       }
;;;1305     }
;;;1306     if (pcb != NULL) {
;;;1307       memset(pcb, 0, sizeof(struct tcp_pcb));
000098  2198              MOVS     r1,#0x98
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       __aeabi_memclr4
;;;1308       pcb->prio = prio;
0000a0  7674              STRB     r4,[r6,#0x19]
;;;1309       pcb->snd_buf = TCP_SND_BUF;
0000a2  f44f607a          MOV      r0,#0xfa0
0000a6  f8a60066          STRH     r0,[r6,#0x66]
;;;1310       pcb->snd_queuelen = 0;
0000aa  2300              MOVS     r3,#0
0000ac  f8a63068          STRH     r3,[r6,#0x68]
;;;1311       pcb->rcv_wnd = TCP_WND;
0000b0  85b0              STRH     r0,[r6,#0x2c]
;;;1312       pcb->rcv_ann_wnd = TCP_WND;
0000b2  85f0              STRH     r0,[r6,#0x2e]
;;;1313       pcb->tos = 0;
0000b4  7273              STRB     r3,[r6,#9]
;;;1314       pcb->ttl = TCP_TTL;
0000b6  20ff              MOVS     r0,#0xff
0000b8  72b0              STRB     r0,[r6,#0xa]
;;;1315       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1316          The send MSS is updated when an MSS option is received. */
;;;1317       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
0000ba  f44f7006          MOV      r0,#0x218
0000be  86f0              STRH     r0,[r6,#0x36]
;;;1318       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
0000c0  2006              MOVS     r0,#6
0000c2  f8a60044          STRH     r0,[r6,#0x44]
;;;1319       pcb->sa = 0;
0000c6  f8a63040          STRH     r3,[r6,#0x40]
;;;1320       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
0000ca  f8a60042          STRH     r0,[r6,#0x42]
;;;1321       pcb->rtime = -1;
0000ce  1fc0              SUBS     r0,r0,#7
0000d0  86b0              STRH     r0,[r6,#0x34]
;;;1322       pcb->cwnd = 1;
0000d2  2001              MOVS     r0,#1
0000d4  f8a6004c          STRH     r0,[r6,#0x4c]
0000d8  3614              ADDS     r6,r6,#0x14
;;;1323       iss = tcp_next_iss();
0000da  f7fffffe          BL       tcp_next_iss
;;;1324       pcb->snd_wl2 = iss;
;;;1325       pcb->snd_nxt = iss;
0000de  6470              STR      r0,[r6,#0x44]
;;;1326       pcb->lastack = iss;
0000e0  63f0              STR      r0,[r6,#0x3c]
;;;1327       pcb->snd_lbb = iss;   
0000e2  6370              STR      r0,[r6,#0x34]
;;;1328       pcb->tmr = tcp_ticks;
0000e4  64b0              STR      r0,[r6,#0x48]
0000e6  68e8              LDR      r0,[r5,#0xc]  ; tcp_ticks
;;;1329       pcb->last_timer = tcp_timer_ctr;
0000e8  6130              STR      r0,[r6,#0x10]
0000ea  78a8              LDRB     r0,[r5,#2]  ; tcp_timer_ctr
0000ec  7370              STRB     r0,[r6,#0xd]
;;;1330   
;;;1331       pcb->polltmr = 0;
0000ee  72f3              STRB     r3,[r6,#0xb]
;;;1332   
;;;1333   #if LWIP_CALLBACK_API
;;;1334       pcb->recv = tcp_recv_null;
0000f0  4806              LDR      r0,|L5.268|
;;;1335   #endif /* LWIP_CALLBACK_API */  
;;;1336       
;;;1337       /* Init KEEPALIVE timer */
;;;1338       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
0000f2  66f0              STR      r0,[r6,#0x6c]
0000f4  4806              LDR      r0,|L5.272|
;;;1339       
;;;1340   #if LWIP_TCP_KEEPALIVE
;;;1341       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1342       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1343   #endif /* LWIP_TCP_KEEPALIVE */
;;;1344   
;;;1345       pcb->keep_cnt_sent = 0;
0000f6  67f0              STR      r0,[r6,#0x7c]
0000f8  f8863082          STRB     r3,[r6,#0x82]
0000fc  3e14              SUBS     r6,r6,#0x14
                  |L5.254|
;;;1346     }
;;;1347     return pcb;
0000fe  4630              MOV      r0,r6
;;;1348   }
000100  e8bd81f0          POP      {r4-r8,pc}
;;;1349   
                          ENDP

                  |L5.260|
                          DCD      ||.data||
                  |L5.264|
                          DCD      lwip_stats
                  |L5.268|
                          DCD      tcp_recv_null
                  |L5.272|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=1

                  tcp_arg PROC
;;;1375   void
;;;1376   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  6101              STR      r1,[r0,#0x10]
;;;1377   {
;;;1378     /* This function is allowed to be called for both listen pcbs and
;;;1379        connection pcbs. */
;;;1380     pcb->callback_arg = arg;
;;;1381   }
000002  4770              BX       lr
;;;1382   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                  tcp_bind PROC
;;;432    err_t
;;;433    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;434    {
000004  4605              MOV      r5,r0
;;;435      int i;
;;;436      int max_pcb_list = NUM_TCP_PCB_LISTS;
;;;437      struct tcp_pcb *cpcb;
;;;438    
;;;439      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
000006  7e00              LDRB     r0,[r0,#0x18]
000008  460c              MOV      r4,r1                 ;434
00000a  2604              MOVS     r6,#4                 ;436
00000c  b130              CBZ      r0,|L7.28|
00000e  a01b              ADR      r0,|L7.124|
000010  f7fffffe          BL       __2printf
000014  f06f0005          MVN      r0,#5
                  |L7.24|
;;;440    
;;;441    #if SO_REUSE
;;;442      /* Unless the REUSEADDR flag is set,
;;;443         we have to check the pcbs in TIME-WAIT state, also.
;;;444         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;445         packets using both local and remote IP addresses and ports to distinguish.
;;;446       */
;;;447      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;448        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;449      }
;;;450    #endif /* SO_REUSE */
;;;451    
;;;452      if (port == 0) {
;;;453        port = tcp_new_port();
;;;454        if (port == 0) {
;;;455          return ERR_BUF;
;;;456        }
;;;457      }
;;;458    
;;;459      /* Check if the address already is in use (on all lists) */
;;;460      for (i = 0; i < max_pcb_list; i++) {
;;;461        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;462          if (cpcb->local_port == port) {
;;;463    #if SO_REUSE
;;;464            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;465               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;466               tcp_connect. */
;;;467            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;468                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;469    #endif /* SO_REUSE */
;;;470            {
;;;471              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;472                  ip_addr_isany(ipaddr) ||
;;;473                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;474                return ERR_USE;
;;;475              }
;;;476            }
;;;477          }
;;;478        }
;;;479      }
;;;480    
;;;481      if (!ip_addr_isany(ipaddr)) {
;;;482        pcb->local_ip = *ipaddr;
;;;483      }
;;;484      pcb->local_port = port;
;;;485      TCP_REG(&tcp_bound_pcbs, pcb);
;;;486      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;487      return ERR_OK;
;;;488    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L7.28|
00001c  b91a              CBNZ     r2,|L7.38|
00001e  f7fffffe          BL       tcp_new_port
000022  0002              MOVS     r2,r0                 ;453
000024  d006              BEQ      |L7.52|
                  |L7.38|
000026  f8dfc07c          LDR      r12,|L7.164|
00002a  2100              MOVS     r1,#0                 ;460
                  |L7.44|
00002c  f85c0021          LDR      r0,[r12,r1,LSL #2]    ;461
000030  6800              LDR      r0,[r0,#0]            ;461
000032  e011              B        |L7.88|
                  |L7.52|
000034  f06f0001          MVN      r0,#1                 ;455
000038  e7ee              B        |L7.24|
                  |L7.58|
00003a  8b43              LDRH     r3,[r0,#0x1a]         ;462
00003c  4293              CMP      r3,r2                 ;462
00003e  d10a              BNE      |L7.86|
000040  b130              CBZ      r0,|L7.80|
000042  6803              LDR      r3,[r0,#0]            ;471
000044  b123              CBZ      r3,|L7.80|
000046  b11c              CBZ      r4,|L7.80|
000048  6827              LDR      r7,[r4,#0]            ;472
00004a  b10f              CBZ      r7,|L7.80|
00004c  42bb              CMP      r3,r7                 ;473
00004e  d102              BNE      |L7.86|
                  |L7.80|
000050  f06f0007          MVN      r0,#7                 ;474
000054  e7e0              B        |L7.24|
                  |L7.86|
000056  68c0              LDR      r0,[r0,#0xc]          ;461
                  |L7.88|
000058  2800              CMP      r0,#0                 ;461
00005a  d1ee              BNE      |L7.58|
00005c  1c49              ADDS     r1,r1,#1              ;461
00005e  42b1              CMP      r1,r6                 ;460
000060  dbe4              BLT      |L7.44|
000062  b114              CBZ      r4,|L7.106|
000064  6820              LDR      r0,[r4,#0]            ;481
000066  b100              CBZ      r0,|L7.106|
000068  6028              STR      r0,[r5,#0]            ;482
                  |L7.106|
00006a  480f              LDR      r0,|L7.168|
00006c  836a              STRH     r2,[r5,#0x1a]         ;484
00006e  6901              LDR      r1,[r0,#0x10]         ;485  ; tcp_bound_pcbs
000070  60e9              STR      r1,[r5,#0xc]          ;485
000072  6105              STR      r5,[r0,#0x10]         ;485  ; tcp_bound_pcbs
000074  f7fffffe          BL       tcp_timer_needed
000078  2000              MOVS     r0,#0                 ;487
00007a  e7cd              B        |L7.24|
;;;489    #if LWIP_CALLBACK_API
                          ENDP

                  |L7.124|
00007c  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
000080  62696e64
000084  3a206361
000088  6e206f6e
00008c  6c792062
000090  696e6420
000094  696e2073
000098  74617465
00009c  20434c4f
0000a0  53454400
                  |L7.164|
                          DCD      ||.constdata||+0x44
                  |L7.168|
                          DCD      ||.data||

                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=1

                  tcp_close PROC
;;;284    err_t
;;;285    tcp_close(struct tcp_pcb *pcb)
000000  7e01              LDRB     r1,[r0,#0x18]
;;;286    {
;;;287    #if TCP_DEBUG
;;;288      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;289      tcp_debug_print_state(pcb->state);
;;;290    #endif /* TCP_DEBUG */
;;;291    
;;;292      if (pcb->state != LISTEN) {
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L8.14|
;;;293        /* Set a flag not to receive any more data... */
;;;294        pcb->flags |= TF_RXCLOSED;
000006  7f81              LDRB     r1,[r0,#0x1e]
000008  f0410110          ORR      r1,r1,#0x10
00000c  7781              STRB     r1,[r0,#0x1e]
                  |L8.14|
;;;295      }
;;;296      /* ... and close */
;;;297      return tcp_close_shutdown(pcb, 1);
00000e  2101              MOVS     r1,#1
000010  f7ffbffe          B.W      tcp_close_shutdown
;;;298    }
;;;299    
                          ENDP


                          AREA ||i.tcp_close_shutdown||, CODE, READONLY, ALIGN=2

                  tcp_close_shutdown PROC
;;;169    static err_t
;;;170    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;171    {
000004  4604              MOV      r4,r0
;;;172      err_t err;
;;;173    
;;;174      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
000006  7e00              LDRB     r0,[r0,#0x18]
;;;175        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
;;;176          /* Not all data received by application, send RST to tell the remote
;;;177             side about this. */
;;;178          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
;;;179    
;;;180          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;181             that might not be expected when calling tcp_close */
;;;182          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
;;;183            pcb->local_port, pcb->remote_port);
;;;184    
;;;185          tcp_pcb_purge(pcb);
;;;186          TCP_RMV_ACTIVE(pcb);
000008  4e49              LDR      r6,|L9.304|
00000a  f04f0900          MOV      r9,#0                 ;171
00000e  2701              MOVS     r7,#1
000010  b3c1              CBZ      r1,|L9.132|
000012  2804              CMP      r0,#4                 ;174
000014  d001              BEQ      |L9.26|
000016  2807              CMP      r0,#7                 ;174
000018  d13d              BNE      |L9.150|
                  |L9.26|
00001a  6fa1              LDR      r1,[r4,#0x78]         ;175
00001c  b919              CBNZ     r1,|L9.38|
00001e  8da1              LDRH     r1,[r4,#0x2c]         ;175
000020  f5b16f7a          CMP      r1,#0xfa0             ;175
000024  d037              BEQ      |L9.150|
                  |L9.38|
000026  7fa0              LDRB     r0,[r4,#0x1e]         ;178
000028  06c0              LSLS     r0,r0,#27             ;178
00002a  d403              BMI      |L9.52|
00002c  a041              ADR      r0,|L9.308|
00002e  f7fffffe          BL       __2printf
                  |L9.50|
000032  e7fe              B        |L9.50|
                  |L9.52|
000034  8ba1              LDRH     r1,[r4,#0x1c]         ;182
000036  8b60              LDRH     r0,[r4,#0x1a]         ;182
000038  e9cd0100          STRD     r0,r1,[sp,#0]         ;182
00003c  1d23              ADDS     r3,r4,#4              ;182
00003e  4622              MOV      r2,r4                 ;182
000040  6aa1              LDR      r1,[r4,#0x28]         ;182
000042  6d20              LDR      r0,[r4,#0x50]         ;182
000044  f7fffffe          BL       tcp_rst
000048  4620              MOV      r0,r4                 ;185
00004a  f7fffffe          BL       tcp_pcb_purge
00004e  69b0              LDR      r0,[r6,#0x18]  ; tcp_active_pcbs
000050  42a0              CMP      r0,r4
000052  d102              BNE      |L9.90|
000054  68c0              LDR      r0,[r0,#0xc]
000056  61b0              STR      r0,[r6,#0x18]  ; tcp_active_pcbs
000058  e007              B        |L9.106|
                  |L9.90|
00005a  6230              STR      r0,[r6,#0x20]  ; tcp_tmp_pcb
00005c  b128              CBZ      r0,|L9.106|
00005e  68c0              LDR      r0,[r0,#0xc]
000060  42a0              CMP      r0,r4
000062  d1fa              BNE      |L9.90|
000064  6a31              LDR      r1,[r6,#0x20]  ; tcp_tmp_pcb
000066  68e0              LDR      r0,[r4,#0xc]
000068  60c8              STR      r0,[r1,#0xc]
                  |L9.106|
00006a  f8c4900c          STR      r9,[r4,#0xc]
00006e  7037              STRB     r7,[r6,#0]
;;;187          if (pcb->state == ESTABLISHED) {
000070  7e20              LDRB     r0,[r4,#0x18]
000072  2804              CMP      r0,#4
000074  d007              BEQ      |L9.134|
;;;188            /* move to TIME_WAIT since we close actively */
;;;189            pcb->state = TIME_WAIT;
;;;190            TCP_REG(&tcp_tw_pcbs, pcb);
;;;191          } else {
;;;192            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;193            memp_free(MEMP_TCP_PCB, pcb);
000076  4621              MOV      r1,r4
000078  2002              MOVS     r0,#2
00007a  f7fffffe          BL       memp_free
                  |L9.126|
;;;194          }
;;;195          return ERR_OK;
00007e  2000              MOVS     r0,#0
                  |L9.128|
;;;196        }
;;;197      }
;;;198    
;;;199      switch (pcb->state) {
;;;200      case CLOSED:
;;;201        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;202         * however, it is in this state once allocated and as yet unused
;;;203         * and the user needs some way to free it should the need arise.
;;;204         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;205         * or for a pcb that has been used and then entered the CLOSED state 
;;;206         * is erroneous, but this should never happen as the pcb has in those cases
;;;207         * been freed, and so any remaining handles are bogus. */
;;;208        err = ERR_OK;
;;;209        if (pcb->local_port != 0) {
;;;210          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;211        }
;;;212        memp_free(MEMP_TCP_PCB, pcb);
;;;213        pcb = NULL;
;;;214        break;
;;;215      case LISTEN:
;;;216        err = ERR_OK;
;;;217        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;218        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;219        pcb = NULL;
;;;220        break;
;;;221      case SYN_SENT:
;;;222        err = ERR_OK;
;;;223        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;224        memp_free(MEMP_TCP_PCB, pcb);
;;;225        pcb = NULL;
;;;226        snmp_inc_tcpattemptfails();
;;;227        break;
;;;228      case SYN_RCVD:
;;;229        err = tcp_send_fin(pcb);
;;;230        if (err == ERR_OK) {
;;;231          snmp_inc_tcpattemptfails();
;;;232          pcb->state = FIN_WAIT_1;
;;;233        }
;;;234        break;
;;;235      case ESTABLISHED:
;;;236        err = tcp_send_fin(pcb);
;;;237        if (err == ERR_OK) {
;;;238          snmp_inc_tcpestabresets();
;;;239          pcb->state = FIN_WAIT_1;
;;;240        }
;;;241        break;
;;;242      case CLOSE_WAIT:
;;;243        err = tcp_send_fin(pcb);
;;;244        if (err == ERR_OK) {
;;;245          snmp_inc_tcpestabresets();
;;;246          pcb->state = LAST_ACK;
;;;247        }
;;;248        break;
;;;249      default:
;;;250        /* Has already been closed, do nothing. */
;;;251        err = ERR_OK;
;;;252        pcb = NULL;
;;;253        break;
;;;254      }
;;;255    
;;;256      if (pcb != NULL && err == ERR_OK) {
;;;257        /* To ensure all data has been sent when tcp_close returns, we have
;;;258           to make sure tcp_output doesn't fail.
;;;259           Since we don't really have to ensure all data has been sent when tcp_close
;;;260           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;261           for the return value of tcp_output for now. */
;;;262        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;263           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;264           This can only be valid for sequential APIs, not for the raw API. */
;;;265        tcp_output(pcb);
;;;266      }
;;;267      return err;
;;;268    }
000080  e8bd87fc          POP      {r2-r10,pc}
                  |L9.132|
000084  e007              B        |L9.150|
                  |L9.134|
000086  200a              MOVS     r0,#0xa               ;189
000088  7620              STRB     r0,[r4,#0x18]         ;189
00008a  69f0              LDR      r0,[r6,#0x1c]         ;190  ; tcp_tw_pcbs
00008c  60e0              STR      r0,[r4,#0xc]          ;190
00008e  61f4              STR      r4,[r6,#0x1c]         ;190  ; tcp_tw_pcbs
000090  f7fffffe          BL       tcp_timer_needed
000094  e7f3              B        |L9.126|
                  |L9.150|
000096  f04f0805          MOV      r8,#5                 ;232
00009a  2808              CMP      r0,#8                 ;199
00009c  d240              BCS      |L9.288|
00009e  e8dff000          TBB      [pc,r0]               ;199
0000a2  041c              DCB      0x04,0x1c
0000a4  252d2d3f          DCB      0x25,0x2d,0x2d,0x3f
0000a8  3f35              DCB      0x3f,0x35
0000aa  8b60              LDRH     r0,[r4,#0x1a]         ;209
0000ac  2500              MOVS     r5,#0                 ;208
0000ae  b178              CBZ      r0,|L9.208|
0000b0  6930              LDR      r0,[r6,#0x10]         ;210  ; tcp_bound_pcbs
0000b2  42a0              CMP      r0,r4                 ;210
0000b4  d102              BNE      |L9.188|
0000b6  68c0              LDR      r0,[r0,#0xc]          ;210
0000b8  6130              STR      r0,[r6,#0x10]         ;210  ; tcp_bound_pcbs
0000ba  e007              B        |L9.204|
                  |L9.188|
0000bc  6230              STR      r0,[r6,#0x20]         ;210  ; tcp_tmp_pcb
0000be  b128              CBZ      r0,|L9.204|
0000c0  68c0              LDR      r0,[r0,#0xc]          ;210
0000c2  42a0              CMP      r0,r4                 ;210
0000c4  d1fa              BNE      |L9.188|
0000c6  6a31              LDR      r1,[r6,#0x20]         ;210  ; tcp_tmp_pcb
0000c8  68e0              LDR      r0,[r4,#0xc]          ;210
0000ca  60c8              STR      r0,[r1,#0xc]          ;210
                  |L9.204|
0000cc  f8c4900c          STR      r9,[r4,#0xc]          ;210
                  |L9.208|
0000d0  4621              MOV      r1,r4                 ;212
0000d2  2002              MOVS     r0,#2                 ;212
                  |L9.212|
0000d4  f7fffffe          BL       memp_free
0000d8  e027              B        |L9.298|
0000da  4815              LDR      r0,|L9.304|
0000dc  2500              MOVS     r5,#0                 ;216
0000de  4621              MOV      r1,r4                 ;217
0000e0  3014              ADDS     r0,r0,#0x14           ;217
0000e2  f7fffffe          BL       tcp_pcb_remove
0000e6  4621              MOV      r1,r4                 ;218
0000e8  2003              MOVS     r0,#3                 ;218
0000ea  e7f3              B        |L9.212|
0000ec  4810              LDR      r0,|L9.304|
0000ee  2500              MOVS     r5,#0                 ;222
0000f0  4621              MOV      r1,r4                 ;223
0000f2  3018              ADDS     r0,r0,#0x18           ;223
0000f4  f7fffffe          BL       tcp_pcb_remove
0000f8  7037              STRB     r7,[r6,#0]            ;223
0000fa  e7e9              B        |L9.208|
0000fc  4620              MOV      r0,r4                 ;236
0000fe  f7fffffe          BL       tcp_send_fin
000102  0005              MOVS     r5,r0                 ;236
000104  d109              BNE      |L9.282|
000106  f8848018          STRB     r8,[r4,#0x18]         ;239
00010a  e006              B        |L9.282|
00010c  4620              MOV      r0,r4                 ;243
00010e  f7fffffe          BL       tcp_send_fin
000112  0005              MOVS     r5,r0                 ;243
000114  d101              BNE      |L9.282|
000116  2009              MOVS     r0,#9                 ;246
000118  7620              STRB     r0,[r4,#0x18]         ;246
                  |L9.282|
00011a  b134              CBZ      r4,|L9.298|
00011c  b115              CBZ      r5,|L9.292|
00011e  e004              B        |L9.298|
                  |L9.288|
000120  2500              MOVS     r5,#0                 ;251
000122  e002              B        |L9.298|
                  |L9.292|
000124  4620              MOV      r0,r4                 ;265
000126  f7fffffe          BL       tcp_output
                  |L9.298|
00012a  4628              MOV      r0,r5                 ;267
00012c  e7a8              B        |L9.128|
;;;269    
                          ENDP

00012e  0000              DCW      0x0000
                  |L9.304|
                          DCD      ||.data||
                  |L9.308|
000134  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
000138  3e666c61
00013c  67732026
000140  2054465f
000144  5258434c
000148  4f534544
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                  tcp_connect PROC
;;;683    err_t
;;;684    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;685          tcp_connected_fn connected)
;;;686    {
000004  4604              MOV      r4,r0
;;;687      err_t ret;
;;;688      u32_t iss;
;;;689      u16_t old_local_port;
;;;690    
;;;691      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
000006  7e00              LDRB     r0,[r0,#0x18]
000008  4698              MOV      r8,r3                 ;686
00000a  460e              MOV      r6,r1                 ;686
00000c  b130              CBZ      r0,|L10.28|
00000e  a03b              ADR      r0,|L10.252|
000010  f7fffffe          BL       __2printf
000014  f06f0008          MVN      r0,#8
                  |L10.24|
;;;692    
;;;693      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;694      if (ipaddr != NULL) {
;;;695        pcb->remote_ip = *ipaddr;
;;;696      } else {
;;;697        return ERR_VAL;
;;;698      }
;;;699      pcb->remote_port = port;
;;;700    
;;;701      /* check if we have a route to the remote host */
;;;702      if (ip_addr_isany(&(pcb->local_ip))) {
;;;703        /* no local IP address set, yet. */
;;;704        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;705        if (netif == NULL) {
;;;706          /* Don't even try to send a SYN packet if we have no route
;;;707             since that will fail. */
;;;708          return ERR_RTE;
;;;709        }
;;;710        /* Use the netif's IP address as local address. */
;;;711        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;712      }
;;;713    
;;;714      old_local_port = pcb->local_port;
;;;715      if (pcb->local_port == 0) {
;;;716        pcb->local_port = tcp_new_port();
;;;717        if (pcb->local_port == 0) {
;;;718          return ERR_BUF;
;;;719        }
;;;720      }
;;;721    #if SO_REUSE
;;;722      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;723        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;724           now that the 5-tuple is unique. */
;;;725        struct tcp_pcb *cpcb;
;;;726        int i;
;;;727        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;728        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;729          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;730            if ((cpcb->local_port == pcb->local_port) &&
;;;731                (cpcb->remote_port == port) &&
;;;732                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;733                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;734              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;735              return ERR_USE;
;;;736            }
;;;737          }
;;;738        }
;;;739      }
;;;740    #endif /* SO_REUSE */
;;;741      iss = tcp_next_iss();
;;;742      pcb->rcv_nxt = 0;
;;;743      pcb->snd_nxt = iss;
;;;744      pcb->lastack = iss - 1;
;;;745      pcb->snd_lbb = iss - 1;
;;;746      pcb->rcv_wnd = TCP_WND;
;;;747      pcb->rcv_ann_wnd = TCP_WND;
;;;748      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;749      pcb->snd_wnd = TCP_WND;
;;;750      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;751         The send MSS is updated when an MSS option is received. */
;;;752      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;753    #if TCP_CALCULATE_EFF_SEND_MSS
;;;754      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;755    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;756      pcb->cwnd = 1;
;;;757      pcb->ssthresh = pcb->mss * 10;
;;;758    #if LWIP_CALLBACK_API
;;;759      pcb->connected = connected;
;;;760    #else /* LWIP_CALLBACK_API */  
;;;761      LWIP_UNUSED_ARG(connected);
;;;762    #endif /* LWIP_CALLBACK_API */
;;;763    
;;;764      /* Send a SYN together with the MSS option. */
;;;765      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;766      if (ret == ERR_OK) {
;;;767        /* SYN segment was enqueued, changed the pcbs state now */
;;;768        pcb->state = SYN_SENT;
;;;769        if (old_local_port != 0) {
;;;770          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;771        }
;;;772        TCP_REG_ACTIVE(pcb);
;;;773        snmp_inc_tcpactiveopens();
;;;774    
;;;775        tcp_output(pcb);
;;;776      }
;;;777      return ret;
;;;778    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L10.28|
00001c  b136              CBZ      r6,|L10.44|
00001e  6830              LDR      r0,[r6,#0]            ;695
000020  6060              STR      r0,[r4,#4]            ;699
000022  83a2              STRH     r2,[r4,#0x1c]         ;699
000024  b12c              CBZ      r4,|L10.50|
000026  6820              LDR      r0,[r4,#0]            ;702
000028  b118              CBZ      r0,|L10.50|
00002a  e008              B        |L10.62|
                  |L10.44|
00002c  f06f0005          MVN      r0,#5                 ;697
000030  e7f2              B        |L10.24|
                  |L10.50|
000032  1d20              ADDS     r0,r4,#4              ;704
000034  f7fffffe          BL       ip_route
000038  b120              CBZ      r0,|L10.68|
00003a  6840              LDR      r0,[r0,#4]            ;711
00003c  6020              STR      r0,[r4,#0]            ;711
                  |L10.62|
00003e  8b65              LDRH     r5,[r4,#0x1a]         ;714
000040  b11d              CBZ      r5,|L10.74|
000042  e006              B        |L10.82|
                  |L10.68|
000044  f06f0003          MVN      r0,#3                 ;708
000048  e7e6              B        |L10.24|
                  |L10.74|
00004a  f7fffffe          BL       tcp_new_port
00004e  8360              STRH     r0,[r4,#0x1a]         ;716
000050  b350              CBZ      r0,|L10.168|
                  |L10.82|
000052  f7fffffe          BL       tcp_next_iss
000056  f04f0900          MOV      r9,#0                 ;742
00005a  f8449f28          STR      r9,[r4,#0x28]!        ;742
00005e  4631              MOV      r1,r6                 ;754
000060  62a0              STR      r0,[r4,#0x28]         ;743
000062  1e40              SUBS     r0,r0,#1              ;743
000064  6220              STR      r0,[r4,#0x20]         ;745
000066  6360              STR      r0,[r4,#0x34]         ;746
000068  f44f607a          MOV      r0,#0xfa0             ;746
00006c  80a0              STRH     r0,[r4,#4]            ;746
00006e  80e0              STRH     r0,[r4,#6]            ;747
000070  f8c49008          STR      r9,[r4,#8]            ;749
000074  8720              STRH     r0,[r4,#0x38]         ;749
000076  f44f7006          MOV      r0,#0x218             ;752
00007a  81e0              STRH     r0,[r4,#0xe]          ;752
00007c  f7fffffe          BL       tcp_eff_send_mss
000080  81e0              STRH     r0,[r4,#0xe]          ;754
000082  eb000080          ADD      r0,r0,r0,LSL #2       ;757
000086  f64f71ff          MOV      r1,#0xffff            ;757
00008a  2701              MOVS     r7,#1                 ;756
00008c  ea010040          AND      r0,r1,r0,LSL #1       ;757
000090  84a7              STRH     r7,[r4,#0x24]         ;756
000092  84e0              STRH     r0,[r4,#0x26]         ;757
000094  f8c4805c          STR      r8,[r4,#0x5c]         ;765
000098  3c28              SUBS     r4,r4,#0x28           ;765
00009a  2102              MOVS     r1,#2                 ;765
00009c  4620              MOV      r0,r4                 ;765
00009e  f7fffffe          BL       tcp_enqueue_flags
0000a2  0006              MOVS     r6,r0                 ;765
0000a4  d003              BEQ      |L10.174|
0000a6  e027              B        |L10.248|
                  |L10.168|
0000a8  f06f0001          MVN      r0,#1                 ;718
0000ac  e7b4              B        |L10.24|
                  |L10.174|
0000ae  2002              MOVS     r0,#2                 ;768
0000b0  f8df8078          LDR      r8,|L10.300|
0000b4  7620              STRB     r0,[r4,#0x18]         ;768
0000b6  b19d              CBZ      r5,|L10.224|
0000b8  f8d80010          LDR      r0,[r8,#0x10]         ;770  ; tcp_bound_pcbs
0000bc  42a0              CMP      r0,r4                 ;770
0000be  d103              BNE      |L10.200|
0000c0  68c0              LDR      r0,[r0,#0xc]          ;770
0000c2  f8c80010          STR      r0,[r8,#0x10]         ;770  ; tcp_bound_pcbs
0000c6  e009              B        |L10.220|
                  |L10.200|
0000c8  f8c80020          STR      r0,[r8,#0x20]         ;770  ; tcp_tmp_pcb
0000cc  b130              CBZ      r0,|L10.220|
0000ce  68c0              LDR      r0,[r0,#0xc]          ;770
0000d0  42a0              CMP      r0,r4                 ;770
0000d2  d1f9              BNE      |L10.200|
0000d4  f8d81020          LDR      r1,[r8,#0x20]         ;770  ; tcp_tmp_pcb
0000d8  68e0              LDR      r0,[r4,#0xc]          ;770
0000da  60c8              STR      r0,[r1,#0xc]          ;770
                  |L10.220|
0000dc  f8c4900c          STR      r9,[r4,#0xc]          ;770
                  |L10.224|
0000e0  f8d80018          LDR      r0,[r8,#0x18]         ;772  ; tcp_active_pcbs
0000e4  60e0              STR      r0,[r4,#0xc]          ;772
0000e6  f8c84018          STR      r4,[r8,#0x18]         ;772  ; tcp_active_pcbs
0000ea  f7fffffe          BL       tcp_timer_needed
0000ee  f8887000          STRB     r7,[r8,#0]            ;772
0000f2  4620              MOV      r0,r4                 ;775
0000f4  f7fffffe          BL       tcp_output
                  |L10.248|
0000f8  4630              MOV      r0,r6                 ;777
0000fa  e78d              B        |L10.24|
;;;779    
                          ENDP

                  |L10.252|
0000fc  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
000100  636f6e6e
000104  6563743a
000108  2063616e
00010c  206f6e6c
000110  7920636f
000114  6e6e6563
000118  74206672
00011c  6f6d2073
000120  74617465
000124  20434c4f
000128  53454400
                  |L10.300|
                          DCD      ||.data||

                          AREA ||i.tcp_debug_state_str||, CODE, READONLY, ALIGN=2

                  tcp_debug_state_str PROC
;;;1604   const char*
;;;1605   tcp_debug_state_str(enum tcp_state s)
000000  4901              LDR      r1,|L11.8|
;;;1606   {
;;;1607     return tcp_state_str[s];
000002  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;1608   }
000006  4770              BX       lr
;;;1609   
                          ENDP

                  |L11.8|
                          DCD      ||.constdata||+0x8

                          AREA ||i.tcp_eff_send_mss||, CODE, READONLY, ALIGN=1

                  tcp_eff_send_mss PROC
;;;1585   u16_t
;;;1586   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
000000  b510              PUSH     {r4,lr}
;;;1587   {
000002  4604              MOV      r4,r0
;;;1588     u16_t mss_s;
;;;1589     struct netif *outif;
;;;1590   
;;;1591     outif = ip_route(addr);
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       ip_route
;;;1592     if ((outif != NULL) && (outif->mtu != 0)) {
00000a  b138              CBZ      r0,|L12.28|
00000c  8c00              LDRH     r0,[r0,#0x20]
00000e  b128              CBZ      r0,|L12.28|
000010  3828              SUBS     r0,r0,#0x28
;;;1593       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
000012  b280              UXTH     r0,r0
;;;1594       /* RFC 1122, chap 4.2.2.6:
;;;1595        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1596        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1597        */
;;;1598       sendmss = LWIP_MIN(sendmss, mss_s);
000014  4284              CMP      r4,r0
000016  d200              BCS      |L12.26|
000018  4620              MOV      r0,r4
                  |L12.26|
00001a  4604              MOV      r4,r0
                  |L12.28|
;;;1599     }
;;;1600     return sendmss;
00001c  4620              MOV      r0,r4
;;;1601   }
00001e  bd10              POP      {r4,pc}
;;;1602   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP


                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=2

                  tcp_err PROC
;;;1420   void
;;;1421   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000000  b510              PUSH     {r4,lr}
;;;1422   {
;;;1423     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
000002  7e02              LDRB     r2,[r0,#0x18]
000004  2a01              CMP      r2,#1
000006  d002              BEQ      |L13.14|
;;;1424     pcb->errf = err;
;;;1425   }
000008  f8c0108c          STR      r1,[r0,#0x8c]
00000c  bd10              POP      {r4,pc}
                  |L13.14|
00000e  a002              ADR      r0,|L13.24|
000010  f7fffffe          BL       __2printf
                  |L13.20|
000014  e7fe              B        |L13.20|
;;;1426   
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
000018  696e7661          DCB      "invalid socket state for err callback",0
00001c  6c696420
000020  736f636b
000024  65742073
000028  74617465
00002c  20666f72
000030  20657272
000034  2063616c
000038  6c626163
00003c  6b00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;1045   void
;;;1046   tcp_fasttmr(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1047   {
;;;1048     struct tcp_pcb *pcb;
;;;1049   
;;;1050     ++tcp_timer_ctr;
000004  4e14              LDR      r6,|L14.88|
000006  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000008  1c40              ADDS     r0,r0,#1
00000a  70b0              STRB     r0,[r6,#2]
                  |L14.12|
;;;1051   
;;;1052   tcp_fasttmr_start:
;;;1053     pcb = tcp_active_pcbs;
00000c  2700              MOVS     r7,#0
;;;1054   
;;;1055     while(pcb != NULL) {
00000e  69b4              LDR      r4,[r6,#0x18]  ; tcp_active_pcbs
000010  e01e              B        |L14.80|
                  |L14.18|
;;;1056       if (pcb->last_timer != tcp_timer_ctr) {
000012  f8941021          LDRB     r1,[r4,#0x21]
000016  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000018  4281              CMP      r1,r0
00001a  d019              BEQ      |L14.80|
;;;1057         struct tcp_pcb *next;
;;;1058         pcb->last_timer = tcp_timer_ctr;
00001c  f8840021          STRB     r0,[r4,#0x21]
;;;1059         /* send delayed ACKs */
;;;1060         if (pcb->flags & TF_ACK_DELAY) {
000020  7fa0              LDRB     r0,[r4,#0x1e]
000022  07c1              LSLS     r1,r0,#31
000024  d009              BEQ      |L14.58|
;;;1061           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
;;;1062           tcp_ack_now(pcb);
000026  f0400002          ORR      r0,r0,#2
00002a  77a0              STRB     r0,[r4,#0x1e]
;;;1063           tcp_output(pcb);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       tcp_output
;;;1064           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000032  7fa0              LDRB     r0,[r4,#0x1e]
000034  f0200003          BIC      r0,r0,#3
000038  77a0              STRB     r0,[r4,#0x1e]
                  |L14.58|
;;;1065         }
;;;1066   
;;;1067         next = pcb->next;
;;;1068   
;;;1069         /* If there is data which was previously "refused" by upper layer */
;;;1070         if (pcb->refused_data != NULL) {
00003a  68e5              LDR      r5,[r4,#0xc]
00003c  6fa0              LDR      r0,[r4,#0x78]
00003e  b130              CBZ      r0,|L14.78|
;;;1071           tcp_active_pcbs_changed = 0;
000040  7037              STRB     r7,[r6,#0]
;;;1072           tcp_process_refused_data(pcb);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       tcp_process_refused_data
;;;1073           if (tcp_active_pcbs_changed) {
000048  7830              LDRB     r0,[r6,#0]  ; tcp_active_pcbs_changed
00004a  2800              CMP      r0,#0
00004c  d1de              BNE      |L14.12|
                  |L14.78|
;;;1074             /* application callback has changed the pcb list: restart the loop */
;;;1075             goto tcp_fasttmr_start;
;;;1076           }
;;;1077         }
;;;1078         pcb = next;
00004e  462c              MOV      r4,r5
                  |L14.80|
000050  2c00              CMP      r4,#0                 ;1055
000052  d1de              BNE      |L14.18|
;;;1079       }
;;;1080     }
;;;1081   }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;1082   
                          ENDP

                  |L14.88|
                          DCD      ||.data||

                          AREA ||i.tcp_init||, CODE, READONLY, ALIGN=1

                  tcp_init PROC
;;;129    void
;;;130    tcp_init(void)
000000  4770              BX       lr
;;;131    {
;;;132    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;133      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;134    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;135    }
;;;136    
                          ENDP


                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=2

                  tcp_listen_with_backlog PROC
;;;518    struct tcp_pcb *
;;;519    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  b570              PUSH     {r4-r6,lr}
;;;520    {
000002  4604              MOV      r4,r0
;;;521      struct tcp_pcb_listen *lpcb;
;;;522    
;;;523      LWIP_UNUSED_ARG(backlog);
;;;524      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
000004  7e00              LDRB     r0,[r0,#0x18]
000006  b120              CBZ      r0,|L16.18|
000008  a01e              ADR      r0,|L16.132|
00000a  f7fffffe          BL       __2printf
00000e  2000              MOVS     r0,#0
                  |L16.16|
;;;525    
;;;526      /* already listening? */
;;;527      if (pcb->state == LISTEN) {
;;;528        return pcb;
;;;529      }
;;;530    #if SO_REUSE
;;;531      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;532        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;533           is declared (listen-/connection-pcb), we have to make sure now that
;;;534           this port is only used once for every local IP. */
;;;535        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;536          if (lpcb->local_port == pcb->local_port) {
;;;537            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;538              /* this address/port is already used */
;;;539              return NULL;
;;;540            }
;;;541          }
;;;542        }
;;;543      }
;;;544    #endif /* SO_REUSE */
;;;545      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;546      if (lpcb == NULL) {
;;;547        return NULL;
;;;548      }
;;;549      lpcb->callback_arg = pcb->callback_arg;
;;;550      lpcb->local_port = pcb->local_port;
;;;551      lpcb->state = LISTEN;
;;;552      lpcb->prio = pcb->prio;
;;;553      lpcb->so_options = pcb->so_options;
;;;554      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;555      lpcb->ttl = pcb->ttl;
;;;556      lpcb->tos = pcb->tos;
;;;557      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;558      if (pcb->local_port != 0) {
;;;559        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;560      }
;;;561      memp_free(MEMP_TCP_PCB, pcb);
;;;562    #if LWIP_CALLBACK_API
;;;563      lpcb->accept = tcp_accept_null;
;;;564    #endif /* LWIP_CALLBACK_API */
;;;565    #if TCP_LISTEN_BACKLOG
;;;566      lpcb->accepts_pending = 0;
;;;567      lpcb->backlog = (backlog ? backlog : 1);
;;;568    #endif /* TCP_LISTEN_BACKLOG */
;;;569      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;570      return (struct tcp_pcb *)lpcb;
;;;571    }
000010  bd70              POP      {r4-r6,pc}
                  |L16.18|
000012  2003              MOVS     r0,#3                 ;545
000014  f7fffffe          BL       memp_malloc
000018  1e05              SUBS     r5,r0,#0              ;545
00001a  d0f9              BEQ      |L16.16|
00001c  6920              LDR      r0,[r4,#0x10]         ;549
00001e  6128              STR      r0,[r5,#0x10]         ;550
000020  8b60              LDRH     r0,[r4,#0x1a]         ;550
000022  8368              STRH     r0,[r5,#0x1a]         ;550
000024  2001              MOVS     r0,#1                 ;551
000026  7628              STRB     r0,[r5,#0x18]         ;551
000028  7e60              LDRB     r0,[r4,#0x19]         ;552
00002a  7668              STRB     r0,[r5,#0x19]         ;552
00002c  7a20              LDRB     r0,[r4,#8]            ;553
00002e  f0400002          ORR      r0,r0,#2              ;554
000032  7228              STRB     r0,[r5,#8]            ;554
000034  7aa0              LDRB     r0,[r4,#0xa]          ;555
000036  72a8              STRB     r0,[r5,#0xa]          ;555
000038  7a60              LDRB     r0,[r4,#9]            ;556
00003a  7268              STRB     r0,[r5,#9]            ;556
00003c  6820              LDR      r0,[r4,#0]            ;557
00003e  6028              STR      r0,[r5,#0]            ;558
000040  8b60              LDRH     r0,[r4,#0x1a]         ;558
000042  b180              CBZ      r0,|L16.102|
000044  4918              LDR      r1,|L16.168|
000046  6908              LDR      r0,[r1,#0x10]         ;559  ; tcp_bound_pcbs
000048  42a0              CMP      r0,r4                 ;559
00004a  d102              BNE      |L16.82|
00004c  68c0              LDR      r0,[r0,#0xc]          ;559
00004e  6108              STR      r0,[r1,#0x10]         ;559  ; tcp_bound_pcbs
000050  e007              B        |L16.98|
                  |L16.82|
000052  6208              STR      r0,[r1,#0x20]         ;559  ; tcp_tmp_pcb
000054  b128              CBZ      r0,|L16.98|
000056  68c0              LDR      r0,[r0,#0xc]          ;559
000058  42a0              CMP      r0,r4                 ;559
00005a  d1fa              BNE      |L16.82|
00005c  6a09              LDR      r1,[r1,#0x20]         ;559  ; tcp_tmp_pcb
00005e  68e0              LDR      r0,[r4,#0xc]          ;559
000060  60c8              STR      r0,[r1,#0xc]          ;559
                  |L16.98|
000062  2000              MOVS     r0,#0                 ;559
000064  60e0              STR      r0,[r4,#0xc]          ;559
                  |L16.102|
000066  4621              MOV      r1,r4                 ;561
000068  2002              MOVS     r0,#2                 ;561
00006a  f7fffffe          BL       memp_free
00006e  480f              LDR      r0,|L16.172|
000070  6168              STR      r0,[r5,#0x14]         ;569
000072  480d              LDR      r0,|L16.168|
000074  3014              ADDS     r0,r0,#0x14           ;569
000076  6801              LDR      r1,[r0,#0]            ;569  ; tcp_listen_pcbs
000078  60e9              STR      r1,[r5,#0xc]          ;569
00007a  6005              STR      r5,[r0,#0]            ;569  ; tcp_listen_pcbs
00007c  f7fffffe          BL       tcp_timer_needed
000080  4628              MOV      r0,r5                 ;570
000082  bd70              POP      {r4-r6,pc}
;;;572    
                          ENDP

                  |L16.132|
000084  7463705f          DCB      "tcp_listen: pcb already connected",0
000088  6c697374
00008c  656e3a20
000090  70636220
000094  616c7265
000098  61647920
00009c  636f6e6e
0000a0  65637465
0000a4  6400    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L16.168|
                          DCD      ||.data||
                  |L16.172|
                          DCD      tcp_accept_null

                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=1

                  tcp_new PROC
;;;1362   struct tcp_pcb *
;;;1363   tcp_new(void)
000000  2040              MOVS     r0,#0x40
;;;1364   {
;;;1365     return tcp_alloc(TCP_PRIO_NORMAL);
000002  f7ffbffe          B.W      tcp_alloc
;;;1366   }
;;;1367   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;646    static u16_t
;;;647    tcp_new_port(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;648    {
;;;649      u8_t i;
;;;650      u16_t n = 0;
;;;651      struct tcp_pcb *pcb;
;;;652      
;;;653    again:
;;;654      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
;;;655        tcp_port = TCP_LOCAL_PORT_RANGE_START;
;;;656      }
;;;657      /* Check all PCB lists. */
;;;658      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
;;;659        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
000002  4d14              LDR      r5,|L18.84|
000004  4e14              LDR      r6,|L18.88|
000006  2400              MOVS     r4,#0                 ;650
000008  f64f77ff          MOV      r7,#0xffff            ;654
00000c  f44f4c40          MOV      r12,#0xc000           ;655
;;;660          if (pcb->local_port == tcp_port) {
;;;661            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
000010  f44f4e80          MOV      lr,#0x4000
                  |L18.20|
000014  88b0              LDRH     r0,[r6,#4]            ;654  ; tcp_port
000016  1c41              ADDS     r1,r0,#1              ;654
000018  80b1              STRH     r1,[r6,#4]            ;654
00001a  42b8              CMP      r0,r7                 ;654
00001c  d101              BNE      |L18.34|
00001e  f8a6c004          STRH     r12,[r6,#4]           ;655
                  |L18.34|
000022  88b2              LDRH     r2,[r6,#4]            ;654
000024  2100              MOVS     r1,#0                 ;658
                  |L18.38|
000026  f8550021          LDR      r0,[r5,r1,LSL #2]     ;659
00002a  6800              LDR      r0,[r0,#0]            ;659
00002c  e009              B        |L18.66|
                  |L18.46|
00002e  8b43              LDRH     r3,[r0,#0x1a]         ;660
000030  4293              CMP      r3,r2                 ;660
000032  d105              BNE      |L18.64|
000034  1c64              ADDS     r4,r4,#1              ;660
000036  b2a4              UXTH     r4,r4
000038  4574              CMP      r4,lr
00003a  d3eb              BCC      |L18.20|
;;;662              return 0;
00003c  2000              MOVS     r0,#0
;;;663            }
;;;664            goto again;
;;;665          }
;;;666        }
;;;667      }
;;;668      return tcp_port;
;;;669    }
00003e  bdf0              POP      {r4-r7,pc}
                  |L18.64|
000040  68c0              LDR      r0,[r0,#0xc]          ;659
                  |L18.66|
000042  2800              CMP      r0,#0                 ;659
000044  d1f3              BNE      |L18.46|
000046  1c49              ADDS     r1,r1,#1              ;659
000048  b2c9              UXTB     r1,r1                 ;658
00004a  2904              CMP      r1,#4                 ;658
00004c  d3eb              BCC      |L18.38|
00004e  b290              UXTH     r0,r2                 ;668
000050  bdf0              POP      {r4-r7,pc}
;;;670    
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      ||.constdata||+0x44
                  |L18.88|
                          DCD      ||.data||

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                  tcp_next_iss PROC
;;;1570   u32_t
;;;1571   tcp_next_iss(void)
000000  4902              LDR      r1,|L19.12|
;;;1572   {
;;;1573     static u32_t iss = 6510;
;;;1574     
;;;1575     iss += tcp_ticks;       /* XXX */
000002  e9d10202          LDRD     r0,r2,[r1,#8]
000006  4410              ADD      r0,r0,r2
000008  6088              STR      r0,[r1,#8]  ; iss
;;;1576     return iss;
;;;1577   }
00000a  4770              BX       lr
;;;1578   
                          ENDP

                  |L19.12|
                          DCD      ||.data||

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=1

                  tcp_pcb_purge PROC
;;;1469   void
;;;1470   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1471   {
000002  4604              MOV      r4,r0
;;;1472     if (pcb->state != CLOSED &&
000004  7e00              LDRB     r0,[r0,#0x18]
000006  2800              CMP      r0,#0                 ;1471
000008  d01a              BEQ      |L20.64|
;;;1473        pcb->state != TIME_WAIT &&
00000a  280a              CMP      r0,#0xa
00000c  d018              BEQ      |L20.64|
;;;1474        pcb->state != LISTEN) {
00000e  2801              CMP      r0,#1
000010  d016              BEQ      |L20.64|
;;;1475   
;;;1476       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
;;;1477   
;;;1478   #if TCP_LISTEN_BACKLOG
;;;1479       if (pcb->state == SYN_RCVD) {
;;;1480         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1481         struct tcp_pcb_listen *lpcb;
;;;1482         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
;;;1483           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1484         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;1485           if ((lpcb->local_port == pcb->local_port) &&
;;;1486               (ip_addr_isany(&lpcb->local_ip) ||
;;;1487                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
;;;1488               /* port and address of the listen pcb match the timed-out pcb */
;;;1489               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
;;;1490                 lpcb->accepts_pending > 0);
;;;1491               lpcb->accepts_pending--;
;;;1492               break;
;;;1493             }
;;;1494         }
;;;1495       }
;;;1496   #endif /* TCP_LISTEN_BACKLOG */
;;;1497   
;;;1498   
;;;1499       if (pcb->refused_data != NULL) {
000012  6fa0              LDR      r0,[r4,#0x78]
000014  2500              MOVS     r5,#0
000016  b110              CBZ      r0,|L20.30|
;;;1500         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
;;;1501         pbuf_free(pcb->refused_data);
000018  f7fffffe          BL       pbuf_free
;;;1502         pcb->refused_data = NULL;
00001c  67a5              STR      r5,[r4,#0x78]
                  |L20.30|
;;;1503       }
;;;1504       if (pcb->unsent != NULL) {
;;;1505         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
;;;1506       }
;;;1507       if (pcb->unacked != NULL) {
;;;1508         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
;;;1509       }
;;;1510   #if TCP_QUEUE_OOSEQ
;;;1511       if (pcb->ooseq != NULL) {
;;;1512         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;1513       }
;;;1514       tcp_segs_free(pcb->ooseq);
00001e  6f60              LDR      r0,[r4,#0x74]
000020  f7fffffe          BL       tcp_segs_free
;;;1515       pcb->ooseq = NULL;
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517   
;;;1518       /* Stop the retransmission timer as it will expect data on unacked
;;;1519          queue if it fires */
;;;1520       pcb->rtime = -1;
000024  f04f30ff          MOV      r0,#0xffffffff
000028  6765              STR      r5,[r4,#0x74]
00002a  86a0              STRH     r0,[r4,#0x34]
;;;1521   
;;;1522       tcp_segs_free(pcb->unsent);
00002c  6ee0              LDR      r0,[r4,#0x6c]
00002e  f7fffffe          BL       tcp_segs_free
;;;1523       tcp_segs_free(pcb->unacked);
000032  6f20              LDR      r0,[r4,#0x70]
000034  f7fffffe          BL       tcp_segs_free
;;;1524       pcb->unacked = pcb->unsent = NULL;
000038  66e5              STR      r5,[r4,#0x6c]
;;;1525   #if TCP_OVERSIZE
;;;1526       pcb->unsent_oversize = 0;
00003a  6725              STR      r5,[r4,#0x70]
00003c  f8a4506a          STRH     r5,[r4,#0x6a]
                  |L20.64|
;;;1527   #endif /* TCP_OVERSIZE */
;;;1528     }
;;;1529   }
000040  bd70              POP      {r4-r6,pc}
;;;1530   
                          ENDP


                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                  tcp_pcb_remove PROC
;;;1537   void
;;;1538   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1539   {
000002  460c              MOV      r4,r1
000004  4601              MOV      r1,r0
;;;1540     TCP_RMV(pcblist, pcb);
000006  6800              LDR      r0,[r0,#0]
000008  42a0              CMP      r0,r4
00000a  d102              BNE      |L21.18|
00000c  68c0              LDR      r0,[r0,#0xc]
00000e  6008              STR      r0,[r1,#0]
000010  e00b              B        |L21.42|
                  |L21.18|
000012  491b              LDR      r1,|L21.128|
000014  e006              B        |L21.36|
                  |L21.22|
000016  68c0              LDR      r0,[r0,#0xc]
000018  42a0              CMP      r0,r4
00001a  d103              BNE      |L21.36|
00001c  6a09              LDR      r1,[r1,#0x20]  ; tcp_tmp_pcb
00001e  68e0              LDR      r0,[r4,#0xc]
000020  60c8              STR      r0,[r1,#0xc]
000022  e002              B        |L21.42|
                  |L21.36|
000024  6208              STR      r0,[r1,#0x20]  ; tcp_tmp_pcb
000026  2800              CMP      r0,#0
000028  d1f5              BNE      |L21.22|
                  |L21.42|
00002a  2500              MOVS     r5,#0
;;;1541   
;;;1542     tcp_pcb_purge(pcb);
00002c  4620              MOV      r0,r4
00002e  60e5              STR      r5,[r4,#0xc]
000030  f7fffffe          BL       tcp_pcb_purge
;;;1543     
;;;1544     /* if there is an outstanding delayed ACKs, send it */
;;;1545     if (pcb->state != TIME_WAIT &&
000034  7e20              LDRB     r0,[r4,#0x18]
000036  280a              CMP      r0,#0xa
000038  d00d              BEQ      |L21.86|
;;;1546        pcb->state != LISTEN &&
00003a  2801              CMP      r0,#1
00003c  d01d              BEQ      |L21.122|
;;;1547        pcb->flags & TF_ACK_DELAY) {
00003e  7fa0              LDRB     r0,[r4,#0x1e]
000040  07c1              LSLS     r1,r0,#31
000042  d008              BEQ      |L21.86|
;;;1548       pcb->flags |= TF_ACK_NOW;
000044  f0400002          ORR      r0,r0,#2
000048  77a0              STRB     r0,[r4,#0x1e]
;;;1549       tcp_output(pcb);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       tcp_output
;;;1550     }
;;;1551   
;;;1552     if (pcb->state != LISTEN) {
000050  7e20              LDRB     r0,[r4,#0x18]
000052  2801              CMP      r0,#1
000054  d011              BEQ      |L21.122|
                  |L21.86|
;;;1553       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
000056  6ee0              LDR      r0,[r4,#0x6c]
000058  b118              CBZ      r0,|L21.98|
00005a  a00a              ADR      r0,|L21.132|
00005c  f7fffffe          BL       __2printf
                  |L21.96|
000060  e7fe              B        |L21.96|
                  |L21.98|
;;;1554       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
000062  6f20              LDR      r0,[r4,#0x70]
000064  b118              CBZ      r0,|L21.110|
000066  a00d              ADR      r0,|L21.156|
000068  f7fffffe          BL       __2printf
                  |L21.108|
00006c  e7fe              B        |L21.108|
                  |L21.110|
;;;1555   #if TCP_QUEUE_OOSEQ
;;;1556       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
00006e  6f60              LDR      r0,[r4,#0x74]
000070  b118              CBZ      r0,|L21.122|
000072  a011              ADR      r0,|L21.184|
000074  f7fffffe          BL       __2printf
                  |L21.120|
000078  e7fe              B        |L21.120|
                  |L21.122|
;;;1557   #endif /* TCP_QUEUE_OOSEQ */
;;;1558     }
;;;1559   
;;;1560     pcb->state = CLOSED;
00007a  7625              STRB     r5,[r4,#0x18]
;;;1561   
;;;1562     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;1563   }
00007c  bd70              POP      {r4-r6,pc}
;;;1564   
                          ENDP

00007e  0000              DCW      0x0000
                  |L21.128|
                          DCD      ||.data||
                  |L21.132|
000084  756e7365          DCB      "unsent segments leaking",0
000088  6e742073
00008c  65676d65
000090  6e747320
000094  6c65616b
000098  696e6700
                  |L21.156|
00009c  756e6163          DCB      "unacked segments leaking",0
0000a0  6b656420
0000a4  7365676d
0000a8  656e7473
0000ac  206c6561
0000b0  6b696e67
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L21.184|
0000b8  6f6f7365          DCB      "ooseq segments leaking",0
0000bc  71207365
0000c0  676d656e
0000c4  7473206c
0000c8  65616b69
0000cc  6e6700  
0000cf  00                DCB      0

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=2

                  tcp_poll PROC
;;;1451   void
;;;1452   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000000  b510              PUSH     {r4,lr}
;;;1453   {
;;;1454     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
000002  7e03              LDRB     r3,[r0,#0x18]
000004  2b01              CMP      r3,#1
000006  d004              BEQ      |L22.18|
;;;1455   #if LWIP_CALLBACK_API
;;;1456     pcb->poll = poll;
;;;1457   #else /* LWIP_CALLBACK_API */  
;;;1458     LWIP_UNUSED_ARG(poll);
;;;1459   #endif /* LWIP_CALLBACK_API */  
;;;1460     pcb->pollinterval = interval;
000008  f8c01088          STR      r1,[r0,#0x88]
00000c  f8802020          STRB     r2,[r0,#0x20]
;;;1461   }
000010  bd10              POP      {r4,pc}
                  |L22.18|
000012  a002              ADR      r0,|L22.28|
000014  f7fffffe          BL       __2printf
                  |L22.24|
000018  e7fe              B        |L22.24|
;;;1462   
                          ENDP

00001a  0000              DCW      0x0000
                  |L22.28|
00001c  696e7661          DCB      "invalid socket state for poll",0
000020  6c696420
000024  736f636b
000028  65742073
00002c  74617465
000030  20666f72
000034  20706f6c
000038  6c00    
00003a  00                DCB      0
00003b  00                DCB      0

                          AREA ||i.tcp_process_refused_data||, CODE, READONLY, ALIGN=1

                  tcp_process_refused_data PROC
;;;1084   err_t
;;;1085   tcp_process_refused_data(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1086   {
;;;1087     err_t err;
;;;1088     u8_t refused_flags = pcb->refused_data->flags;
000004  6f85              LDR      r5,[r0,#0x78]
000006  4604              MOV      r4,r0                 ;1086
;;;1089     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1090        closes the pcb */
;;;1091     struct pbuf *refused_data = pcb->refused_data;
;;;1092     pcb->refused_data = NULL;
000008  2000              MOVS     r0,#0
00000a  7b6e              LDRB     r6,[r5,#0xd]          ;1088
;;;1093     /* Notify again application with data previously received. */
;;;1094     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
;;;1095     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
00000c  67a0              STR      r0,[r4,#0x78]
00000e  f8d47080          LDR      r7,[r4,#0x80]         ;1086
000012  b12f              CBZ      r7,|L23.32|
000014  2300              MOVS     r3,#0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  6920              LDR      r0,[r4,#0x10]
00001c  47b8              BLX      r7
00001e  e005              B        |L23.44|
                  |L23.32|
000020  2300              MOVS     r3,#0
000022  462a              MOV      r2,r5
000024  4621              MOV      r1,r4
000026  4618              MOV      r0,r3
000028  f7fffffe          BL       tcp_recv_null
                  |L23.44|
;;;1096     if (err == ERR_OK) {
;;;1097       /* did refused_data include a FIN? */
;;;1098       if (refused_flags & PBUF_FLAG_TCP_FIN) {
;;;1099         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1100            for the FIN's seqno */
;;;1101         if (pcb->rcv_wnd != TCP_WND) {
;;;1102           pcb->rcv_wnd++;
;;;1103         }
;;;1104         TCP_EVENT_CLOSED(pcb, err);
;;;1105         if (err == ERR_ABRT) {
00002c  f06f0709          MVN      r7,#9
000030  b128              CBZ      r0,|L23.62|
000032  300a              ADDS     r0,r0,#0xa            ;1096
;;;1106           return ERR_ABRT;
;;;1107         }
;;;1108       }
;;;1109     } else if (err == ERR_ABRT) {
000034  d015              BEQ      |L23.98|
;;;1110       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1111       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1112          segment contains data). */
;;;1113       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1114       return ERR_ABRT;
;;;1115     } else {
;;;1116       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1117       pcb->refused_data = refused_data;
000036  67a5              STR      r5,[r4,#0x78]
                  |L23.56|
;;;1118     }
;;;1119     return ERR_OK;
000038  2000              MOVS     r0,#0
                  |L23.58|
;;;1120   }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L23.62|
00003e  06b1              LSLS     r1,r6,#26             ;1098
000040  d5fa              BPL      |L23.56|
000042  8da1              LDRH     r1,[r4,#0x2c]         ;1101
000044  f5b16f7a          CMP      r1,#0xfa0             ;1101
000048  d001              BEQ      |L23.78|
00004a  1c49              ADDS     r1,r1,#1              ;1101
00004c  85a1              STRH     r1,[r4,#0x2c]         ;1102
                  |L23.78|
00004e  f8d45080          LDR      r5,[r4,#0x80]         ;1104
000052  b125              CBZ      r5,|L23.94|
000054  2300              MOVS     r3,#0                 ;1104
000056  461a              MOV      r2,r3                 ;1104
000058  4621              MOV      r1,r4                 ;1104
00005a  6920              LDR      r0,[r4,#0x10]         ;1104
00005c  47a8              BLX      r5                    ;1104
                  |L23.94|
00005e  300a              ADDS     r0,r0,#0xa            ;1104
000060  d1ea              BNE      |L23.56|
                  |L23.98|
000062  4638              MOV      r0,r7                 ;1114
000064  e7e9              B        |L23.58|
;;;1121   
                          ENDP


                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=2

                  tcp_recv PROC
;;;1391   void
;;;1392   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000000  b510              PUSH     {r4,lr}
;;;1393   {
;;;1394     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
000002  7e02              LDRB     r2,[r0,#0x18]
000004  2a01              CMP      r2,#1
000006  d002              BEQ      |L24.14|
;;;1395     pcb->recv = recv;
;;;1396   }
000008  f8c01080          STR      r1,[r0,#0x80]
00000c  bd10              POP      {r4,pc}
                  |L24.14|
00000e  a002              ADR      r0,|L24.24|
000010  f7fffffe          BL       __2printf
                  |L24.20|
000014  e7fe              B        |L24.20|
;;;1397   
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
000018  696e7661          DCB      "invalid socket state for recv callback",0
00001c  6c696420
000020  736f636b
000024  65742073
000028  74617465
00002c  20666f72
000030  20726563
000034  76206361
000038  6c6c6261
00003c  636b00  
00003f  00                DCB      0

                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=1

                  tcp_recv_null PROC
;;;1196   err_t
;;;1197   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  b510              PUSH     {r4,lr}
;;;1198   {
000002  0014              MOVS     r4,r2
000004  4608              MOV      r0,r1
000006  d006              BEQ      |L25.22|
;;;1199     LWIP_UNUSED_ARG(arg);
;;;1200     if (p != NULL) {
;;;1201       tcp_recved(pcb, p->tot_len);
000008  8921              LDRH     r1,[r4,#8]
00000a  f7fffffe          BL       tcp_recved
;;;1202       pbuf_free(p);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pbuf_free
000014  e000              B        |L25.24|
                  |L25.22|
;;;1203     } else if (err == ERR_OK) {
000016  b10b              CBZ      r3,|L25.28|
                  |L25.24|
;;;1204       return tcp_close(pcb);
;;;1205     }
;;;1206     return ERR_OK;
000018  2000              MOVS     r0,#0
;;;1207   }
00001a  bd10              POP      {r4,pc}
                  |L25.28|
00001c  e8bd4010          POP      {r4,lr}               ;1204
000020  f7ffbffe          B.W      tcp_close
;;;1208   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                  tcp_recved PROC
;;;610    void
;;;611    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  b510              PUSH     {r4,lr}
;;;612    {
000002  4604              MOV      r4,r0
;;;613      int wnd_inflation;
;;;614    
;;;615      /* pcb->state LISTEN not allowed here */
;;;616      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
000004  7e00              LDRB     r0,[r0,#0x18]
000006  2801              CMP      r0,#1
000008  d009              BEQ      |L26.30|
;;;617        pcb->state != LISTEN);
;;;618      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
00000a  8da0              LDRH     r0,[r4,#0x2c]
00000c  f64f72ff          MOV      r2,#0xffff
000010  1a12              SUBS     r2,r2,r0
000012  428a              CMP      r2,r1
000014  d207              BCS      |L26.38|
000016  a010              ADR      r0,|L26.88|
000018  f7fffffe          BL       __2printf
                  |L26.28|
00001c  e7fe              B        |L26.28|
                  |L26.30|
00001e  a017              ADR      r0,|L26.124|
000020  f7fffffe          BL       __2printf
                  |L26.36|
000024  e7fe              B        |L26.36|
                  |L26.38|
;;;619                  len <= 0xffff - pcb->rcv_wnd );
;;;620    
;;;621      pcb->rcv_wnd += len;
000026  4408              ADD      r0,r0,r1
000028  b280              UXTH     r0,r0
;;;622      if (pcb->rcv_wnd > TCP_WND) {
00002a  f44f617a          MOV      r1,#0xfa0
00002e  85a0              STRH     r0,[r4,#0x2c]         ;621
000030  4288              CMP      r0,r1
000032  d900              BLS      |L26.54|
;;;623        pcb->rcv_wnd = TCP_WND;
000034  85a1              STRH     r1,[r4,#0x2c]
                  |L26.54|
;;;624      }
;;;625    
;;;626      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;627    
;;;628      /* If the change in the right edge of window is significant (default
;;;629       * watermark is TCP_WND/4), then send an explicit update now.
;;;630       * Otherwise wait for a packet to be sent in the normal course of
;;;631       * events (or more window to be available later) */
;;;632      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
00003c  f5b07f7a          CMP      r0,#0x3e8
000040  db08              BLT      |L26.84|
;;;633        tcp_ack_now(pcb);
000042  7fa0              LDRB     r0,[r4,#0x1e]
000044  f0400002          ORR      r0,r0,#2
000048  77a0              STRB     r0,[r4,#0x1e]
;;;634        tcp_output(pcb);
00004a  4620              MOV      r0,r4
00004c  e8bd4010          POP      {r4,lr}
000050  f7ffbffe          B.W      tcp_output
                  |L26.84|
;;;635      }
;;;636    
;;;637      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
;;;638             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;639    }
000054  bd10              POP      {r4,pc}
;;;640    
                          ENDP

000056  0000              DCW      0x0000
                  |L26.88|
000058  7463705f          DCB      "tcp_recved: len would wrap rcv_wnd\n",0
00005c  72656376
000060  65643a20
000064  6c656e20
000068  776f756c
00006c  64207772
000070  61702072
000074  63765f77
000078  6e640a00
                  |L26.124|
00007c  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
000080  74206361
000084  6c6c2074
000088  63705f72
00008c  65637665
000090  6420666f
000094  72206c69
000098  7374656e
00009c  2d706362
0000a0  7300    
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.tcp_seg_copy||, CODE, READONLY, ALIGN=1

                  tcp_seg_copy PROC
;;;1176   struct tcp_seg *
;;;1177   tcp_seg_copy(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1178   {
000002  4605              MOV      r5,r0
;;;1179     struct tcp_seg *cseg;
;;;1180   
;;;1181     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       memp_malloc
00000a  0004              MOVS     r4,r0
;;;1182     if (cseg == NULL) {
00000c  d008              BEQ      |L27.32|
;;;1183       return NULL;
;;;1184     }
;;;1185     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
00000e  2214              MOVS     r2,#0x14
000010  4629              MOV      r1,r5
000012  f7fffffe          BL       __aeabi_memcpy4
;;;1186     pbuf_ref(cseg->p);
000016  6860              LDR      r0,[r4,#4]
000018  f7fffffe          BL       pbuf_ref
;;;1187     return cseg;
00001c  4620              MOV      r0,r4
;;;1188   }
00001e  bd70              POP      {r4-r6,pc}
                  |L27.32|
000020  2000              MOVS     r0,#0                 ;1183
000022  bd70              POP      {r4-r6,pc}
;;;1189   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP


                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=1

                  tcp_seg_free PROC
;;;1142   void
;;;1143   tcp_seg_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1144   {
000002  0004              MOVS     r4,r0
000004  d009              BEQ      |L28.26|
;;;1145     if (seg != NULL) {
;;;1146       if (seg->p != NULL) {
000006  6860              LDR      r0,[r4,#4]
000008  b108              CBZ      r0,|L28.14|
;;;1147         pbuf_free(seg->p);
00000a  f7fffffe          BL       pbuf_free
                  |L28.14|
;;;1148   #if TCP_DEBUG
;;;1149         seg->p = NULL;
;;;1150   #endif /* TCP_DEBUG */
;;;1151       }
;;;1152       memp_free(MEMP_TCP_SEG, seg);
00000e  4621              MOV      r1,r4
000010  e8bd4010          POP      {r4,lr}
000014  2004              MOVS     r0,#4
000016  f7ffbffe          B.W      memp_free
                  |L28.26|
;;;1153     }
;;;1154   }
00001a  bd10              POP      {r4,pc}
;;;1155   
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=1

                  tcp_segs_free PROC
;;;1127   void
;;;1128   tcp_segs_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1129   {
;;;1130     while (seg != NULL) {
;;;1131       struct tcp_seg *next = seg->next;
;;;1132       tcp_seg_free(seg);
;;;1133       seg = next;
;;;1134     }
000002  e003              B        |L29.12|
                  |L29.4|
000004  6804              LDR      r4,[r0,#0]            ;1132
000006  f7fffffe          BL       tcp_seg_free
00000a  4620              MOV      r0,r4                 ;1133
                  |L29.12|
00000c  2800              CMP      r0,#0                 ;1130
00000e  d1f9              BNE      |L29.4|
;;;1135   }
000010  bd10              POP      {r4,pc}
;;;1136   
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=2

                  tcp_sent PROC
;;;1405   void
;;;1406   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000000  b510              PUSH     {r4,lr}
;;;1407   {
;;;1408     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
000002  7e02              LDRB     r2,[r0,#0x18]
000004  2a01              CMP      r2,#1
000006  d001              BEQ      |L30.12|
;;;1409     pcb->sent = sent;
;;;1410   }
000008  67c1              STR      r1,[r0,#0x7c]
00000a  bd10              POP      {r4,pc}
                  |L30.12|
00000c  a001              ADR      r0,|L30.20|
00000e  f7fffffe          BL       __2printf
                  |L30.18|
000012  e7fe              B        |L30.18|
;;;1411   
                          ENDP

                  |L30.20|
000014  696e7661          DCB      "invalid socket state for sent callback",0
000018  6c696420
00001c  736f636b
000020  65742073
000024  74617465
000028  20666f72
00002c  2073656e
000030  74206361
000034  6c6c6261
000038  636b00  
00003b  00                DCB      0

                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=1

                  tcp_setprio PROC
;;;1162   void
;;;1163   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  7641              STRB     r1,[r0,#0x19]
;;;1164   {
;;;1165     pcb->prio = prio;
;;;1166   }
000002  4770              BX       lr
;;;1167   
                          ENDP


                          AREA ||i.tcp_shutdown||, CODE, READONLY, ALIGN=1

                  tcp_shutdown PROC
;;;312    err_t
;;;313    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000000  b510              PUSH     {r4,lr}
;;;314    {
000002  4604              MOV      r4,r0
;;;315      if (pcb->state == LISTEN) {
000004  7e00              LDRB     r0,[r0,#0x18]
;;;316        return ERR_CONN;
000006  f06f030c          MVN      r3,#0xc
00000a  2801              CMP      r0,#1                 ;315
00000c  d015              BEQ      |L32.58|
;;;317      }
;;;318      if (shut_rx) {
00000e  b169              CBZ      r1,|L32.44|
;;;319        /* shut down the receive side: set a flag not to receive any more data... */
;;;320        pcb->flags |= TF_RXCLOSED;
000010  7fa0              LDRB     r0,[r4,#0x1e]
000012  f0400010          ORR      r0,r0,#0x10
000016  77a0              STRB     r0,[r4,#0x1e]
;;;321        if (shut_tx) {
000018  b10a              CBZ      r2,|L32.30|
;;;322          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;323          return tcp_close_shutdown(pcb, 1);
00001a  2101              MOVS     r1,#1
00001c  e010              B        |L32.64|
                  |L32.30|
;;;324        }
;;;325        /* ... and free buffered data */
;;;326        if (pcb->refused_data != NULL) {
00001e  6fa0              LDR      r0,[r4,#0x78]
000020  b198              CBZ      r0,|L32.74|
;;;327          pbuf_free(pcb->refused_data);
000022  f7fffffe          BL       pbuf_free
;;;328          pcb->refused_data = NULL;
000026  2000              MOVS     r0,#0
000028  67a0              STR      r0,[r4,#0x78]
00002a  e00e              B        |L32.74|
                  |L32.44|
;;;329        }
;;;330      }
;;;331      if (shut_tx) {
00002c  b16a              CBZ      r2,|L32.74|
;;;332        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;333           Only close in these states as the others directly deallocate the PCB */
;;;334        switch (pcb->state) {
00002e  2803              CMP      r0,#3
000030  d005              BEQ      |L32.62|
000032  2804              CMP      r0,#4
000034  d003              BEQ      |L32.62|
000036  2807              CMP      r0,#7
000038  d001              BEQ      |L32.62|
                  |L32.58|
;;;335        case SYN_RCVD:
;;;336        case ESTABLISHED:
;;;337        case CLOSE_WAIT:
;;;338          return tcp_close_shutdown(pcb, shut_rx);
;;;339        default:
;;;340          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;341            into CLOSED state, where the PCB is deallocated. */
;;;342          return ERR_CONN;
00003a  4618              MOV      r0,r3
;;;343        }
;;;344      }
;;;345      return ERR_OK;
;;;346    }
00003c  bd10              POP      {r4,pc}
                  |L32.62|
00003e  b2c9              UXTB     r1,r1                 ;338
                  |L32.64|
000040  4620              MOV      r0,r4                 ;338
000042  e8bd4010          POP      {r4,lr}               ;338
000046  f7ffbffe          B.W      tcp_close_shutdown
                  |L32.74|
00004a  2000              MOVS     r0,#0                 ;345
00004c  bd10              POP      {r4,pc}
;;;347    
                          ENDP


                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                  tcp_slowtmr PROC
;;;787    void
;;;788    tcp_slowtmr(void)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;789    {
;;;790      struct tcp_pcb *pcb, *prev;
;;;791      u16_t eff_wnd;
;;;792      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;793      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;794      err_t err;
;;;795    
;;;796      err = ERR_OK;
;;;797    
;;;798      ++tcp_ticks;
000004  4fb5              LDR      r7,|L33.732|
;;;799      ++tcp_timer_ctr;
;;;800    
;;;801    tcp_slowtmr_start:
;;;802      /* Steps through all of the active PCBs. */
;;;803      prev = NULL;
;;;804      pcb = tcp_active_pcbs;
;;;805      if (pcb == NULL) {
;;;806        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
;;;807      }
;;;808      while (pcb != NULL) {
;;;809        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
;;;810        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
;;;811        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
;;;812        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
;;;813        if (pcb->last_timer == tcp_timer_ctr) {
;;;814          /* skip this pcb, we have already processed it */
;;;815          pcb = pcb->next;
;;;816          continue;
;;;817        }
;;;818        pcb->last_timer = tcp_timer_ctr;
;;;819    
;;;820        pcb_remove = 0;
;;;821        pcb_reset = 0;
;;;822    
;;;823        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
;;;824          ++pcb_remove;
;;;825          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
;;;826        }
;;;827        else if (pcb->nrtx == TCP_MAXRTX) {
;;;828          ++pcb_remove;
;;;829          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
;;;830        } else {
;;;831          if (pcb->persist_backoff > 0) {
;;;832            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;833             * instead of using the standard retransmission mechanism. */
;;;834            pcb->persist_cnt++;
;;;835            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
;;;836              pcb->persist_cnt = 0;
;;;837              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
;;;838                pcb->persist_backoff++;
;;;839              }
;;;840              tcp_zero_window_probe(pcb);
;;;841            }
;;;842          } else {
;;;843            /* Increase the retransmission timer if it is running */
;;;844            if(pcb->rtime >= 0) {
;;;845              ++pcb->rtime;
;;;846            }
;;;847    
;;;848            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
;;;849              /* Time for a retransmission. */
;;;850              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
;;;851                                          " pcb->rto %"S16_F"\n",
;;;852                                          pcb->rtime, pcb->rto));
;;;853    
;;;854              /* Double retransmission time-out unless we are trying to
;;;855               * connect to somebody (i.e., we are in SYN_SENT). */
;;;856              if (pcb->state != SYN_SENT) {
;;;857                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
;;;858              }
;;;859    
;;;860              /* Reset the retransmission timer. */
;;;861              pcb->rtime = 0;
;;;862    
;;;863              /* Reduce congestion window and ssthresh. */
;;;864              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
;;;865              pcb->ssthresh = eff_wnd >> 1;
;;;866              if (pcb->ssthresh < (pcb->mss << 1)) {
;;;867                pcb->ssthresh = (pcb->mss << 1);
;;;868              }
;;;869              pcb->cwnd = pcb->mss;
;;;870              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
;;;871                                           " ssthresh %"U16_F"\n",
;;;872                                           pcb->cwnd, pcb->ssthresh));
;;;873     
;;;874              /* The following needs to be called AFTER cwnd is set to one
;;;875                 mss - STJ */
;;;876              tcp_rexmit_rto(pcb);
;;;877            }
;;;878          }
;;;879        }
;;;880        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;881        if (pcb->state == FIN_WAIT_2) {
;;;882          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;883          if (pcb->flags & TF_RXCLOSED) {
;;;884            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;885               normal FIN-WAIT timeout handling. */
;;;886            if ((u32_t)(tcp_ticks - pcb->tmr) >
;;;887                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;888              ++pcb_remove;
;;;889              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
;;;890            }
;;;891          }
;;;892        }
;;;893    
;;;894        /* Check if KEEPALIVE should be sent */
;;;895        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
;;;896           ((pcb->state == ESTABLISHED) ||
;;;897            (pcb->state == CLOSE_WAIT))) {
;;;898          if((u32_t)(tcp_ticks - pcb->tmr) >
000006  f44f7afa          MOV      r10,#0x1f4
00000a  f04f0900          MOV      r9,#0
00000e  68f8              LDR      r0,[r7,#0xc]          ;798  ; tcp_ticks
000010  1c40              ADDS     r0,r0,#1              ;798
000012  60f8              STR      r0,[r7,#0xc]          ;799  ; tcp_ticks
000014  78b8              LDRB     r0,[r7,#2]            ;799  ; tcp_timer_ctr
000016  1c40              ADDS     r0,r0,#1              ;799
000018  70b8              STRB     r0,[r7,#2]            ;799
                  |L33.26|
00001a  2600              MOVS     r6,#0                 ;803
00001c  69bc              LDR      r4,[r7,#0x18]         ;808  ; tcp_active_pcbs
00001e  e128              B        |L33.626|
                  |L33.32|
000020  7e20              LDRB     r0,[r4,#0x18]         ;810
000022  b150              CBZ      r0,|L33.58|
000024  2801              CMP      r0,#1                 ;811
000026  d00c              BEQ      |L33.66|
000028  280a              CMP      r0,#0xa               ;812
00002a  d00e              BEQ      |L33.74|
00002c  f8942021          LDRB     r2,[r4,#0x21]         ;813
000030  78b9              LDRB     r1,[r7,#2]            ;813  ; tcp_timer_ctr
000032  428a              CMP      r2,r1                 ;813
000034  d10d              BNE      |L33.82|
000036  68e4              LDR      r4,[r4,#0xc]          ;815
000038  e11b              B        |L33.626|
                  |L33.58|
00003a  a0a9              ADR      r0,|L33.736|
00003c  f7fffffe          BL       __2printf
                  |L33.64|
000040  e7fe              B        |L33.64|
                  |L33.66|
000042  a0b2              ADR      r0,|L33.780|
000044  f7fffffe          BL       __2printf
                  |L33.72|
000048  e7fe              B        |L33.72|
                  |L33.74|
00004a  a0bb              ADR      r0,|L33.824|
00004c  f7fffffe          BL       __2printf
                  |L33.80|
000050  e7fe              B        |L33.80|
                  |L33.82|
000052  2500              MOVS     r5,#0                 ;820
000054  f8841021          STRB     r1,[r4,#0x21]         ;818
000058  46a8              MOV      r8,r5                 ;821
00005a  2802              CMP      r0,#2                 ;823
00005c  d103              BNE      |L33.102|
00005e  f8941046          LDRB     r1,[r4,#0x46]         ;823
000062  2906              CMP      r1,#6                 ;823
000064  d01b              BEQ      |L33.158|
                  |L33.102|
000066  f8942046          LDRB     r2,[r4,#0x46]         ;827
00006a  2a0c              CMP      r2,#0xc               ;827
00006c  d019              BEQ      |L33.162|
00006e  f8941095          LDRB     r1,[r4,#0x95]         ;831
000072  b1c1              CBZ      r1,|L33.166|
000074  f8940094          LDRB     r0,[r4,#0x94]         ;834
000078  4abb              LDR      r2,|L33.872|
00007a  1c40              ADDS     r0,r0,#1              ;834
00007c  b2c0              UXTB     r0,r0                 ;834
00007e  f8840094          STRB     r0,[r4,#0x94]         ;834
000082  5c8a              LDRB     r2,[r1,r2]            ;835
000084  4290              CMP      r0,r2                 ;835
000086  d344              BCC      |L33.274|
000088  f8849094          STRB     r9,[r4,#0x94]         ;836
00008c  2907              CMP      r1,#7                 ;837
00008e  d202              BCS      |L33.150|
000090  1c49              ADDS     r1,r1,#1              ;837
000092  f8841095          STRB     r1,[r4,#0x95]         ;838
                  |L33.150|
000096  4620              MOV      r0,r4                 ;840
000098  f7fffffe          BL       tcp_zero_window_probe
00009c  e039              B        |L33.274|
                  |L33.158|
00009e  2501              MOVS     r5,#1                 ;824
0000a0  e043              B        |L33.298|
                  |L33.162|
0000a2  2501              MOVS     r5,#1                 ;828
0000a4  e035              B        |L33.274|
                  |L33.166|
0000a6  f9b41034          LDRSH    r1,[r4,#0x34]         ;844
0000aa  2900              CMP      r1,#0                 ;844
0000ac  db01              BLT      |L33.178|
0000ae  1c49              ADDS     r1,r1,#1              ;844
0000b0  86a1              STRH     r1,[r4,#0x34]         ;845
                  |L33.178|
0000b2  6f21              LDR      r1,[r4,#0x70]         ;848
0000b4  b369              CBZ      r1,|L33.274|
0000b6  f9b41034          LDRSH    r1,[r4,#0x34]         ;848
0000ba  f9b43044          LDRSH    r3,[r4,#0x44]         ;848
0000be  4299              CMP      r1,r3                 ;848
0000c0  db27              BLT      |L33.274|
0000c2  2802              CMP      r0,#2                 ;856
0000c4  d00a              BEQ      |L33.220|
0000c6  f8b40042          LDRH     r0,[r4,#0x42]         ;857
0000ca  f9b41040          LDRSH    r1,[r4,#0x40]         ;857
0000ce  eb0000e1          ADD      r0,r0,r1,ASR #3       ;857
0000d2  49a6              LDR      r1,|L33.876|
0000d4  5c89              LDRB     r1,[r1,r2]            ;857
0000d6  4088              LSLS     r0,r0,r1              ;857
0000d8  f8a40044          STRH     r0,[r4,#0x44]         ;857
                  |L33.220|
0000dc  f8a49034          STRH     r9,[r4,#0x34]         ;861
0000e0  f8b4004c          LDRH     r0,[r4,#0x4c]         ;864
0000e4  f8b41060          LDRH     r1,[r4,#0x60]         ;864
0000e8  4288              CMP      r0,r1                 ;864
0000ea  d300              BCC      |L33.238|
0000ec  4608              MOV      r0,r1                 ;864
                  |L33.238|
0000ee  0841              LSRS     r1,r0,#1              ;865
0000f0  f8a4104e          STRH     r1,[r4,#0x4e]         ;865
0000f4  8ee0              LDRH     r0,[r4,#0x36]         ;866
0000f6  ebb10f40          CMP      r1,r0,LSL #1          ;866
0000fa  d205              BCS      |L33.264|
0000fc  f64f71ff          MOV      r1,#0xffff            ;867
000100  ea010140          AND      r1,r1,r0,LSL #1       ;867
000104  f8a4104e          STRH     r1,[r4,#0x4e]         ;867
                  |L33.264|
000108  f8a4004c          STRH     r0,[r4,#0x4c]         ;869
00010c  4620              MOV      r0,r4                 ;876
00010e  f7fffffe          BL       tcp_rexmit_rto
                  |L33.274|
000112  7e20              LDRB     r0,[r4,#0x18]         ;881
000114  2806              CMP      r0,#6                 ;881
000116  d108              BNE      |L33.298|
000118  7fa0              LDRB     r0,[r4,#0x1e]         ;883
00011a  06c0              LSLS     r0,r0,#27             ;883
00011c  d505              BPL      |L33.298|
00011e  6a60              LDR      r0,[r4,#0x24]         ;886
000120  68f9              LDR      r1,[r7,#0xc]          ;886  ; tcp_ticks
000122  1a08              SUBS     r0,r1,r0              ;886
000124  2828              CMP      r0,#0x28              ;886
000126  d900              BLS      |L33.298|
000128  1c6d              ADDS     r5,r5,#1              ;886
                  |L33.298|
00012a  7a20              LDRB     r0,[r4,#8]            ;895
00012c  0700              LSLS     r0,r0,#28             ;895
00012e  d529              BPL      |L33.388|
000130  7e20              LDRB     r0,[r4,#0x18]         ;896
000132  2804              CMP      r0,#4                 ;896
000134  d001              BEQ      |L33.314|
000136  2807              CMP      r0,#7                 ;897
000138  d124              BNE      |L33.388|
                  |L33.314|
00013a  488d              LDR      r0,|L33.880|
00013c  f8d41090          LDR      r1,[r4,#0x90]
000140  f8d7c00c          LDR      r12,[r7,#0xc]  ; tcp_ticks
000144  4408              ADD      r0,r0,r1
000146  fbb0f2fa          UDIV     r2,r0,r10
00014a  6a60              LDR      r0,[r4,#0x24]
00014c  ebac0000          SUB      r0,r12,r0
000150  4282              CMP      r2,r0
000152  d203              BCS      |L33.348|
;;;899             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;900          {
;;;901            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
;;;902                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;903                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;904            
;;;905            ++pcb_remove;
;;;906            ++pcb_reset;
000154  f04f0801          MOV      r8,#1
000158  1c6d              ADDS     r5,r5,#1
00015a  e013              B        |L33.388|
                  |L33.348|
;;;907          }
;;;908          else if((u32_t)(tcp_ticks - pcb->tmr) > 
00015c  f8942096          LDRB     r2,[r4,#0x96]
000160  f2424c9f          MOV      r12,#0x249f
000164  fb02f20c          MUL      r2,r2,r12
000168  eb0101c2          ADD      r1,r1,r2,LSL #3
00016c  fbb1f1fa          UDIV     r1,r1,r10
000170  4281              CMP      r1,r0
000172  d207              BCS      |L33.388|
;;;909                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;910                  / TCP_SLOW_INTERVAL)
;;;911          {
;;;912            tcp_keepalive(pcb);
000174  4620              MOV      r0,r4
000176  f7fffffe          BL       tcp_keepalive
;;;913            pcb->keep_cnt_sent++;
00017a  f8940096          LDRB     r0,[r4,#0x96]
00017e  1c40              ADDS     r0,r0,#1
000180  f8840096          STRB     r0,[r4,#0x96]
                  |L33.388|
;;;914          }
;;;915        }
;;;916    
;;;917        /* If this PCB has queued out of sequence data, but has been
;;;918           inactive for too long, will drop the data (it will eventually
;;;919           be retransmitted). */
;;;920    #if TCP_QUEUE_OOSEQ
;;;921        if (pcb->ooseq != NULL &&
000184  6f60              LDR      r0,[r4,#0x74]
000186  b168              CBZ      r0,|L33.420|
;;;922            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
000188  6a61              LDR      r1,[r4,#0x24]
00018a  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
00018c  1a52              SUBS     r2,r2,r1
00018e  f9b41044          LDRSH    r1,[r4,#0x44]
000192  eb010141          ADD      r1,r1,r1,LSL #1
000196  ebb20f41          CMP      r2,r1,LSL #1
00019a  d303              BCC      |L33.420|
;;;923          tcp_segs_free(pcb->ooseq);
00019c  f7fffffe          BL       tcp_segs_free
;;;924          pcb->ooseq = NULL;
0001a0  f8c49074          STR      r9,[r4,#0x74]
                  |L33.420|
;;;925          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;926        }
;;;927    #endif /* TCP_QUEUE_OOSEQ */
;;;928    
;;;929        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;930        if (pcb->state == SYN_RCVD) {
0001a4  7e20              LDRB     r0,[r4,#0x18]
0001a6  2803              CMP      r0,#3
0001a8  d002              BEQ      |L33.432|
;;;931          if ((u32_t)(tcp_ticks - pcb->tmr) >
;;;932              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;933            ++pcb_remove;
;;;934            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
;;;935          }
;;;936        }
;;;937    
;;;938        /* Check if this PCB has stayed too long in LAST-ACK */
;;;939        if (pcb->state == LAST_ACK) {
0001aa  2809              CMP      r0,#9
0001ac  d007              BEQ      |L33.446|
0001ae  e00b              B        |L33.456|
                  |L33.432|
0001b0  6a60              LDR      r0,[r4,#0x24]         ;931
0001b2  68f9              LDR      r1,[r7,#0xc]          ;931  ; tcp_ticks
0001b4  1a08              SUBS     r0,r1,r0              ;931
0001b6  2828              CMP      r0,#0x28              ;931
0001b8  d906              BLS      |L33.456|
                  |L33.442|
0001ba  1c6d              ADDS     r5,r5,#1              ;931
0001bc  e004              B        |L33.456|
                  |L33.446|
;;;940          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0001be  6a60              LDR      r0,[r4,#0x24]
0001c0  68f9              LDR      r1,[r7,#0xc]  ; tcp_ticks
0001c2  1a08              SUBS     r0,r1,r0
0001c4  28f0              CMP      r0,#0xf0
0001c6  d8f8              BHI      |L33.442|
                  |L33.456|
;;;941            ++pcb_remove;
;;;942            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
;;;943          }
;;;944        }
;;;945    
;;;946        /* If the PCB should be removed, do it. */
;;;947        if (pcb_remove) {
0001c8  b3bd              CBZ      r5,|L33.570|
;;;948          struct tcp_pcb *pcb2;
;;;949          tcp_err_fn err_fn;
;;;950          void *err_arg;
;;;951          tcp_pcb_purge(pcb);
0001ca  4620              MOV      r0,r4
0001cc  f7fffffe          BL       tcp_pcb_purge
;;;952          /* Remove PCB from tcp_active_pcbs list. */
;;;953          if (prev != NULL) {
0001d0  69b8              LDR      r0,[r7,#0x18]  ; tcp_active_pcbs
0001d2  b146              CBZ      r6,|L33.486|
;;;954            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
0001d4  4284              CMP      r4,r0
0001d6  d103              BNE      |L33.480|
0001d8  a066              ADR      r0,|L33.884|
0001da  f7fffffe          BL       __2printf
                  |L33.478|
0001de  e7fe              B        |L33.478|
                  |L33.480|
;;;955            prev->next = pcb->next;
0001e0  68e0              LDR      r0,[r4,#0xc]
0001e2  60f0              STR      r0,[r6,#0xc]
0001e4  e007              B        |L33.502|
                  |L33.486|
;;;956          } else {
;;;957            /* This PCB was the first. */
;;;958            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
0001e6  42a0              CMP      r0,r4
0001e8  d003              BEQ      |L33.498|
0001ea  a06d              ADR      r0,|L33.928|
0001ec  f7fffffe          BL       __2printf
                  |L33.496|
0001f0  e7fe              B        |L33.496|
                  |L33.498|
;;;959            tcp_active_pcbs = pcb->next;
0001f2  68e0              LDR      r0,[r4,#0xc]
0001f4  61b8              STR      r0,[r7,#0x18]  ; tcp_active_pcbs
                  |L33.502|
;;;960          }
;;;961    
;;;962          if (pcb_reset) {
0001f6  f1b80f00          CMP      r8,#0
0001fa  d009              BEQ      |L33.528|
;;;963            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0001fc  8ba1              LDRH     r1,[r4,#0x1c]
0001fe  8b60              LDRH     r0,[r4,#0x1a]
000200  e9cd0100          STRD     r0,r1,[sp,#0]
000204  1d23              ADDS     r3,r4,#4
000206  4622              MOV      r2,r4
000208  6aa1              LDR      r1,[r4,#0x28]
00020a  6d20              LDR      r0,[r4,#0x50]
00020c  f7fffffe          BL       tcp_rst
                  |L33.528|
;;;964              pcb->local_port, pcb->remote_port);
;;;965          }
;;;966    
;;;967          err_fn = pcb->errf;
;;;968          err_arg = pcb->callback_arg;
;;;969          pcb2 = pcb;
000210  4621              MOV      r1,r4
;;;970          pcb = pcb->next;
000212  f8d48010          LDR      r8,[r4,#0x10]
000216  f8d4508c          LDR      r5,[r4,#0x8c]
00021a  68e4              LDR      r4,[r4,#0xc]
;;;971          memp_free(MEMP_TCP_PCB, pcb2);
00021c  2002              MOVS     r0,#2
00021e  f7fffffe          BL       memp_free
;;;972    
;;;973          tcp_active_pcbs_changed = 0;
000222  f8879000          STRB     r9,[r7,#0]
;;;974          TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
000226  b325              CBZ      r5,|L33.626|
000228  f06f0109          MVN      r1,#9
00022c  4640              MOV      r0,r8
00022e  47a8              BLX      r5
;;;975          if (tcp_active_pcbs_changed) {
000230  7838              LDRB     r0,[r7,#0]  ; tcp_active_pcbs_changed
000232  2800              CMP      r0,#0                 ;974
                  |L33.564|
000234  f47faef1          BNE      |L33.26|
000238  e01b              B        |L33.626|
                  |L33.570|
00023a  e7ff              B        |L33.572|
                  |L33.572|
;;;976            goto tcp_slowtmr_start;
;;;977          }
;;;978        } else {
;;;979          /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;980          prev = pcb;
00023c  4626              MOV      r6,r4
;;;981          pcb = pcb->next;
00023e  68e4              LDR      r4,[r4,#0xc]
;;;982    
;;;983          /* We check if we should poll the connection. */
;;;984          ++prev->polltmr;
000240  7ff0              LDRB     r0,[r6,#0x1f]
000242  1c40              ADDS     r0,r0,#1
000244  b2c0              UXTB     r0,r0
000246  77f0              STRB     r0,[r6,#0x1f]
;;;985          if (prev->polltmr >= prev->pollinterval) {
000248  f8961020          LDRB     r1,[r6,#0x20]
00024c  4288              CMP      r0,r1
00024e  d310              BCC      |L33.626|
;;;986            prev->polltmr = 0;
000250  f886901f          STRB     r9,[r6,#0x1f]
;;;987            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
;;;988            tcp_active_pcbs_changed = 0;
000254  f8879000          STRB     r9,[r7,#0]
;;;989            TCP_EVENT_POLL(prev, err);
000258  f8d62088          LDR      r2,[r6,#0x88]
00025c  b132              CBZ      r2,|L33.620|
00025e  4631              MOV      r1,r6
000260  6930              LDR      r0,[r6,#0x10]
000262  4790              BLX      r2
;;;990            if (tcp_active_pcbs_changed) {
000264  7839              LDRB     r1,[r7,#0]  ; tcp_active_pcbs_changed
000266  2900              CMP      r1,#0                 ;989
000268  d1e4              BNE      |L33.564|
;;;991              goto tcp_slowtmr_start;
;;;992            }
;;;993            /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;994            if (err == ERR_OK) {
00026a  b910              CBNZ     r0,|L33.626|
                  |L33.620|
;;;995              tcp_output(prev);
00026c  4630              MOV      r0,r6
00026e  f7fffffe          BL       tcp_output
                  |L33.626|
000272  2c00              CMP      r4,#0                 ;808
000274  f47faed4          BNE      |L33.32|
;;;996            }
;;;997          }
;;;998        }
;;;999      }
;;;1000   
;;;1001     
;;;1002     /* Steps through all of the TIME-WAIT PCBs. */
;;;1003     prev = NULL;
000278  2500              MOVS     r5,#0
;;;1004     pcb = tcp_tw_pcbs;
;;;1005     while (pcb != NULL) {
00027a  69fc              LDR      r4,[r7,#0x1c]  ; tcp_tw_pcbs
00027c  e029              B        |L33.722|
                  |L33.638|
;;;1006       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
00027e  7e20              LDRB     r0,[r4,#0x18]
000280  280a              CMP      r0,#0xa
000282  d003              BEQ      |L33.652|
000284  a051              ADR      r0,|L33.972|
000286  f7fffffe          BL       __2printf
                  |L33.650|
00028a  e7fe              B        |L33.650|
                  |L33.652|
;;;1007       pcb_remove = 0;
;;;1008   
;;;1009       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1010       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
00028c  6a60              LDR      r0,[r4,#0x24]
00028e  68f9              LDR      r1,[r7,#0xc]  ; tcp_ticks
000290  1a08              SUBS     r0,r1,r0
000292  28f0              CMP      r0,#0xf0
000294  d91b              BLS      |L33.718|
;;;1011         ++pcb_remove;
;;;1012       }
;;;1013       
;;;1014   
;;;1015   
;;;1016       /* If the PCB should be removed, do it. */
;;;1017       if (pcb_remove) {
;;;1018         struct tcp_pcb *pcb2;
;;;1019         tcp_pcb_purge(pcb);
000296  4620              MOV      r0,r4
000298  f7fffffe          BL       tcp_pcb_purge
00029c  69f8              LDR      r0,[r7,#0x1c]         ;1011  ; tcp_tw_pcbs
00029e  b145              CBZ      r5,|L33.690|
;;;1020         /* Remove PCB from tcp_tw_pcbs list. */
;;;1021         if (prev != NULL) {
;;;1022           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
0002a0  4284              CMP      r4,r0
0002a2  d103              BNE      |L33.684|
0002a4  a055              ADR      r0,|L33.1020|
0002a6  f7fffffe          BL       __2printf
                  |L33.682|
0002aa  e7fe              B        |L33.682|
                  |L33.684|
;;;1023           prev->next = pcb->next;
0002ac  68e0              LDR      r0,[r4,#0xc]
0002ae  60e8              STR      r0,[r5,#0xc]
0002b0  e007              B        |L33.706|
                  |L33.690|
;;;1024         } else {
;;;1025           /* This PCB was the first. */
;;;1026           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
0002b2  42a0              CMP      r0,r4
0002b4  d003              BEQ      |L33.702|
0002b6  a05b              ADR      r0,|L33.1060|
0002b8  f7fffffe          BL       __2printf
                  |L33.700|
0002bc  e7fe              B        |L33.700|
                  |L33.702|
;;;1027           tcp_tw_pcbs = pcb->next;
0002be  68e0              LDR      r0,[r4,#0xc]
0002c0  61f8              STR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
                  |L33.706|
;;;1028         }
;;;1029         pcb2 = pcb;
;;;1030         pcb = pcb->next;
0002c2  4621              MOV      r1,r4
0002c4  68e4              LDR      r4,[r4,#0xc]
;;;1031         memp_free(MEMP_TCP_PCB, pcb2);
0002c6  2002              MOVS     r0,#2
0002c8  f7fffffe          BL       memp_free
;;;1032       } else {
0002cc  e001              B        |L33.722|
                  |L33.718|
;;;1033         prev = pcb;
0002ce  4625              MOV      r5,r4
;;;1034         pcb = pcb->next;
0002d0  68e4              LDR      r4,[r4,#0xc]
                  |L33.722|
0002d2  2c00              CMP      r4,#0                 ;1005
0002d4  d1d3              BNE      |L33.638|
;;;1035       }
;;;1036     }
;;;1037   }
0002d6  e8bd87fc          POP      {r2-r10,pc}
;;;1038   
                          ENDP

0002da  0000              DCW      0x0000
                  |L33.732|
                          DCD      ||.data||
                  |L33.736|
0002e0  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
0002e4  736c6f77
0002e8  746d723a
0002ec  20616374
0002f0  69766520
0002f4  7063622d
0002f8  3e737461
0002fc  74652021
000300  3d20434c
000304  4f534544
000308  0a00    
00030a  00                DCB      0
00030b  00                DCB      0
                  |L33.780|
00030c  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
000310  736c6f77
000314  746d723a
000318  20616374
00031c  69766520
000320  7063622d
000324  3e737461
000328  74652021
00032c  3d204c49
000330  5354454e
000334  0a00    
000336  00                DCB      0
000337  00                DCB      0
                  |L33.824|
000338  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
00033c  736c6f77
000340  746d723a
000344  20616374
000348  69766520
00034c  7063622d
000350  3e737461
000354  74652021
000358  3d205449
00035c  4d452d57
000360  4149540a
000364  00      
000365  00                DCB      0
000366  00                DCB      0
000367  00                DCB      0
                  |L33.872|
                          DCD      ||.constdata||-0x1
                  |L33.876|
                          DCD      ||.constdata||+0x34
                  |L33.880|
                          DCD      0x000a4cb8
                  |L33.884|
000374  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
000378  736c6f77
00037c  746d723a
000380  206d6964
000384  646c6520
000388  74637020
00038c  213d2074
000390  63705f61
000394  63746976
000398  655f7063
00039c  627300  
00039f  00                DCB      0
                  |L33.928|
0003a0  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
0003a4  736c6f77
0003a8  746d723a
0003ac  20666972
0003b0  73742070
0003b4  6362203d
0003b8  3d207463
0003bc  705f6163
0003c0  74697665
0003c4  5f706362
0003c8  7300    
0003ca  00                DCB      0
0003cb  00                DCB      0
                  |L33.972|
0003cc  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
0003d0  736c6f77
0003d4  746d723a
0003d8  2054494d
0003dc  452d5741
0003e0  49542070
0003e4  63622d3e
0003e8  73746174
0003ec  65203d3d
0003f0  2054494d
0003f4  452d5741
0003f8  495400  
0003fb  00                DCB      0
                  |L33.1020|
0003fc  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
000400  736c6f77
000404  746d723a
000408  206d6964
00040c  646c6520
000410  74637020
000414  213d2074
000418  63705f74
00041c  775f7063
000420  627300  
000423  00                DCB      0
                  |L33.1060|
000424  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
000428  736c6f77
00042c  746d723a
000430  20666972
000434  73742070
000438  6362203d
00043c  3d207463
000440  705f7477
000444  5f706362
000448  7300    
00044a  00                DCB      0
00044b  00                DCB      0

                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;140    void
;;;141    tcp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      /* Call tcp_fasttmr() every 250 ms */
;;;144      tcp_fasttmr();
000002  f7fffffe          BL       tcp_fasttmr
;;;145    
;;;146      if (++tcp_timer & 1) {
000006  4905              LDR      r1,|L34.28|
000008  7848              LDRB     r0,[r1,#1]  ; tcp_timer
00000a  1c40              ADDS     r0,r0,#1
00000c  7048              STRB     r0,[r1,#1]
00000e  07c0              LSLS     r0,r0,#31
000010  d003              BEQ      |L34.26|
;;;147        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;148           tcp_tmr() is called. */
;;;149        tcp_slowtmr();
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      tcp_slowtmr
                  |L34.26|
;;;150      }
;;;151    }
00001a  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  |L34.28|
                          DCD      ||.data||

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=2

                  tcp_update_rcv_ann_wnd PROC
;;;578     */
;;;579    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
;;;581      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000002  8d85              LDRH     r5,[r0,#0x2c]
000004  6a82              LDR      r2,[r0,#0x28]
;;;582    
;;;583      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
000006  8ec4              LDRH     r4,[r0,#0x36]
000008  1953              ADDS     r3,r2,r5              ;581
00000a  f44f66fa          MOV      r6,#0x7d0
00000e  6b01              LDR      r1,[r0,#0x30]
000010  42b4              CMP      r4,r6
000012  d900              BLS      |L35.22|
000014  4634              MOV      r4,r6
                  |L35.22|
000016  440c              ADD      r4,r4,r1
000018  1b1c              SUBS     r4,r3,r4
00001a  d402              BMI      |L35.34|
;;;584        /* we can advertise more window */
;;;585        pcb->rcv_ann_wnd = pcb->rcv_wnd;
00001c  85c5              STRH     r5,[r0,#0x2e]
;;;586        return new_right_edge - pcb->rcv_ann_right_edge;
00001e  1a58              SUBS     r0,r3,r1
;;;587      } else {
;;;588        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;589          /* Can happen due to other end sending out of advertised window,
;;;590           * but within actual available (but not yet advertised) window */
;;;591          pcb->rcv_ann_wnd = 0;
;;;592        } else {
;;;593          /* keep the right edge of window constant */
;;;594          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;595          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;596          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;597        }
;;;598        return 0;
;;;599      }
;;;600    }
000020  bd70              POP      {r4-r6,pc}
                  |L35.34|
000022  1a53              SUBS     r3,r2,r1              ;588
000024  2b00              CMP      r3,#0                 ;588
000026  dd01              BLE      |L35.44|
000028  2100              MOVS     r1,#0                 ;591
00002a  e007              B        |L35.60|
                  |L35.44|
00002c  1a89              SUBS     r1,r1,r2              ;594
00002e  f5b13f80          CMP      r1,#0x10000           ;595
000032  d303              BCC      |L35.60|
000034  a003              ADR      r0,|L35.68|
000036  f7fffffe          BL       __2printf
                  |L35.58|
00003a  e7fe              B        |L35.58|
                  |L35.60|
00003c  85c1              STRH     r1,[r0,#0x2e]         ;596
00003e  2000              MOVS     r0,#0                 ;598
000040  bd70              POP      {r4-r6,pc}
;;;601    
                          ENDP

000042  0000              DCW      0x0000
                  |L35.68|
000044  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
000048  7263765f
00004c  616e6e5f
000050  776e6420
000054  3c3d2030
000058  78666666
00005c  6600    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_persist_backoff
000000  03060c18          DCB      0x03,0x06,0x0c,0x18
000004  30607800          DCB      0x30,0x60,0x78,0x00
                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
000034  01020304          DCB      0x01,0x02,0x03,0x04
000038  05060707          DCB      0x05,0x06,0x07,0x07
00003c  07070707          DCB      0x07,0x07,0x07,0x07
000040  07000000          DCB      0x07,0x00,0x00,0x00
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_active_pcbs_changed
000000  00                DCB      0x00
                  tcp_timer
000001  00                DCB      0x00
                  tcp_timer_ctr
000002  0000              DCB      0x00,0x00
                  tcp_port
000004  c000              DCW      0xc000
000006  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
