; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\tcp_in.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp_in.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\tcp_in.crf ..\lwip\src\core\tcp_in.c]
                          THUMB

                          AREA ||i.tcp_input||, CODE, READONLY, ALIGN=2

                  tcp_input PROC
;;;91     void
;;;92     tcp_input(struct pbuf *p, struct netif *inp)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;93     {
;;;94       struct tcp_pcb *pcb, *prev;
;;;95       struct tcp_pcb_listen *lpcb;
;;;96     #if SO_REUSE
;;;97       struct tcp_pcb *lpcb_prev = NULL;
;;;98       struct tcp_pcb_listen *lpcb_any = NULL;
;;;99     #endif /* SO_REUSE */
;;;100      u8_t hdrlen;
;;;101      err_t err;
;;;102    
;;;103      PERF_START;
;;;104    
;;;105      TCP_STATS_INC(tcp.recv);
000004  4eef              LDR      r6,|L1.964|
000006  4605              MOV      r5,r0                 ;93
;;;106      snmp_inc_tcpinsegs();
;;;107    
;;;108      iphdr = (struct ip_hdr *)p->payload;
000008  4fef              LDR      r7,|L1.968|
00000a  f8b60092          LDRH     r0,[r6,#0x92]         ;105  ; lwip_stats
00000e  4688              MOV      r8,r1                 ;93
000010  1c40              ADDS     r0,r0,#1              ;105
000012  f8a60092          STRH     r0,[r6,#0x92]         ;105
000016  6868              LDR      r0,[r5,#4]
;;;109      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
000018  60b8              STR      r0,[r7,#8]  ; iphdr
00001a  7801              LDRB     r1,[r0,#0]
00001c  f001010f          AND      r1,r1,#0xf
000020  eb000081          ADD      r0,r0,r1,LSL #2
;;;110    
;;;111    #if TCP_INPUT_DEBUG
;;;112      tcp_debug_print(tcphdr);
;;;113    #endif
;;;114    
;;;115      /* remove header from payload */
;;;116      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
000024  6078              STR      r0,[r7,#4]  ; tcphdr
000026  0088              LSLS     r0,r1,#2
000028  4241              RSBS     r1,r0,#0
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       pbuf_header
000030  bb70              CBNZ     r0,|L1.144|
000032  8928              LDRH     r0,[r5,#8]
000034  2814              CMP      r0,#0x14
000036  d32b              BCC      |L1.144|
;;;117        /* drop short packets */
;;;118        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
;;;119        TCP_STATS_INC(tcp.lenerr);
;;;120        goto dropped;
;;;121      }
;;;122    
;;;123      /* Don't even process incoming broadcasts/multicasts. */
;;;124      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
000038  4ce4              LDR      r4,|L1.972|
00003a  4641              MOV      r1,r8
00003c  6820              LDR      r0,[r4,#0]  ; current_iphdr_dest
00003e  f7fffffe          BL       ip4_addr_isbroadcast
000042  b9a0              CBNZ     r0,|L1.110|
;;;125          ip_addr_ismulticast(&current_iphdr_dest)) {
000044  7820              LDRB     r0,[r4,#0]  ; current_iphdr_dest
000046  46a0              MOV      r8,r4
000048  f3c01003          UBFX     r0,r0,#4,#4
00004c  280e              CMP      r0,#0xe
00004e  d00e              BEQ      |L1.110|
;;;126        TCP_STATS_INC(tcp.proterr);
;;;127        goto dropped;
;;;128      }
;;;129    
;;;130    #if CHECKSUM_CHECK_TCP
;;;131      /* Verify TCP checksum. */
;;;132      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
000050  8928              LDRH     r0,[r5,#8]
000052  9000              STR      r0,[sp,#0]
000054  2306              MOVS     r3,#6
000056  4622              MOV      r2,r4
000058  49dd              LDR      r1,|L1.976|
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       inet_chksum_pseudo
000060  b158              CBZ      r0,|L1.122|
;;;133          IP_PROTO_TCP, p->tot_len) != 0) {
;;;134          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;135            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;136          IP_PROTO_TCP, p->tot_len)));
;;;137    #if TCP_DEBUG
;;;138        tcp_debug_print(tcphdr);
;;;139    #endif /* TCP_DEBUG */
;;;140        TCP_STATS_INC(tcp.chkerr);
000062  f8b60098          LDRH     r0,[r6,#0x98]  ; lwip_stats
000066  1c40              ADDS     r0,r0,#1
000068  f8a60098          STRH     r0,[r6,#0x98]
;;;141        goto dropped;
00006c  e015              B        |L1.154|
                  |L1.110|
00006e  f8b600a0          LDRH     r0,[r6,#0xa0]         ;126  ; lwip_stats
000072  1c40              ADDS     r0,r0,#1              ;126
000074  f8a600a0          STRH     r0,[r6,#0xa0]         ;126
000078  e00f              B        |L1.154|
                  |L1.122|
;;;142      }
;;;143    #endif
;;;144    
;;;145      /* Move the payload pointer in the pbuf so that it points to the
;;;146         TCP data instead of the TCP header. */
;;;147      hdrlen = TCPH_HDRLEN(tcphdr);
00007a  6878              LDR      r0,[r7,#4]  ; tcphdr
00007c  8980              LDRH     r0,[r0,#0xc]
00007e  f7fffffe          BL       lwip_ntohs
000082  0b00              LSRS     r0,r0,#12
;;;148      if(pbuf_header(p, -(hdrlen * 4))){
000084  0080              LSLS     r0,r0,#2
000086  4241              RSBS     r1,r0,#0
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       pbuf_header
00008e  b148              CBZ      r0,|L1.164|
                  |L1.144|
;;;149        /* drop short packets */
;;;150        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
;;;151        TCP_STATS_INC(tcp.lenerr);
000090  f8b6009a          LDRH     r0,[r6,#0x9a]  ; lwip_stats
000094  1c40              ADDS     r0,r0,#1
000096  f8a6009a          STRH     r0,[r6,#0x9a]
                  |L1.154|
;;;152        goto dropped;
;;;153      }
;;;154    
;;;155      /* Convert fields in TCP header to host byte order. */
;;;156      tcphdr->src = ntohs(tcphdr->src);
;;;157      tcphdr->dest = ntohs(tcphdr->dest);
;;;158      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
;;;159      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
;;;160      tcphdr->wnd = ntohs(tcphdr->wnd);
;;;161    
;;;162      flags = TCPH_FLAGS(tcphdr);
;;;163      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
;;;164    
;;;165      /* Demultiplex an incoming segment. First, we check if it is destined
;;;166         for an active connection. */
;;;167      prev = NULL;
;;;168    
;;;169      
;;;170      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
;;;171        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
;;;174        if (pcb->remote_port == tcphdr->src &&
;;;175           pcb->local_port == tcphdr->dest &&
;;;176           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
;;;177           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
;;;178    
;;;179          /* Move this PCB to the front of the list so that subsequent
;;;180             lookups will be faster (we exploit locality in TCP segment
;;;181             arrivals). */
;;;182          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
;;;183          if (prev != NULL) {
;;;184            prev->next = pcb->next;
;;;185            pcb->next = tcp_active_pcbs;
;;;186            tcp_active_pcbs = pcb;
;;;187          }
;;;188          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
;;;189          break;
;;;190        }
;;;191        prev = pcb;
;;;192      }
;;;193    
;;;194      if (pcb == NULL) {
;;;195        /* If it did not go to an active connection, we check the connections
;;;196           in the TIME-WAIT state. */
;;;197        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
;;;198          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
;;;199          if (pcb->remote_port == tcphdr->src &&
;;;200             pcb->local_port == tcphdr->dest &&
;;;201             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
;;;202             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
;;;203            /* We don't really care enough to move this PCB to the front
;;;204               of the list since we are not very likely to receive that
;;;205               many segments for connections in TIME-WAIT. */
;;;206            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
;;;207            tcp_timewait_input(pcb);
;;;208            pbuf_free(p);
;;;209            return;
;;;210          }
;;;211        }
;;;212    
;;;213        /* Finally, if we still did not get a match, we check all PCBs that
;;;214           are LISTENing for incoming connections. */
;;;215        prev = NULL;
;;;216        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;217          if (lpcb->local_port == tcphdr->dest) {
;;;218    #if SO_REUSE
;;;219            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;220              /* found an exact match */
;;;221              break;
;;;222            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;223              /* found an ANY-match */
;;;224              lpcb_any = lpcb;
;;;225              lpcb_prev = prev;
;;;226            }
;;;227    #else /* SO_REUSE */
;;;228            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
;;;229                ip_addr_isany(&(lpcb->local_ip))) {
;;;230              /* found a match */
;;;231              break;
;;;232            }
;;;233    #endif /* SO_REUSE */
;;;234          }
;;;235          prev = (struct tcp_pcb *)lpcb;
;;;236        }
;;;237    #if SO_REUSE
;;;238        /* first try specific local IP */
;;;239        if (lpcb == NULL) {
;;;240          /* only pass to ANY if no specific local IP has been found */
;;;241          lpcb = lpcb_any;
;;;242          prev = lpcb_prev;
;;;243        }
;;;244    #endif /* SO_REUSE */
;;;245        if (lpcb != NULL) {
;;;246          /* Move this PCB to the front of the list so that subsequent
;;;247             lookups will be faster (we exploit locality in TCP segment
;;;248             arrivals). */
;;;249          if (prev != NULL) {
;;;250            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
;;;251                  /* our successor is the remainder of the listening list */
;;;252            lpcb->next = tcp_listen_pcbs.listen_pcbs;
;;;253                  /* put this listening pcb at the head of the listening list */
;;;254            tcp_listen_pcbs.listen_pcbs = lpcb;
;;;255          }
;;;256        
;;;257          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;258          tcp_listen_input(lpcb);
;;;259          pbuf_free(p);
;;;260          return;
;;;261        }
;;;262      }
;;;263    
;;;264    #if TCP_INPUT_DEBUG
;;;265      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;266      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;267      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;268    #endif /* TCP_INPUT_DEBUG */
;;;269    
;;;270    
;;;271      if (pcb != NULL) {
;;;272        /* The incoming segment belongs to a connection. */
;;;273    #if TCP_INPUT_DEBUG
;;;274    #if TCP_DEBUG
;;;275        tcp_debug_print_state(pcb->state);
;;;276    #endif /* TCP_DEBUG */
;;;277    #endif /* TCP_INPUT_DEBUG */
;;;278    
;;;279        /* Set up a tcp_seg structure. */
;;;280        inseg.next = NULL;
;;;281        inseg.len = p->tot_len;
;;;282        inseg.p = p;
;;;283        inseg.tcphdr = tcphdr;
;;;284    
;;;285        recv_data = NULL;
;;;286        recv_flags = 0;
;;;287    
;;;288        if (flags & TCP_PSH) {
;;;289          p->flags |= PBUF_FLAG_PUSH;
;;;290        }
;;;291    
;;;292        /* If there is data which was previously "refused" by upper layer */
;;;293        if (pcb->refused_data != NULL) {
;;;294          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
;;;295            ((pcb->refused_data != NULL) && (tcplen > 0))) {
;;;296            /* pcb has been aborted or refused data is still refused and the new
;;;297               segment contains data */
;;;298            TCP_STATS_INC(tcp.drop);
;;;299            snmp_inc_tcpinerrs();
;;;300            goto aborted;
;;;301          }
;;;302        }
;;;303        tcp_input_pcb = pcb;
;;;304        err = tcp_process(pcb);
;;;305        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;306           and that the pcb has been freed. If so, we don't do anything. */
;;;307        if (err != ERR_ABRT) {
;;;308          if (recv_flags & TF_RESET) {
;;;309            /* TF_RESET means that the connection was reset by the other
;;;310               end. We then call the error callback to inform the
;;;311               application that the connection is dead before we
;;;312               deallocate the PCB. */
;;;313            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
;;;314            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;315            memp_free(MEMP_TCP_PCB, pcb);
;;;316          } else if (recv_flags & TF_CLOSED) {
;;;317            /* The connection has been closed and we will deallocate the
;;;318               PCB. */
;;;319            if (!(pcb->flags & TF_RXCLOSED)) {
;;;320              /* Connection closed although the application has only shut down the
;;;321                 tx side: call the PCB's err callback and indicate the closure to
;;;322                 ensure the application doesn't continue using the PCB. */
;;;323              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
;;;324            }
;;;325            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;326            memp_free(MEMP_TCP_PCB, pcb);
;;;327          } else {
;;;328            err = ERR_OK;
;;;329            /* If the application has registered a "sent" function to be
;;;330               called when new send buffer space is available, we call it
;;;331               now. */
;;;332            if (pcb->acked > 0) {
;;;333              TCP_EVENT_SENT(pcb, pcb->acked, err);
;;;334              if (err == ERR_ABRT) {
;;;335                goto aborted;
;;;336              }
;;;337            }
;;;338    
;;;339            if (recv_data != NULL) {
;;;340              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
;;;341              if (pcb->flags & TF_RXCLOSED) {
;;;342                /* received data although already closed -> abort (send RST) to
;;;343                   notify the remote host that not all data has been processed */
;;;344                pbuf_free(recv_data);
;;;345                tcp_abort(pcb);
;;;346                goto aborted;
;;;347              }
;;;348    
;;;349              /* Notify application that data has been received. */
;;;350              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
;;;351              if (err == ERR_ABRT) {
;;;352                goto aborted;
;;;353              }
;;;354    
;;;355              /* If the upper layer can't receive this data, store it */
;;;356              if (err != ERR_OK) {
;;;357                pcb->refused_data = recv_data;
;;;358                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;359              }
;;;360            }
;;;361    
;;;362            /* If a FIN segment was received, we call the callback
;;;363               function with a NULL buffer to indicate EOF. */
;;;364            if (recv_flags & TF_GOT_FIN) {
;;;365              if (pcb->refused_data != NULL) {
;;;366                /* Delay this if we have refused data. */
;;;367                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
;;;368              } else {
;;;369                /* correct rcv_wnd as the application won't call tcp_recved()
;;;370                   for the FIN's seqno */
;;;371                if (pcb->rcv_wnd != TCP_WND) {
;;;372                  pcb->rcv_wnd++;
;;;373                }
;;;374                TCP_EVENT_CLOSED(pcb, err);
;;;375                if (err == ERR_ABRT) {
;;;376                  goto aborted;
;;;377                }
;;;378              }
;;;379            }
;;;380    
;;;381            tcp_input_pcb = NULL;
;;;382            /* Try to send something out. */
;;;383            tcp_output(pcb);
;;;384    #if TCP_INPUT_DEBUG
;;;385    #if TCP_DEBUG
;;;386            tcp_debug_print_state(pcb->state);
;;;387    #endif /* TCP_DEBUG */
;;;388    #endif /* TCP_INPUT_DEBUG */
;;;389          }
;;;390        }
;;;391        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;392           Below this line, 'pcb' may not be dereferenced! */
;;;393    aborted:
;;;394        tcp_input_pcb = NULL;
;;;395        recv_data = NULL;
;;;396    
;;;397        /* give up our reference to inseg.p */
;;;398        if (inseg.p != NULL)
;;;399        {
;;;400          pbuf_free(inseg.p);
;;;401          inseg.p = NULL;
;;;402        }
;;;403      } else {
;;;404    
;;;405        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;406           sender. */
;;;407        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;408        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;409          TCP_STATS_INC(tcp.proterr);
;;;410          TCP_STATS_INC(tcp.drop);
;;;411          tcp_rst(ackno, seqno + tcplen,
;;;412            ip_current_dest_addr(), ip_current_src_addr(),
;;;413            tcphdr->dest, tcphdr->src);
;;;414        }
;;;415        pbuf_free(p);
;;;416      }
;;;417    
;;;418      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;419      PERF_STOP("tcp_input");
;;;420      return;
;;;421    dropped:
;;;422      TCP_STATS_INC(tcp.drop);
00009a  f8360f96          LDRH     r0,[r6,#0x96]!  ; lwip_stats
00009e  1c40              ADDS     r0,r0,#1
0000a0  8030              STRH     r0,[r6,#0]
;;;423      snmp_inc_tcpinerrs();
;;;424      pbuf_free(p);
;;;425    }
0000a2  e18a              B        |L1.954|
                  |L1.164|
0000a4  6878              LDR      r0,[r7,#4]            ;156  ; tcphdr
0000a6  8800              LDRH     r0,[r0,#0]            ;156
0000a8  f7fffffe          BL       lwip_ntohs
0000ac  4601              MOV      r1,r0                 ;156
0000ae  6878              LDR      r0,[r7,#4]            ;156  ; tcphdr
0000b0  8001              STRH     r1,[r0,#0]            ;156
0000b2  8840              LDRH     r0,[r0,#2]            ;157
0000b4  f7fffffe          BL       lwip_ntohs
0000b8  4601              MOV      r1,r0                 ;157
0000ba  6878              LDR      r0,[r7,#4]            ;157  ; tcphdr
0000bc  8041              STRH     r1,[r0,#2]            ;157
0000be  6840              LDR      r0,[r0,#4]            ;158
0000c0  f7fffffe          BL       lwip_ntohl
0000c4  4601              MOV      r1,r0                 ;158
0000c6  6878              LDR      r0,[r7,#4]            ;158  ; tcphdr
0000c8  6041              STR      r1,[r0,#4]            ;158
0000ca  60f9              STR      r1,[r7,#0xc]          ;159  ; seqno
0000cc  6880              LDR      r0,[r0,#8]            ;159
0000ce  f7fffffe          BL       lwip_ntohl
0000d2  6879              LDR      r1,[r7,#4]            ;159  ; tcphdr
0000d4  6088              STR      r0,[r1,#8]            ;159
0000d6  6138              STR      r0,[r7,#0x10]         ;160  ; ackno
0000d8  89c8              LDRH     r0,[r1,#0xe]          ;160
0000da  f7fffffe          BL       lwip_ntohs
0000de  4601              MOV      r1,r0                 ;160
0000e0  6878              LDR      r0,[r7,#4]            ;160  ; tcphdr
0000e2  81c1              STRH     r1,[r0,#0xe]          ;160
0000e4  8980              LDRH     r0,[r0,#0xc]          ;162
0000e6  f7fffffe          BL       lwip_ntohs
0000ea  f000003f          AND      r0,r0,#0x3f           ;162
0000ee  7038              STRB     r0,[r7,#0]            ;162
0000f0  4681              MOV      r9,r0                 ;162
0000f2  8929              LDRH     r1,[r5,#8]            ;163
0000f4  0780              LSLS     r0,r0,#30             ;163
0000f6  d000              BEQ      |L1.250|
0000f8  2001              MOVS     r0,#1                 ;163
                  |L1.250|
0000fa  4408              ADD      r0,r0,r1              ;163
0000fc  8078              STRH     r0,[r7,#2]            ;163
0000fe  f8dfb2d4          LDR      r11,|L1.980|
000102  48b3              LDR      r0,|L1.976|
000104  f04f0c00          MOV      r12,#0                ;167
000108  f8db4000          LDR      r4,[r11,#0]           ;170  ; tcp_active_pcbs
00010c  6803              LDR      r3,[r0,#0]            ;108
00010e  46a2              MOV      r10,r4                ;170
000110  6879              LDR      r1,[r7,#4]            ;124
000112  f8d82000          LDR      r2,[r8,#0]            ;170
000116  e03a              B        |L1.398|
                  |L1.280|
000118  7e20              LDRB     r0,[r4,#0x18]         ;171
00011a  b1d0              CBZ      r0,|L1.338|
00011c  280a              CMP      r0,#0xa               ;172
00011e  d01c              BEQ      |L1.346|
000120  2801              CMP      r0,#1                 ;173
000122  d01e              BEQ      |L1.354|
000124  8ba0              LDRH     r0,[r4,#0x1c]         ;174
000126  f8b18000          LDRH     r8,[r1,#0]            ;174
00012a  4540              CMP      r0,r8                 ;174
00012c  d12d              BNE      |L1.394|
00012e  8b60              LDRH     r0,[r4,#0x1a]         ;175
000130  f8b18002          LDRH     r8,[r1,#2]            ;175
000134  4540              CMP      r0,r8                 ;175
000136  d128              BNE      |L1.394|
000138  6860              LDR      r0,[r4,#4]            ;176
00013a  4298              CMP      r0,r3                 ;176
00013c  d125              BNE      |L1.394|
00013e  6820              LDR      r0,[r4,#0]            ;177
000140  4290              CMP      r0,r2                 ;177
000142  d122              BNE      |L1.394|
000144  68e0              LDR      r0,[r4,#0xc]          ;182
000146  42a0              CMP      r0,r4                 ;182
000148  d10f              BNE      |L1.362|
00014a  a0a3              ADR      r0,|L1.984|
00014c  f7fffffe          BL       __2printf
                  |L1.336|
000150  e7fe              B        |L1.336|
                  |L1.338|
000152  a0ac              ADR      r0,|L1.1028|
000154  f7fffffe          BL       __2printf
                  |L1.344|
000158  e7fe              B        |L1.344|
                  |L1.346|
00015a  a0b4              ADR      r0,|L1.1068|
00015c  f7fffffe          BL       __2printf
                  |L1.352|
000160  e7fe              B        |L1.352|
                  |L1.354|
000162  a0bd              ADR      r0,|L1.1112|
000164  f7fffffe          BL       __2printf
                  |L1.360|
000168  e7fe              B        |L1.360|
                  |L1.362|
00016a  f1bc0f00          CMP      r12,#0                ;183
00016e  d005              BEQ      |L1.380|
000170  f8cc000c          STR      r0,[r12,#0xc]         ;185
000174  f8c4a00c          STR      r10,[r4,#0xc]         ;186
000178  f8cb4000          STR      r4,[r11,#0]           ;186  ; tcp_active_pcbs
                  |L1.380|
00017c  68e0              LDR      r0,[r4,#0xc]          ;188
00017e  42a0              CMP      r0,r4                 ;188
000180  d108              BNE      |L1.404|
000182  a0bf              ADR      r0,|L1.1152|
000184  f7fffffe          BL       __2printf
                  |L1.392|
000188  e7fe              B        |L1.392|
                  |L1.394|
00018a  46a4              MOV      r12,r4                ;191
00018c  68e4              LDR      r4,[r4,#0xc]          ;170
                  |L1.398|
00018e  2c00              CMP      r4,#0                 ;170
000190  d1c2              BNE      |L1.280|
000192  e000              B        |L1.406|
                  |L1.404|
000194  bbb4              CBNZ     r4,|L1.516|
                  |L1.406|
000196  48c5              LDR      r0,|L1.1196|
000198  6804              LDR      r4,[r0,#0]            ;197  ; tcp_tw_pcbs
00019a  e01b              B        |L1.468|
                  |L1.412|
00019c  7e20              LDRB     r0,[r4,#0x18]         ;198
00019e  280a              CMP      r0,#0xa               ;198
0001a0  d003              BEQ      |L1.426|
0001a2  a0c3              ADR      r0,|L1.1200|
0001a4  f7fffffe          BL       __2printf
                  |L1.424|
0001a8  e7fe              B        |L1.424|
                  |L1.426|
0001aa  8ba0              LDRH     r0,[r4,#0x1c]         ;199
0001ac  f8b1c000          LDRH     r12,[r1,#0]           ;199
0001b0  4560              CMP      r0,r12                ;199
0001b2  d10e              BNE      |L1.466|
0001b4  8b60              LDRH     r0,[r4,#0x1a]         ;200
0001b6  f8b1c002          LDRH     r12,[r1,#2]           ;200
0001ba  4560              CMP      r0,r12                ;200
0001bc  d109              BNE      |L1.466|
0001be  6860              LDR      r0,[r4,#4]            ;201
0001c0  4298              CMP      r0,r3                 ;201
0001c2  d106              BNE      |L1.466|
0001c4  6820              LDR      r0,[r4,#0]            ;202
0001c6  4290              CMP      r0,r2                 ;202
0001c8  d103              BNE      |L1.466|
0001ca  4620              MOV      r0,r4                 ;207
0001cc  f7fffffe          BL       tcp_timewait_input
0001d0  e0f3              B        |L1.954|
                  |L1.466|
0001d2  68e4              LDR      r4,[r4,#0xc]          ;197
                  |L1.468|
0001d4  2c00              CMP      r4,#0                 ;197
0001d6  d1e1              BNE      |L1.412|
0001d8  f8dfb304          LDR      r11,|L1.1248|
0001dc  46a4              MOV      r12,r4                ;215
0001de  f8db0000          LDR      r0,[r11,#0]           ;216  ; tcp_listen_pcbs
0001e2  4682              MOV      r10,r0                ;216
0001e4  e00b              B        |L1.510|
                  |L1.486|
0001e6  8b43              LDRH     r3,[r0,#0x1a]         ;217
0001e8  f8b18002          LDRH     r8,[r1,#2]            ;217
0001ec  4543              CMP      r3,r8                 ;217
0001ee  d104              BNE      |L1.506|
0001f0  6803              LDR      r3,[r0,#0]            ;228
0001f2  4293              CMP      r3,r2                 ;228
0001f4  d007              BEQ      |L1.518|
0001f6  b1a0              CBZ      r0,|L1.546|
0001f8  b133              CBZ      r3,|L1.520|
                  |L1.506|
0001fa  4684              MOV      r12,r0                ;235
0001fc  68c0              LDR      r0,[r0,#0xc]          ;216
                  |L1.510|
0001fe  2800              CMP      r0,#0                 ;216
000200  d1f1              BNE      |L1.486|
000202  e00e              B        |L1.546|
                  |L1.516|
000204  e00f              B        |L1.550|
                  |L1.518|
000206  b160              CBZ      r0,|L1.546|
                  |L1.520|
000208  f1bc0f00          CMP      r12,#0                ;249
00020c  d006              BEQ      |L1.540|
00020e  68c1              LDR      r1,[r0,#0xc]          ;250
000210  f8cc100c          STR      r1,[r12,#0xc]         ;252
000214  f8c0a00c          STR      r10,[r0,#0xc]         ;254
000218  f8cb0000          STR      r0,[r11,#0]           ;254  ; tcp_listen_pcbs
                  |L1.540|
00021c  f7fffffe          BL       tcp_listen_input
000220  e0cb              B        |L1.954|
                  |L1.546|
000222  2c00              CMP      r4,#0                 ;271
000224  d072              BEQ      |L1.780|
                  |L1.550|
000226  f8dfa2bc          LDR      r10,|L1.1252|
00022a  f04f0800          MOV      r8,#0                 ;280
00022e  ea5f7009          LSLS     r0,r9,#28             ;288
000232  f8ca8000          STR      r8,[r10,#0]           ;281  ; inseg
000236  892b              LDRH     r3,[r5,#8]            ;281
000238  f8aa3008          STRH     r3,[r10,#8]           ;281
00023c  f8ca5004          STR      r5,[r10,#4]           ;285  ; inseg
000240  f8ca1010          STR      r1,[r10,#0x10]        ;285  ; inseg
000244  f8c78014          STR      r8,[r7,#0x14]         ;286  ; recv_data
000248  f8878001          STRB     r8,[r7,#1]            ;286
00024c  d503              BPL      |L1.598|
00024e  7b68              LDRB     r0,[r5,#0xd]          ;289
000250  f0400001          ORR      r0,r0,#1              ;289
000254  7368              STRB     r0,[r5,#0xd]          ;289
                  |L1.598|
000256  6fa0              LDR      r0,[r4,#0x78]         ;293
000258  b168              CBZ      r0,|L1.630|
00025a  4620              MOV      r0,r4                 ;294
00025c  f7fffffe          BL       tcp_process_refused_data
000260  300a              ADDS     r0,r0,#0xa            ;294
000262  d003              BEQ      |L1.620|
000264  6fa0              LDR      r0,[r4,#0x78]         ;295
000266  b130              CBZ      r0,|L1.630|
000268  8878              LDRH     r0,[r7,#2]            ;295  ; tcplen
00026a  b120              CBZ      r0,|L1.630|
                  |L1.620|
00026c  f8360f96          LDRH     r0,[r6,#0x96]!        ;298  ; lwip_stats
000270  1c40              ADDS     r0,r0,#1              ;298
000272  8030              STRH     r0,[r6,#0]            ;298
000274  e078              B        |L1.872|
                  |L1.630|
000276  4620              MOV      r0,r4                 ;304
000278  61bc              STR      r4,[r7,#0x18]         ;304  ; tcp_input_pcb
00027a  f7fffffe          BL       tcp_process
00027e  300a              ADDS     r0,r0,#0xa            ;304
000280  d072              BEQ      |L1.872|
000282  7878              LDRB     r0,[r7,#1]            ;308  ; recv_flags
000284  0701              LSLS     r1,r0,#28             ;308
000286  d506              BPL      |L1.662|
000288  f8d4208c          LDR      r2,[r4,#0x8c]         ;313
00028c  b17a              CBZ      r2,|L1.686|
00028e  f06f010a          MVN      r1,#0xa               ;313
000292  6920              LDR      r0,[r4,#0x10]         ;313
000294  e00a              B        |L1.684|
                  |L1.662|
000296  06c0              LSLS     r0,r0,#27             ;316
000298  d512              BPL      |L1.704|
00029a  7fa0              LDRB     r0,[r4,#0x1e]         ;319
00029c  06c0              LSLS     r0,r0,#27             ;319
00029e  d406              BMI      |L1.686|
0002a0  f8d4208c          LDR      r2,[r4,#0x8c]         ;323
0002a4  b11a              CBZ      r2,|L1.686|
0002a6  f06f010b          MVN      r1,#0xb               ;323
0002aa  6920              LDR      r0,[r4,#0x10]         ;323
                  |L1.684|
0002ac  4790              BLX      r2                    ;313
                  |L1.686|
0002ae  4621              MOV      r1,r4                 ;325
0002b0  4848              LDR      r0,|L1.980|
0002b2  f7fffffe          BL       tcp_pcb_remove
0002b6  4621              MOV      r1,r4                 ;326
0002b8  2002              MOVS     r0,#2                 ;326
0002ba  f7fffffe          BL       memp_free
0002be  e053              B        |L1.872|
                  |L1.704|
0002c0  f8b42064          LDRH     r2,[r4,#0x64]         ;332
0002c4  2000              MOVS     r0,#0                 ;328
0002c6  b132              CBZ      r2,|L1.726|
0002c8  6fe3              LDR      r3,[r4,#0x7c]         ;333
0002ca  b113              CBZ      r3,|L1.722|
0002cc  4621              MOV      r1,r4                 ;333
0002ce  6920              LDR      r0,[r4,#0x10]         ;333
0002d0  4798              BLX      r3                    ;333
                  |L1.722|
0002d2  300a              ADDS     r0,r0,#0xa            ;333
0002d4  d048              BEQ      |L1.872|
                  |L1.726|
0002d6  6978              LDR      r0,[r7,#0x14]         ;339  ; recv_data
0002d8  b328              CBZ      r0,|L1.806|
0002da  6fa1              LDR      r1,[r4,#0x78]         ;340
0002dc  b119              CBZ      r1,|L1.742|
0002de  a082              ADR      r0,|L1.1256|
0002e0  f7fffffe          BL       __2printf
                  |L1.740|
0002e4  e7fe              B        |L1.740|
                  |L1.742|
0002e6  7fa1              LDRB     r1,[r4,#0x1e]         ;341
0002e8  06c9              LSLS     r1,r1,#27             ;341
0002ea  d505              BPL      |L1.760|
0002ec  f7fffffe          BL       pbuf_free
0002f0  4620              MOV      r0,r4                 ;345
0002f2  f7fffffe          BL       tcp_abort
0002f6  e037              B        |L1.872|
                  |L1.760|
0002f8  f8d45080          LDR      r5,[r4,#0x80]         ;350
0002fc  b13d              CBZ      r5,|L1.782|
0002fe  6926              LDR      r6,[r4,#0x10]         ;350
000300  4602              MOV      r2,r0                 ;350
000302  2300              MOVS     r3,#0                 ;350
000304  4621              MOV      r1,r4                 ;350
000306  4630              MOV      r0,r6                 ;350
000308  47a8              BLX      r5                    ;350
00030a  e006              B        |L1.794|
                  |L1.780|
00030c  e03b              B        |L1.902|
                  |L1.782|
00030e  2300              MOVS     r3,#0                 ;350
000310  4602              MOV      r2,r0                 ;350
000312  4621              MOV      r1,r4                 ;350
000314  4618              MOV      r0,r3                 ;350
000316  f7fffffe          BL       tcp_recv_null
                  |L1.794|
00031a  f1100f0a          CMN      r0,#0xa               ;351
00031e  d023              BEQ      |L1.872|
000320  b108              CBZ      r0,|L1.806|
000322  6978              LDR      r0,[r7,#0x14]         ;357  ; recv_data
000324  67a0              STR      r0,[r4,#0x78]         ;357
                  |L1.806|
000326  7878              LDRB     r0,[r7,#1]            ;364  ; recv_flags
000328  0680              LSLS     r0,r0,#26             ;364
00032a  d518              BPL      |L1.862|
00032c  6fa0              LDR      r0,[r4,#0x78]         ;365
00032e  b120              CBZ      r0,|L1.826|
000330  7b41              LDRB     r1,[r0,#0xd]          ;367
000332  f0410120          ORR      r1,r1,#0x20           ;367
000336  7341              STRB     r1,[r0,#0xd]          ;367
000338  e011              B        |L1.862|
                  |L1.826|
00033a  8da0              LDRH     r0,[r4,#0x2c]         ;371
00033c  f5b06f7a          CMP      r0,#0xfa0             ;371
000340  d001              BEQ      |L1.838|
000342  1c40              ADDS     r0,r0,#1              ;371
000344  85a0              STRH     r0,[r4,#0x2c]         ;372
                  |L1.838|
000346  f8d45080          LDR      r5,[r4,#0x80]         ;374
00034a  b12d              CBZ      r5,|L1.856|
00034c  2300              MOVS     r3,#0                 ;374
00034e  461a              MOV      r2,r3                 ;374
000350  4621              MOV      r1,r4                 ;374
000352  6920              LDR      r0,[r4,#0x10]         ;374
000354  47a8              BLX      r5                    ;374
000356  e000              B        |L1.858|
                  |L1.856|
000358  2000              MOVS     r0,#0                 ;374
                  |L1.858|
00035a  300a              ADDS     r0,r0,#0xa            ;374
00035c  d004              BEQ      |L1.872|
                  |L1.862|
00035e  4620              MOV      r0,r4                 ;383
000360  f8c78018          STR      r8,[r7,#0x18]         ;383  ; tcp_input_pcb
000364  f7fffffe          BL       tcp_output
                  |L1.872|
000368  f8c78018          STR      r8,[r7,#0x18]         ;395  ; tcp_input_pcb
00036c  f8c78014          STR      r8,[r7,#0x14]         ;398  ; recv_data
000370  f8da0004          LDR      r0,[r10,#4]           ;398  ; inseg
000374  4644              MOV      r4,r8                 ;394
000376  4655              MOV      r5,r10                ;398
000378  2800              CMP      r0,#0                 ;398
00037a  d002              BEQ      |L1.898|
00037c  f7fffffe          BL       pbuf_free
000380  606c              STR      r4,[r5,#4]            ;401  ; inseg
                  |L1.898|
000382  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.902|
000386  8988              LDRH     r0,[r1,#0xc]          ;408
000388  f7fffffe          BL       lwip_ntohs
00038c  0740              LSLS     r0,r0,#29             ;408
00038e  d414              BMI      |L1.954|
000390  f8360fa0          LDRH     r0,[r6,#0xa0]!        ;409  ; lwip_stats
000394  4b0e              LDR      r3,|L1.976|
000396  1c40              ADDS     r0,r0,#1              ;409
000398  f826090a          STRH     r0,[r6],#-0xa         ;409
00039c  4a0b              LDR      r2,|L1.972|
00039e  8830              LDRH     r0,[r6,#0]            ;410  ; lwip_stats
0003a0  1c40              ADDS     r0,r0,#1              ;410
0003a2  8030              STRH     r0,[r6,#0]            ;410
0003a4  6878              LDR      r0,[r7,#4]            ;411  ; tcphdr
0003a6  8801              LDRH     r1,[r0,#0]            ;411
0003a8  8840              LDRH     r0,[r0,#2]            ;411
0003aa  e9cd0100          STRD     r0,r1,[sp,#0]         ;411
0003ae  8879              LDRH     r1,[r7,#2]            ;411  ; tcplen
0003b0  68f8              LDR      r0,[r7,#0xc]          ;411  ; seqno
0003b2  4401              ADD      r1,r1,r0              ;411
0003b4  6938              LDR      r0,[r7,#0x10]         ;411  ; ackno
0003b6  f7fffffe          BL       tcp_rst
                  |L1.954|
0003ba  4628              MOV      r0,r5                 ;415
0003bc  e8bd5ffc          POP      {r2-r12,lr}           ;415
0003c0  f7ffbffe          B.W      pbuf_free
;;;426    
                          ENDP

                  |L1.964|
                          DCD      lwip_stats
                  |L1.968|
                          DCD      ||.data||
                  |L1.972|
                          DCD      current_iphdr_dest
                  |L1.976|
                          DCD      current_iphdr_src
                  |L1.980|
                          DCD      tcp_active_pcbs
                  |L1.984|
0003d8  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
0003dc  696e7075
0003e0  743a2070
0003e4  63622d3e
0003e8  6e657874
0003ec  20213d20
0003f0  70636220
0003f4  28626566
0003f8  6f726520
0003fc  63616368
000400  652900  
000403  00                DCB      0
                  |L1.1028|
000404  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
000408  696e7075
00040c  743a2061
000410  63746976
000414  65207063
000418  622d3e73
00041c  74617465
000420  20213d20
000424  434c4f53
000428  454400  
00042b  00                DCB      0
                  |L1.1068|
00042c  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
000430  696e7075
000434  743a2061
000438  63746976
00043c  65207063
000440  622d3e73
000444  74617465
000448  20213d20
00044c  54494d45
000450  2d574149
000454  5400    
000456  00                DCB      0
000457  00                DCB      0
                  |L1.1112|
000458  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
00045c  696e7075
000460  743a2061
000464  63746976
000468  65207063
00046c  622d3e73
000470  74617465
000474  20213d20
000478  4c495354
00047c  454e00  
00047f  00                DCB      0
                  |L1.1152|
000480  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
000484  696e7075
000488  743a2070
00048c  63622d3e
000490  6e657874
000494  20213d20
000498  70636220
00049c  28616674
0004a0  65722063
0004a4  61636865
0004a8  2900    
0004aa  00                DCB      0
0004ab  00                DCB      0
                  |L1.1196|
                          DCD      tcp_tw_pcbs
                  |L1.1200|
0004b0  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
0004b4  696e7075
0004b8  743a2054
0004bc  494d452d
0004c0  57414954
0004c4  20706362
0004c8  2d3e7374
0004cc  61746520
0004d0  3d3d2054
0004d4  494d452d
0004d8  57414954
0004dc  00      
0004dd  00                DCB      0
0004de  00                DCB      0
0004df  00                DCB      0
                  |L1.1248|
                          DCD      tcp_listen_pcbs
                  |L1.1252|
                          DCD      ||.bss||
                  |L1.1256|
0004e8  7063622d          DCB      "pcb->refused_data == NULL",0
0004ec  3e726566
0004f0  75736564
0004f4  5f646174
0004f8  61203d3d
0004fc  204e554c
000500  4c00    
000502  00                DCB      0
000503  00                DCB      0

                          AREA ||i.tcp_listen_input||, CODE, READONLY, ALIGN=2

                  tcp_listen_input PROC
;;;439    static err_t
;;;440    tcp_listen_input(struct tcp_pcb_listen *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;441    {
;;;442      struct tcp_pcb *npcb;
;;;443      err_t rc;
;;;444    
;;;445      if (flags & TCP_RST) {
000002  4e36              LDR      r6,|L2.220|
000004  4605              MOV      r5,r0                 ;441
000006  7830              LDRB     r0,[r6,#0]  ; flags
000008  0741              LSLS     r1,r0,#29
00000a  d464              BMI      |L2.214|
;;;446        /* An incoming RST should be ignored. Return. */
;;;447        return ERR_OK;
;;;448      }
;;;449    
;;;450      /* In the LISTEN state, we check for incoming SYN segments,
;;;451         creates a new PCB, and responds with a SYN|ACK. */
;;;452      if (flags & TCP_ACK) {
00000c  06c1              LSLS     r1,r0,#27
00000e  d50d              BPL      |L2.44|
;;;453        /* For incoming segments with the ACK flag set, respond with a
;;;454           RST. */
;;;455        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;456        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
000010  6870              LDR      r0,[r6,#4]  ; tcphdr
000012  4b33              LDR      r3,|L2.224|
000014  4a33              LDR      r2,|L2.228|
000016  8801              LDRH     r1,[r0,#0]
000018  8840              LDRH     r0,[r0,#2]
00001a  e9cd0100          STRD     r0,r1,[sp,#0]
00001e  8871              LDRH     r1,[r6,#2]  ; tcplen
000020  68f0              LDR      r0,[r6,#0xc]  ; seqno
000022  4401              ADD      r1,r1,r0
000024  6930              LDR      r0,[r6,#0x10]  ; ackno
000026  f7fffffe          BL       tcp_rst
00002a  e054              B        |L2.214|
                  |L2.44|
;;;457          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;458      } else if (flags & TCP_SYN) {
00002c  0780              LSLS     r0,r0,#30
00002e  d552              BPL      |L2.214|
;;;459        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;460    #if TCP_LISTEN_BACKLOG
;;;461        if (pcb->accepts_pending >= pcb->backlog) {
;;;462          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;463          return ERR_ABRT;
;;;464        }
;;;465    #endif /* TCP_LISTEN_BACKLOG */
;;;466        npcb = tcp_alloc(pcb->prio);
000030  7e68              LDRB     r0,[r5,#0x19]
000032  f7fffffe          BL       tcp_alloc
000036  0004              MOVS     r4,r0
;;;467        /* If a new PCB could not be created (probably due to lack of memory),
;;;468           we don't do anything, but rely on the sender will retransmit the
;;;469           SYN at a time when we have more memory available. */
;;;470        if (npcb == NULL) {
000038  d040              BEQ      |L2.188|
;;;471          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;472          TCP_STATS_INC(tcp.memerr);
;;;473          return ERR_MEM;
;;;474        }
;;;475    #if TCP_LISTEN_BACKLOG
;;;476        pcb->accepts_pending++;
;;;477    #endif /* TCP_LISTEN_BACKLOG */
;;;478        /* Set up the new PCB. */
;;;479        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
00003a  482a              LDR      r0,|L2.228|
00003c  6800              LDR      r0,[r0,#0]  ; current_iphdr_dest
;;;480        npcb->local_port = pcb->local_port;
00003e  6020              STR      r0,[r4,#0]
000040  8b68              LDRH     r0,[r5,#0x1a]
000042  8360              STRH     r0,[r4,#0x1a]
;;;481        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
000044  4826              LDR      r0,|L2.224|
000046  6800              LDR      r0,[r0,#0]  ; current_iphdr_src
;;;482        npcb->remote_port = tcphdr->src;
000048  6060              STR      r0,[r4,#4]
00004a  6870              LDR      r0,[r6,#4]  ; tcphdr
00004c  8801              LDRH     r1,[r0,#0]
00004e  83a1              STRH     r1,[r4,#0x1c]
;;;483        npcb->state = SYN_RCVD;
000050  2103              MOVS     r1,#3
000052  7621              STRB     r1,[r4,#0x18]
;;;484        npcb->rcv_nxt = seqno + 1;
000054  68f1              LDR      r1,[r6,#0xc]  ; seqno
000056  460a              MOV      r2,r1
000058  1c49              ADDS     r1,r1,#1
;;;485        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
00005a  62a1              STR      r1,[r4,#0x28]
;;;486        npcb->snd_wnd = tcphdr->wnd;
00005c  6321              STR      r1,[r4,#0x30]
00005e  89c1              LDRH     r1,[r0,#0xe]
000060  f8a41060          STRH     r1,[r4,#0x60]
;;;487        npcb->snd_wnd_max = tcphdr->wnd;
000064  89c0              LDRH     r0,[r0,#0xe]
000066  f8a40062          STRH     r0,[r4,#0x62]
;;;488        npcb->ssthresh = npcb->snd_wnd;
00006a  f8a4104e          STRH     r1,[r4,#0x4e]
00006e  1e52              SUBS     r2,r2,#1
;;;489        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;490        npcb->callback_arg = pcb->callback_arg;
000070  6562              STR      r2,[r4,#0x54]
000072  6928              LDR      r0,[r5,#0x10]
;;;491    #if LWIP_CALLBACK_API
;;;492        npcb->accept = pcb->accept;
000074  6120              STR      r0,[r4,#0x10]
000076  6968              LDR      r0,[r5,#0x14]
;;;493    #endif /* LWIP_CALLBACK_API */
;;;494        /* inherit socket options */
;;;495        npcb->so_options = pcb->so_options & SOF_INHERITED;
000078  6160              STR      r0,[r4,#0x14]
00007a  7a28              LDRB     r0,[r5,#8]
00007c  f000008c          AND      r0,r0,#0x8c
000080  7220              STRB     r0,[r4,#8]
;;;496        /* Register the new PCB so that we can begin receiving segments
;;;497           for it. */
;;;498        TCP_REG_ACTIVE(npcb);
000082  4819              LDR      r0,|L2.232|
000084  6801              LDR      r1,[r0,#0]  ; tcp_active_pcbs
000086  60e1              STR      r1,[r4,#0xc]
000088  6004              STR      r4,[r0,#0]  ; tcp_active_pcbs
00008a  f7fffffe          BL       tcp_timer_needed
00008e  4917              LDR      r1,|L2.236|
000090  2001              MOVS     r0,#1
000092  7008              STRB     r0,[r1,#0]
;;;499    
;;;500        /* Parse any options in the SYN. */
;;;501        tcp_parseopt(npcb);
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       tcp_parseopt
;;;502    #if TCP_CALCULATE_EFF_SEND_MSS
;;;503        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
00009a  8ee0              LDRH     r0,[r4,#0x36]
00009c  1d21              ADDS     r1,r4,#4
00009e  f7fffffe          BL       tcp_eff_send_mss
0000a2  86e0              STRH     r0,[r4,#0x36]
;;;504    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;505    
;;;506        snmp_inc_tcppassiveopens();
;;;507    
;;;508        /* Send a SYN|ACK together with the MSS option. */
;;;509        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
0000a4  2112              MOVS     r1,#0x12
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       tcp_enqueue_flags
0000ac  0005              MOVS     r5,r0
;;;510        if (rc != ERR_OK) {
0000ae  d00d              BEQ      |L2.204|
;;;511          tcp_abandon(npcb, 0);
0000b0  2100              MOVS     r1,#0
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       tcp_abandon
;;;512          return rc;
0000b8  4628              MOV      r0,r5
;;;513        }
;;;514        return tcp_output(npcb);
;;;515      }
;;;516      return ERR_OK;
;;;517    }
0000ba  bd7c              POP      {r2-r6,pc}
                  |L2.188|
0000bc  490c              LDR      r1,|L2.240|
0000be  f8310f9c          LDRH     r0,[r1,#0x9c]!        ;472  ; lwip_stats
0000c2  1c40              ADDS     r0,r0,#1              ;472
0000c4  8008              STRH     r0,[r1,#0]            ;472
0000c6  f04f30ff          MOV      r0,#0xffffffff        ;473
0000ca  bd7c              POP      {r2-r6,pc}
                  |L2.204|
0000cc  4620              MOV      r0,r4                 ;514
0000ce  e8bd407c          POP      {r2-r6,lr}            ;514
0000d2  f7ffbffe          B.W      tcp_output
                  |L2.214|
0000d6  2000              MOVS     r0,#0                 ;516
0000d8  bd7c              POP      {r2-r6,pc}
;;;518    
                          ENDP

0000da  0000              DCW      0x0000
                  |L2.220|
                          DCD      ||.data||
                  |L2.224|
                          DCD      current_iphdr_src
                  |L2.228|
                          DCD      current_iphdr_dest
                  |L2.232|
                          DCD      tcp_active_pcbs
                  |L2.236|
                          DCD      tcp_active_pcbs_changed
                  |L2.240|
                          DCD      lwip_stats

                          AREA ||i.tcp_oos_insert_segment||, CODE, READONLY, ALIGN=2

                  tcp_oos_insert_segment PROC
;;;799    static void
;;;800    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  b570              PUSH     {r4-r6,lr}
;;;801    {
000002  4605              MOV      r5,r0
;;;802      struct tcp_seg *old_seg;
;;;803    
;;;804      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000004  6900              LDR      r0,[r0,#0x10]
000006  460c              MOV      r4,r1                 ;801
000008  8980              LDRH     r0,[r0,#0xc]
00000a  f7fffffe          BL       lwip_ntohs
;;;805        /* received segment overlaps all following segments */
;;;806        tcp_segs_free(next);
;;;807        next = NULL;
;;;808      }
;;;809      else {
;;;810        /* delete some following segments
;;;811           oos queue may have segments with FIN flag */
;;;812        while (next &&
;;;813               TCP_SEQ_GEQ((seqno + cseg->len),
00000e  4e19              LDR      r6,|L3.116|
000010  07c0              LSLS     r0,r0,#31             ;804
000012  d015              BEQ      |L3.64|
000014  4620              MOV      r0,r4                 ;806
000016  f7fffffe          BL       tcp_segs_free
00001a  2400              MOVS     r4,#0                 ;807
00001c  e027              B        |L3.110|
                  |L3.30|
;;;814                          (next->tcphdr->seqno + next->len))) {
;;;815          /* cseg with FIN already processed */
;;;816          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
00001e  8980              LDRH     r0,[r0,#0xc]
000020  f7fffffe          BL       lwip_ntohs
000024  07c0              LSLS     r0,r0,#31
000026  d007              BEQ      |L3.56|
;;;817            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       lwip_htons
00002e  4601              MOV      r1,r0
000030  6928              LDR      r0,[r5,#0x10]
000032  8982              LDRH     r2,[r0,#0xc]
000034  4311              ORRS     r1,r1,r2
000036  8181              STRH     r1,[r0,#0xc]
                  |L3.56|
;;;818          }
;;;819          old_seg = next;
;;;820          next = next->next;
000038  4620              MOV      r0,r4
00003a  6824              LDR      r4,[r4,#0]
;;;821          tcp_seg_free(old_seg);
00003c  f7fffffe          BL       tcp_seg_free
                  |L3.64|
000040  b1ac              CBZ      r4,|L3.110|
000042  6920              LDR      r0,[r4,#0x10]         ;813
000044  8922              LDRH     r2,[r4,#8]            ;813
000046  68f3              LDR      r3,[r6,#0xc]          ;813  ; seqno
000048  6841              LDR      r1,[r0,#4]            ;813
00004a  4411              ADD      r1,r1,r2              ;813
00004c  892a              LDRH     r2,[r5,#8]            ;813
00004e  441a              ADD      r2,r2,r3              ;813
000050  1a51              SUBS     r1,r2,r1              ;813
000052  d5e4              BPL      |L3.30|
;;;822        }
;;;823        if (next &&
;;;824            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
000054  8929              LDRH     r1,[r5,#8]
000056  18ca              ADDS     r2,r1,r3
000058  6921              LDR      r1,[r4,#0x10]
00005a  6849              LDR      r1,[r1,#4]
00005c  1a52              SUBS     r2,r2,r1
00005e  2a00              CMP      r2,#0
000060  dd05              BLE      |L3.110|
;;;825          /* We need to trim the incoming segment. */
;;;826          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
000062  1ac8              SUBS     r0,r1,r3
000064  b281              UXTH     r1,r0
000066  8129              STRH     r1,[r5,#8]
;;;827          pbuf_realloc(cseg->p, cseg->len);
000068  6868              LDR      r0,[r5,#4]
00006a  f7fffffe          BL       pbuf_realloc
                  |L3.110|
;;;828        }
;;;829      }
;;;830      cseg->next = next;
00006e  602c              STR      r4,[r5,#0]
;;;831    }
000070  bd70              POP      {r4-r6,pc}
;;;832    #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      ||.data||

                          AREA ||i.tcp_parseopt||, CODE, READONLY, ALIGN=2

                  tcp_parseopt PROC
;;;1541   static void
;;;1542   tcp_parseopt(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1543   {
;;;1544     u16_t c, max_c;
;;;1545     u16_t mss;
;;;1546     u8_t *opts, opt;
;;;1547   #if LWIP_TCP_TIMESTAMPS
;;;1548     u32_t tsval;
;;;1549   #endif
;;;1550   
;;;1551     opts = (u8_t *)tcphdr + TCP_HLEN;
000002  4e1e              LDR      r6,|L4.124|
000004  4605              MOV      r5,r0                 ;1543
000006  6870              LDR      r0,[r6,#4]  ; tcphdr
000008  f1000414          ADD      r4,r0,#0x14
;;;1552   
;;;1553     /* Parse the TCP MSS option, if present. */
;;;1554     if(TCPH_HDRLEN(tcphdr) > 0x5) {
00000c  8980              LDRH     r0,[r0,#0xc]
00000e  f7fffffe          BL       lwip_ntohs
000012  2105              MOVS     r1,#5
000014  ebb13f10          CMP      r1,r0,LSR #12
000018  d21e              BCS      |L4.88|
;;;1555       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
00001a  6870              LDR      r0,[r6,#4]  ; tcphdr
00001c  8980              LDRH     r0,[r0,#0xc]
00001e  f7fffffe          BL       lwip_ntohs
000022  f06f0104          MVN      r1,#4
000026  eb013010          ADD      r0,r1,r0,LSR #12
00002a  0c09              LSRS     r1,r1,#16
00002c  ea010380          AND      r3,r1,r0,LSL #2
;;;1556       for (c = 0; c < max_c; ) {
000030  2100              MOVS     r1,#0
;;;1557         opt = opts[c];
;;;1558         switch (opt) {
;;;1559         case 0x00:
;;;1560           /* End of options. */
;;;1561           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
;;;1562           return;
;;;1563         case 0x01:
;;;1564           /* NOP option. */
;;;1565           ++c;
;;;1566           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1567           break;
;;;1568         case 0x02:
;;;1569           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1570           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1571             /* Bad length */
;;;1572             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1573             return;
;;;1574           }
;;;1575           /* An MSS option with the right option length. */
;;;1576           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1577           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1578           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
000032  f44f767a          MOV      r6,#0x3e8
000036  e00d              B        |L4.84|
                  |L4.56|
000038  5c60              LDRB     r0,[r4,r1]            ;1557
00003a  2800              CMP      r0,#0                 ;1558
00003c  d00c              BEQ      |L4.88|
00003e  2801              CMP      r0,#1                 ;1558
000040  d00b              BEQ      |L4.90|
000042  2802              CMP      r0,#2                 ;1558
000044  eb040001          ADD      r0,r4,r1              ;1570
000048  d009              BEQ      |L4.94|
;;;1579           /* Advance to next option */
;;;1580           c += 0x04;
;;;1581           break;
;;;1582   #if LWIP_TCP_TIMESTAMPS
;;;1583         case 0x08:
;;;1584           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1585           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1586             /* Bad length */
;;;1587             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1588             return;
;;;1589           }
;;;1590           /* TCP timestamp option with valid length */
;;;1591           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1592             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1593           if (flags & TCP_SYN) {
;;;1594             pcb->ts_recent = ntohl(tsval);
;;;1595             pcb->flags |= TF_TIMESTAMP;
;;;1596           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1597             pcb->ts_recent = ntohl(tsval);
;;;1598           }
;;;1599           /* Advance to next option */
;;;1600           c += 0x0A;
;;;1601           break;
;;;1602   #endif
;;;1603         default:
;;;1604           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1605           if (opts[c + 1] == 0) {
00004a  7840              LDRB     r0,[r0,#1]
00004c  2800              CMP      r0,#0
00004e  d003              BEQ      |L4.88|
;;;1606             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1607             /* If the length field is zero, the options are malformed
;;;1608                and we don't process them further. */
;;;1609             return;
;;;1610           }
;;;1611           /* All other options have a length field, so that we easily
;;;1612              can skip past them. */
;;;1613           c += opts[c + 1];
000050  4408              ADD      r0,r0,r1
000052  b281              UXTH     r1,r0
                  |L4.84|
000054  4299              CMP      r1,r3                 ;1556
000056  d3ef              BCC      |L4.56|
                  |L4.88|
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   }
000058  bd70              POP      {r4-r6,pc}
                  |L4.90|
00005a  1c49              ADDS     r1,r1,#1
00005c  e00c              B        |L4.120|
                  |L4.94|
00005e  7842              LDRB     r2,[r0,#1]            ;1570
000060  2a04              CMP      r2,#4                 ;1570
000062  d1f9              BNE      |L4.88|
000064  1d09              ADDS     r1,r1,#4              ;1570
000066  4299              CMP      r1,r3                 ;1570
000068  d8f6              BHI      |L4.88|
00006a  8840              LDRH     r0,[r0,#2]            ;1576
00006c  ba42              REV16    r2,r0                 ;1576
00006e  42b2              CMP      r2,r6                 ;1578
000070  d800              BHI      |L4.116|
000072  b902              CBNZ     r2,|L4.118|
                  |L4.116|
000074  4632              MOV      r2,r6                 ;1578
                  |L4.118|
000076  86ea              STRH     r2,[r5,#0x36]         ;1578
                  |L4.120|
000078  b289              UXTH     r1,r1                 ;1580
00007a  e7eb              B        |L4.84|
;;;1618   
                          ENDP

                  |L4.124|
                          DCD      ||.data||

                          AREA ||i.tcp_process||, CODE, READONLY, ALIGN=2

                  tcp_process PROC
;;;574    static err_t
;;;575    tcp_process(struct tcp_pcb *pcb)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;576    {
000004  4604              MOV      r4,r0
;;;577      struct tcp_seg *rseg;
;;;578      u8_t acceptable = 0;
;;;579      err_t err;
;;;580    
;;;581      err = ERR_OK;
;;;582    
;;;583      /* Process incoming RST segments. */
;;;584      if (flags & TCP_RST) {
000006  4ecd              LDR      r6,|L5.828|
000008  2000              MOVS     r0,#0                 ;581
00000a  9000              STR      r0,[sp,#0]
00000c  7830              LDRB     r0,[r6,#0]  ; flags
00000e  0741              LSLS     r1,r0,#29
000010  d521              BPL      |L5.86|
;;;585        /* First, determine if the reset is acceptable. */
;;;586        if (pcb->state == SYN_SENT) {
000012  7e20              LDRB     r0,[r4,#0x18]
000014  2802              CMP      r0,#2
000016  d00a              BEQ      |L5.46|
;;;587          if (ackno == pcb->snd_nxt) {
;;;588            acceptable = 1;
;;;589          }
;;;590        } else {
;;;591          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
000018  6aa1              LDR      r1,[r4,#0x28]
00001a  68f2              LDR      r2,[r6,#0xc]  ; seqno
00001c  1a53              SUBS     r3,r2,r1
00001e  d425              BMI      |L5.108|
000020  8da3              LDRH     r3,[r4,#0x2c]
000022  4419              ADD      r1,r1,r3
000024  1a51              SUBS     r1,r2,r1
000026  2900              CMP      r1,#0
000028  dc20              BGT      |L5.108|
;;;592                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;593            acceptable = 1;
00002a  b180              CBZ      r0,|L5.78|
00002c  e003              B        |L5.54|
                  |L5.46|
00002e  6d20              LDR      r0,[r4,#0x50]         ;587
000030  6931              LDR      r1,[r6,#0x10]         ;587  ; ackno
000032  4288              CMP      r0,r1                 ;587
000034  d11a              BNE      |L5.108|
                  |L5.54|
;;;594          }
;;;595        }
;;;596    
;;;597        if (acceptable) {
;;;598          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
;;;599          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
;;;600          recv_flags |= TF_RESET;
000036  7870              LDRB     r0,[r6,#1]  ; recv_flags
000038  f0400008          ORR      r0,r0,#8
00003c  7070              STRB     r0,[r6,#1]
;;;601          pcb->flags &= ~TF_ACK_DELAY;
00003e  7fa0              LDRB     r0,[r4,#0x1e]
000040  f0200001          BIC      r0,r0,#1
000044  77a0              STRB     r0,[r4,#0x1e]
;;;602          return ERR_RST;
000046  f06f000a          MVN      r0,#0xa
                  |L5.74|
;;;603        } else {
;;;604          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;605           seqno, pcb->rcv_nxt));
;;;606          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;607           seqno, pcb->rcv_nxt));
;;;608          return ERR_OK;
;;;609        }
;;;610      }
;;;611    
;;;612      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;613        /* Cope with new connection attempt after remote end crashed */
;;;614        tcp_ack_now(pcb);
;;;615        return ERR_OK;
;;;616      }
;;;617      
;;;618      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;619        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;620        pcb->tmr = tcp_ticks;
;;;621      }
;;;622      pcb->keep_cnt_sent = 0;
;;;623    
;;;624      tcp_parseopt(pcb);
;;;625    
;;;626      /* Do different things depending on the TCP state. */
;;;627      switch (pcb->state) {
;;;628      case SYN_SENT:
;;;629        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;630         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;631        /* received SYN ACK with expected sequence number? */
;;;632        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;633            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;634          pcb->snd_buf++;
;;;635          pcb->rcv_nxt = seqno + 1;
;;;636          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;637          pcb->lastack = ackno;
;;;638          pcb->snd_wnd = tcphdr->wnd;
;;;639          pcb->snd_wnd_max = tcphdr->wnd;
;;;640          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;641          pcb->state = ESTABLISHED;
;;;642    
;;;643    #if TCP_CALCULATE_EFF_SEND_MSS
;;;644          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;645    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;646    
;;;647          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;648           * but for the default value of pcb->mss) */
;;;649          pcb->ssthresh = pcb->mss * 10;
;;;650    
;;;651          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;652          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;653          --pcb->snd_queuelen;
;;;654          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;655          rseg = pcb->unacked;
;;;656          pcb->unacked = rseg->next;
;;;657          tcp_seg_free(rseg);
;;;658    
;;;659          /* If there's nothing left to acknowledge, stop the retransmit
;;;660             timer, otherwise reset it to start again */
;;;661          if(pcb->unacked == NULL)
;;;662            pcb->rtime = -1;
;;;663          else {
;;;664            pcb->rtime = 0;
;;;665            pcb->nrtx = 0;
;;;666          }
;;;667    
;;;668          /* Call the user specified function to call when sucessfully
;;;669           * connected. */
;;;670          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;671          if (err == ERR_ABRT) {
;;;672            return ERR_ABRT;
;;;673          }
;;;674          tcp_ack_now(pcb);
;;;675        }
;;;676        /* received ACK? possibly a half-open connection */
;;;677        else if (flags & TCP_ACK) {
;;;678          /* send a RST to bring the other side in a non-synchronized state. */
;;;679          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;680            tcphdr->dest, tcphdr->src);
;;;681        }
;;;682        break;
;;;683      case SYN_RCVD:
;;;684        if (flags & TCP_ACK) {
;;;685          /* expected ACK number? */
;;;686          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;687            u16_t old_cwnd;
;;;688            pcb->state = ESTABLISHED;
;;;689            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;690    #if LWIP_CALLBACK_API
;;;691            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;692    #endif
;;;693            /* Call the accept function. */
;;;694            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;695            if (err != ERR_OK) {
;;;696              /* If the accept function returns with an error, we abort
;;;697               * the connection. */
;;;698              /* Already aborted? */
;;;699              if (err != ERR_ABRT) {
;;;700                tcp_abort(pcb);
;;;701              }
;;;702              return ERR_ABRT;
;;;703            }
;;;704            old_cwnd = pcb->cwnd;
;;;705            /* If there was any data contained within this ACK,
;;;706             * we'd better pass it on to the application as well. */
;;;707            tcp_receive(pcb);
;;;708    
;;;709            /* Prevent ACK for SYN to generate a sent event */
;;;710            if (pcb->acked != 0) {
;;;711              pcb->acked--;
;;;712            }
;;;713    
;;;714            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;715    
;;;716            if (recv_flags & TF_GOT_FIN) {
;;;717              tcp_ack_now(pcb);
;;;718              pcb->state = CLOSE_WAIT;
;;;719            }
;;;720          } else {
;;;721            /* incorrect ACK number, send RST */
;;;722            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;723                    tcphdr->dest, tcphdr->src);
;;;724          }
;;;725        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;726          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;727          tcp_rexmit(pcb);
;;;728        }
;;;729        break;
;;;730      case CLOSE_WAIT:
;;;731        /* FALLTHROUGH */
;;;732      case ESTABLISHED:
;;;733        tcp_receive(pcb);
;;;734        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;735          tcp_ack_now(pcb);
;;;736          pcb->state = CLOSE_WAIT;
;;;737        }
;;;738        break;
;;;739      case FIN_WAIT_1:
;;;740        tcp_receive(pcb);
;;;741        if (recv_flags & TF_GOT_FIN) {
;;;742          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;743            LWIP_DEBUGF(TCP_DEBUG,
;;;744              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;745            tcp_ack_now(pcb);
;;;746            tcp_pcb_purge(pcb);
;;;747            TCP_RMV_ACTIVE(pcb);
;;;748            pcb->state = TIME_WAIT;
;;;749            TCP_REG(&tcp_tw_pcbs, pcb);
;;;750          } else {
;;;751            tcp_ack_now(pcb);
;;;752            pcb->state = CLOSING;
;;;753          }
;;;754        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;755          pcb->state = FIN_WAIT_2;
;;;756        }
;;;757        break;
;;;758      case FIN_WAIT_2:
;;;759        tcp_receive(pcb);
;;;760        if (recv_flags & TF_GOT_FIN) {
;;;761          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;762          tcp_ack_now(pcb);
;;;763          tcp_pcb_purge(pcb);
;;;764          TCP_RMV_ACTIVE(pcb);
;;;765          pcb->state = TIME_WAIT;
;;;766          TCP_REG(&tcp_tw_pcbs, pcb);
;;;767        }
;;;768        break;
;;;769      case CLOSING:
;;;770        tcp_receive(pcb);
;;;771        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;772          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;773          tcp_pcb_purge(pcb);
;;;774          TCP_RMV_ACTIVE(pcb);
;;;775          pcb->state = TIME_WAIT;
;;;776          TCP_REG(&tcp_tw_pcbs, pcb);
;;;777        }
;;;778        break;
;;;779      case LAST_ACK:
;;;780        tcp_receive(pcb);
;;;781        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;782          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;783          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;784          recv_flags |= TF_CLOSED;
;;;785        }
;;;786        break;
;;;787      default:
;;;788        break;
;;;789      }
;;;790      return ERR_OK;
;;;791    }
00004a  e8bd9ffc          POP      {r2-r12,pc}
                  |L5.78|
00004e  a0bc              ADR      r0,|L5.832|
000050  f7fffffe          BL       __2printf
                  |L5.84|
000054  e7fe              B        |L5.84|
                  |L5.86|
000056  0780              LSLS     r0,r0,#30             ;612
000058  d509              BPL      |L5.110|
00005a  7e20              LDRB     r0,[r4,#0x18]         ;612
00005c  2802              CMP      r0,#2                 ;612
00005e  d006              BEQ      |L5.110|
000060  2803              CMP      r0,#3                 ;612
000062  d004              BEQ      |L5.110|
                  |L5.100|
000064  7fa0              LDRB     r0,[r4,#0x1e]         ;614
000066  f0400002          ORR      r0,r0,#2              ;614
00006a  77a0              STRB     r0,[r4,#0x1e]         ;614
                  |L5.108|
00006c  e164              B        |L5.824|
                  |L5.110|
00006e  7fa0              LDRB     r0,[r4,#0x1e]         ;618
000070  06c0              LSLS     r0,r0,#27             ;618
000072  d402              BMI      |L5.122|
000074  48ba              LDR      r0,|L5.864|
000076  6800              LDR      r0,[r0,#0]            ;620  ; tcp_ticks
000078  6260              STR      r0,[r4,#0x24]         ;620
                  |L5.122|
00007a  2000              MOVS     r0,#0                 ;622
00007c  f8840096          STRB     r0,[r4,#0x96]         ;622
000080  4620              MOV      r0,r4                 ;624
000082  f7fffffe          BL       tcp_parseopt
000086  7e20              LDRB     r0,[r4,#0x18]         ;627
000088  f8dfa2d8          LDR      r10,|L5.868|
00008c  f8df82d8          LDR      r8,|L5.872|
000090  4fb6              LDR      r7,|L5.876|
000092  4db7              LDR      r5,|L5.880|
000094  1e80              SUBS     r0,r0,#2              ;747
000096  f04f0901          MOV      r9,#1                 ;588
00009a  f04f0b0a          MOV      r11,#0xa              ;748
00009e  2808              CMP      r0,#8                 ;627
0000a0  d2e4              BCS      |L5.108|
0000a2  e8dff000          TBB      [pc,r0]               ;627
0000a6  0473              DCB      0x04,0x73
0000a8  c6caf1c6          DCB      0xc6,0xca,0xf1,0xc6
0000ac  f0ef              DCB      0xf0,0xef
0000ae  7830              LDRB     r0,[r6,#0]            ;632  ; flags
0000b0  06c1              LSLS     r1,r0,#27             ;632
                  |L5.178|
0000b2  d5db              BPL      |L5.108|
0000b4  0780              LSLS     r0,r0,#30             ;632
0000b6  d55d              BPL      |L5.372|
0000b8  6f20              LDR      r0,[r4,#0x70]         ;633
0000ba  6900              LDR      r0,[r0,#0x10]         ;633
0000bc  6840              LDR      r0,[r0,#4]            ;633
0000be  f7fffffe          BL       lwip_ntohl
0000c2  6931              LDR      r1,[r6,#0x10]         ;633  ; ackno
0000c4  1c40              ADDS     r0,r0,#1              ;633
0000c6  4288              CMP      r0,r1                 ;633
0000c8  d151              BNE      |L5.366|
0000ca  f8340f66          LDRH     r0,[r4,#0x66]!        ;634
0000ce  1c40              ADDS     r0,r0,#1              ;634
0000d0  f824093e          STRH     r0,[r4],#-0x3e        ;634
0000d4  68f0              LDR      r0,[r6,#0xc]          ;635  ; seqno
0000d6  4602              MOV      r2,r0                 ;635
0000d8  1c40              ADDS     r0,r0,#1              ;635
0000da  6020              STR      r0,[r4,#0]            ;636
0000dc  6221              STR      r1,[r4,#0x20]         ;638
0000de  60a0              STR      r0,[r4,#8]            ;638
0000e0  6870              LDR      r0,[r6,#4]            ;638  ; tcphdr
0000e2  1e52              SUBS     r2,r2,#1              ;639
0000e4  89c1              LDRH     r1,[r0,#0xe]          ;638
0000e6  8721              STRH     r1,[r4,#0x38]         ;638
0000e8  89c0              LDRH     r0,[r0,#0xe]          ;639
0000ea  8760              STRH     r0,[r4,#0x3a]         ;639
0000ec  2004              MOVS     r0,#4                 ;641
0000ee  62e2              STR      r2,[r4,#0x2c]         ;641
0000f0  f8040c10          STRB     r0,[r4,#-0x10]        ;641
0000f4  f8340f0e          LDRH     r0,[r4,#0xe]!         ;644
0000f8  f1a40132          SUB      r1,r4,#0x32           ;644
0000fc  3c36              SUBS     r4,r4,#0x36           ;644
0000fe  f7fffffe          BL       tcp_eff_send_mss
000102  eb000180          ADD      r1,r0,r0,LSL #2       ;649
000106  f64f72ff          MOV      r2,#0xffff            ;649
00010a  86e0              STRH     r0,[r4,#0x36]         ;644
00010c  ea020141          AND      r1,r2,r1,LSL #1       ;649
000110  f8a4104e          STRH     r1,[r4,#0x4e]         ;649
000114  f8b4104c          LDRH     r1,[r4,#0x4c]         ;651
000118  2901              CMP      r1,#1                 ;651
00011a  d100              BNE      |L5.286|
00011c  0040              LSLS     r0,r0,#1              ;651
                  |L5.286|
00011e  f8a4004c          STRH     r0,[r4,#0x4c]         ;651
000122  f8b40068          LDRH     r0,[r4,#0x68]         ;652
000126  b1c0              CBZ      r0,|L5.346|
000128  1e40              SUBS     r0,r0,#1              ;652
00012a  f8a40068          STRH     r0,[r4,#0x68]         ;653
00012e  6f20              LDR      r0,[r4,#0x70]         ;656
000130  6801              LDR      r1,[r0,#0]            ;656
000132  6721              STR      r1,[r4,#0x70]         ;657
000134  f7fffffe          BL       tcp_seg_free
000138  6f20              LDR      r0,[r4,#0x70]         ;661
00013a  b190              CBZ      r0,|L5.354|
00013c  2000              MOVS     r0,#0                 ;664
00013e  86a0              STRH     r0,[r4,#0x34]         ;664
000140  f8840046          STRB     r0,[r4,#0x46]         ;665
                  |L5.324|
000144  f8d43084          LDR      r3,[r4,#0x84]         ;670
000148  b17b              CBZ      r3,|L5.362|
00014a  2200              MOVS     r2,#0                 ;670
00014c  4621              MOV      r1,r4                 ;670
00014e  6920              LDR      r0,[r4,#0x10]         ;670
000150  4798              BLX      r3                    ;670
000152  9000              STR      r0,[sp,#0]            ;670
                  |L5.340|
000154  300a              ADDS     r0,r0,#0xa            ;670
000156  d033              BEQ      |L5.448|
000158  e784              B        |L5.100|
                  |L5.346|
00015a  a086              ADR      r0,|L5.884|
00015c  f7fffffe          BL       __2printf
                  |L5.352|
000160  e7fe              B        |L5.352|
                  |L5.354|
000162  f04f30ff          MOV      r0,#0xffffffff        ;662
000166  86a0              STRH     r0,[r4,#0x34]         ;662
000168  e7ec              B        |L5.324|
                  |L5.362|
00016a  9800              LDR      r0,[sp,#0]            ;670
00016c  e7f2              B        |L5.340|
                  |L5.366|
00016e  7830              LDRB     r0,[r6,#0]            ;677  ; flags
000170  06c0              LSLS     r0,r0,#27             ;677
000172  d59e              BPL      |L5.178|
                  |L5.372|
000174  6870              LDR      r0,[r6,#4]            ;679  ; tcphdr
000176  4b85              LDR      r3,|L5.908|
000178  4a85              LDR      r2,|L5.912|
00017a  8801              LDRH     r1,[r0,#0]            ;679
00017c  8840              LDRH     r0,[r0,#2]            ;679
00017e  e9cd0100          STRD     r0,r1,[sp,#0]         ;679
000182  8871              LDRH     r1,[r6,#2]            ;679  ; tcplen
000184  68f0              LDR      r0,[r6,#0xc]          ;679  ; seqno
000186  4401              ADD      r1,r1,r0              ;679
000188  6930              LDR      r0,[r6,#0x10]         ;679  ; ackno
00018a  e044              B        |L5.534|
00018c  7830              LDRB     r0,[r6,#0]            ;684  ; flags
00018e  06c1              LSLS     r1,r0,#27             ;684
000190  d544              BPL      |L5.540|
000192  6ca1              LDR      r1,[r4,#0x48]         ;686
000194  6930              LDR      r0,[r6,#0x10]         ;686  ; ackno
000196  1a41              SUBS     r1,r0,r1              ;686
000198  2901              CMP      r1,#1                 ;686
00019a  d432              BMI      |L5.514|
00019c  6d21              LDR      r1,[r4,#0x50]         ;686
00019e  1a41              SUBS     r1,r0,r1              ;686
0001a0  2900              CMP      r1,#0                 ;686
0001a2  dc2e              BGT      |L5.514|
0001a4  2004              MOVS     r0,#4                 ;688
0001a6  7620              STRB     r0,[r4,#0x18]         ;688
0001a8  6963              LDR      r3,[r4,#0x14]         ;691
0001aa  b163              CBZ      r3,|L5.454|
0001ac  2200              MOVS     r2,#0                 ;694
0001ae  4621              MOV      r1,r4                 ;694
0001b0  6920              LDR      r0,[r4,#0x10]         ;694
0001b2  4798              BLX      r3                    ;694
0001b4  b158              CBZ      r0,|L5.462|
0001b6  300a              ADDS     r0,r0,#0xa            ;694
0001b8  d002              BEQ      |L5.448|
0001ba  4620              MOV      r0,r4                 ;700
0001bc  f7fffffe          BL       tcp_abort
                  |L5.448|
0001c0  f06f0009          MVN      r0,#9                 ;702
0001c4  e741              B        |L5.74|
                  |L5.454|
0001c6  a073              ADR      r0,|L5.916|
0001c8  f7fffffe          BL       __2printf
                  |L5.460|
0001cc  e7fe              B        |L5.460|
                  |L5.462|
0001ce  f8b4504c          LDRH     r5,[r4,#0x4c]         ;704
0001d2  4620              MOV      r0,r4                 ;707
0001d4  f7fffffe          BL       tcp_receive
0001d8  f8b40064          LDRH     r0,[r4,#0x64]         ;710
0001dc  b110              CBZ      r0,|L5.484|
0001de  1e40              SUBS     r0,r0,#1              ;710
0001e0  f8a40064          STRH     r0,[r4,#0x64]         ;711
                  |L5.484|
0001e4  8ee0              LDRH     r0,[r4,#0x36]         ;714
0001e6  2d01              CMP      r5,#1                 ;714
0001e8  d100              BNE      |L5.492|
0001ea  0040              LSLS     r0,r0,#1              ;714
                  |L5.492|
0001ec  f8a4004c          STRH     r0,[r4,#0x4c]         ;714
                  |L5.496|
0001f0  7870              LDRB     r0,[r6,#1]            ;716  ; recv_flags
0001f2  0680              LSLS     r0,r0,#26             ;716
0001f4  d511              BPL      |L5.538|
0001f6  7fa0              LDRB     r0,[r4,#0x1e]         ;735
0001f8  f0400002          ORR      r0,r0,#2              ;735
0001fc  77a0              STRB     r0,[r4,#0x1e]         ;735
0001fe  2007              MOVS     r0,#7                 ;736
000200  e050              B        |L5.676|
                  |L5.514|
000202  6871              LDR      r1,[r6,#4]            ;722  ; tcphdr
000204  4b61              LDR      r3,|L5.908|
000206  880a              LDRH     r2,[r1,#0]            ;722
000208  8849              LDRH     r1,[r1,#2]            ;722
00020a  e9cd1200          STRD     r1,r2,[sp,#0]         ;722
00020e  8872              LDRH     r2,[r6,#2]            ;722  ; tcplen
000210  68f1              LDR      r1,[r6,#0xc]          ;722  ; seqno
000212  4411              ADD      r1,r1,r2              ;722
000214  4a5e              LDR      r2,|L5.912|
                  |L5.534|
000216  f7fffffe          BL       tcp_rst
                  |L5.538|
00021a  e08d              B        |L5.824|
                  |L5.540|
00021c  0780              LSLS     r0,r0,#30             ;725
00021e  d507              BPL      |L5.560|
000220  6aa0              LDR      r0,[r4,#0x28]         ;725
000222  68f1              LDR      r1,[r6,#0xc]          ;725  ; seqno
000224  1e40              SUBS     r0,r0,#1              ;725
000226  4288              CMP      r0,r1                 ;725
000228  d102              BNE      |L5.560|
00022a  4620              MOV      r0,r4                 ;727
00022c  f7fffffe          BL       tcp_rexmit
                  |L5.560|
000230  e082              B        |L5.824|
000232  4620              MOV      r0,r4                 ;733
000234  f7fffffe          BL       tcp_receive
000238  e7da              B        |L5.496|
00023a  4620              MOV      r0,r4                 ;740
00023c  f7fffffe          BL       tcp_receive
000240  7870              LDRB     r0,[r6,#1]            ;741  ; recv_flags
000242  0680              LSLS     r0,r0,#26             ;741
000244  7830              LDRB     r0,[r6,#0]            ;754  ; flags
000246  ea4f60c0          LSL      r0,r0,#27             ;754
00024a  d524              BPL      |L5.662|
00024c  2800              CMP      r0,#0                 ;742
00024e  da1c              BGE      |L5.650|
000250  6d20              LDR      r0,[r4,#0x50]         ;742
000252  6931              LDR      r1,[r6,#0x10]         ;742  ; ackno
000254  4288              CMP      r0,r1                 ;742
000256  d118              BNE      |L5.650|
000258  7fa0              LDRB     r0,[r4,#0x1e]         ;745
00025a  f0400002          ORR      r0,r0,#2              ;745
00025e  77a0              STRB     r0,[r4,#0x1e]         ;745
000260  4620              MOV      r0,r4                 ;746
000262  f7fffffe          BL       tcp_pcb_purge
000266  6838              LDR      r0,[r7,#0]            ;747  ; tcp_active_pcbs
000268  42a0              CMP      r0,r4                 ;747
00026a  d102              BNE      |L5.626|
                  |L5.620|
00026c  68c0              LDR      r0,[r0,#0xc]          ;747
00026e  6038              STR      r0,[r7,#0]            ;747  ; tcp_active_pcbs
000270  e048              B        |L5.772|
                  |L5.626|
000272  6028              STR      r0,[r5,#0]            ;747  ; tcp_tmp_pcb
000274  b3f0              CBZ      r0,|L5.756|
000276  68c0              LDR      r0,[r0,#0xc]          ;747
000278  42a0              CMP      r0,r4                 ;747
00027a  d1fa              BNE      |L5.626|
                  |L5.636|
00027c  6829              LDR      r1,[r5,#0]            ;747  ; tcp_tmp_pcb
00027e  68e0              LDR      r0,[r4,#0xc]          ;747
000280  60c8              STR      r0,[r1,#0xc]          ;747
000282  e03f              B        |L5.772|
000284  e04a              B        |L5.796|
000286  e025              B        |L5.724|
000288  e00e              B        |L5.680|
                  |L5.650|
00028a  7fa0              LDRB     r0,[r4,#0x1e]         ;751
00028c  f0400002          ORR      r0,r0,#2              ;751
000290  77a0              STRB     r0,[r4,#0x1e]         ;751
000292  2008              MOVS     r0,#8                 ;752
000294  e006              B        |L5.676|
                  |L5.662|
000296  2800              CMP      r0,#0                 ;754
000298  da4e              BGE      |L5.824|
00029a  6d20              LDR      r0,[r4,#0x50]         ;754
00029c  6931              LDR      r1,[r6,#0x10]         ;754  ; ackno
00029e  4288              CMP      r0,r1                 ;754
0002a0  d14a              BNE      |L5.824|
0002a2  2006              MOVS     r0,#6                 ;755
                  |L5.676|
0002a4  7620              STRB     r0,[r4,#0x18]         ;718
0002a6  e047              B        |L5.824|
                  |L5.680|
0002a8  4620              MOV      r0,r4                 ;759
0002aa  f7fffffe          BL       tcp_receive
0002ae  7870              LDRB     r0,[r6,#1]            ;760  ; recv_flags
0002b0  0680              LSLS     r0,r0,#26             ;760
0002b2  d541              BPL      |L5.824|
0002b4  7fa0              LDRB     r0,[r4,#0x1e]         ;762
0002b6  f0400002          ORR      r0,r0,#2              ;762
0002ba  77a0              STRB     r0,[r4,#0x1e]         ;762
0002bc  4620              MOV      r0,r4                 ;763
0002be  f7fffffe          BL       tcp_pcb_purge
0002c2  6838              LDR      r0,[r7,#0]            ;764  ; tcp_active_pcbs
0002c4  42a0              CMP      r0,r4                 ;764
0002c6  d0d1              BEQ      |L5.620|
                  |L5.712|
0002c8  6028              STR      r0,[r5,#0]            ;764  ; tcp_tmp_pcb
0002ca  b198              CBZ      r0,|L5.756|
0002cc  68c0              LDR      r0,[r0,#0xc]          ;764
0002ce  42a0              CMP      r0,r4                 ;764
0002d0  d1fa              BNE      |L5.712|
0002d2  e7d3              B        |L5.636|
                  |L5.724|
0002d4  4620              MOV      r0,r4                 ;770
0002d6  f7fffffe          BL       tcp_receive
0002da  7830              LDRB     r0,[r6,#0]            ;771  ; flags
0002dc  06c0              LSLS     r0,r0,#27             ;771
0002de  d52b              BPL      |L5.824|
0002e0  6d20              LDR      r0,[r4,#0x50]         ;771
0002e2  6931              LDR      r1,[r6,#0x10]         ;771  ; ackno
0002e4  4288              CMP      r0,r1                 ;771
0002e6  d127              BNE      |L5.824|
0002e8  4620              MOV      r0,r4                 ;773
0002ea  f7fffffe          BL       tcp_pcb_purge
0002ee  6838              LDR      r0,[r7,#0]            ;774  ; tcp_active_pcbs
0002f0  42a0              CMP      r0,r4                 ;774
0002f2  e000              B        |L5.758|
                  |L5.756|
0002f4  e006              B        |L5.772|
                  |L5.758|
0002f6  d0b9              BEQ      |L5.620|
                  |L5.760|
0002f8  6028              STR      r0,[r5,#0]            ;774  ; tcp_tmp_pcb
0002fa  b118              CBZ      r0,|L5.772|
0002fc  68c0              LDR      r0,[r0,#0xc]          ;774
0002fe  42a0              CMP      r0,r4                 ;774
000300  d1fa              BNE      |L5.760|
000302  e7bb              B        |L5.636|
                  |L5.772|
000304  f88a9000          STRB     r9,[r10,#0]           ;774
000308  f884b018          STRB     r11,[r4,#0x18]        ;775
00030c  f8d81000          LDR      r1,[r8,#0]            ;776  ; tcp_tw_pcbs
000310  60e1              STR      r1,[r4,#0xc]          ;776
000312  f8c84000          STR      r4,[r8,#0]            ;776  ; tcp_tw_pcbs
000316  f7fffffe          BL       tcp_timer_needed
00031a  e00d              B        |L5.824|
                  |L5.796|
00031c  4620              MOV      r0,r4                 ;780
00031e  f7fffffe          BL       tcp_receive
000322  7830              LDRB     r0,[r6,#0]            ;781  ; flags
000324  06c0              LSLS     r0,r0,#27             ;781
000326  d507              BPL      |L5.824|
000328  6d20              LDR      r0,[r4,#0x50]         ;781
00032a  6931              LDR      r1,[r6,#0x10]         ;781  ; ackno
00032c  4288              CMP      r0,r1                 ;781
00032e  d103              BNE      |L5.824|
000330  7870              LDRB     r0,[r6,#1]            ;784  ; recv_flags
000332  f0400010          ORR      r0,r0,#0x10           ;784
000336  7070              STRB     r0,[r6,#1]            ;784
                  |L5.824|
000338  2000              MOVS     r0,#0                 ;790
00033a  e686              B        |L5.74|
;;;792    
                          ENDP

                  |L5.828|
                          DCD      ||.data||
                  |L5.832|
000340  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
000344  696e7075
000348  743a2070
00034c  63622d3e
000350  73746174
000354  6520213d
000358  20434c4f
00035c  53454400
                  |L5.864|
                          DCD      tcp_ticks
                  |L5.868|
                          DCD      tcp_active_pcbs_changed
                  |L5.872|
                          DCD      tcp_tw_pcbs
                  |L5.876|
                          DCD      tcp_active_pcbs
                  |L5.880|
                          DCD      tcp_tmp_pcb
                  |L5.884|
000374  7063622d          DCB      "pcb->snd_queuelen > 0",0
000378  3e736e64
00037c  5f717565
000380  75656c65
000384  6e203e20
000388  3000    
00038a  00                DCB      0
00038b  00                DCB      0
                  |L5.908|
                          DCD      current_iphdr_src
                  |L5.912|
                          DCD      current_iphdr_dest
                  |L5.916|
000394  7063622d          DCB      "pcb->accept != NULL",0
000398  3e616363
00039c  65707420
0003a0  213d204e
0003a4  554c4c00

                          AREA ||i.tcp_receive||, CODE, READONLY, ALIGN=2

                  tcp_receive PROC
;;;846    static void
;;;847    tcp_receive(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;848    {
000004  4604              MOV      r4,r0
;;;849      struct tcp_seg *next;
;;;850    #if TCP_QUEUE_OOSEQ
;;;851      struct tcp_seg *prev, *cseg;
;;;852    #endif /* TCP_QUEUE_OOSEQ */
;;;853      struct pbuf *p;
;;;854      s32_t off;
;;;855      s16_t m;
;;;856      u32_t right_wnd_edge;
;;;857      u16_t new_tot_len;
;;;858      int found_dupack = 0;
;;;859    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;860      u32_t ooseq_blen;
;;;861      u16_t ooseq_qlen;
;;;862    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;863    
;;;864      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
000006  7e00              LDRB     r0,[r0,#0x18]
000008  2804              CMP      r0,#4
00000a  d203              BCS      |L6.20|
00000c  a0f9              ADR      r0,|L6.1012|
00000e  f7fffffe          BL       __2printf
                  |L6.18|
000012  e7fe              B        |L6.18|
                  |L6.20|
;;;865    
;;;866      if (flags & TCP_ACK) {
000014  4ffe              LDR      r7,|L6.1040|
000016  f04f0600          MOV      r6,#0
00001a  7838              LDRB     r0,[r7,#0]  ; flags
00001c  06c0              LSLS     r0,r0,#27
00001e  d57d              BPL      |L6.284|
000020  4639              MOV      r1,r7
;;;867        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
000022  f8b4c060          LDRH     r12,[r4,#0x60]
000026  6da3              LDR      r3,[r4,#0x58]
;;;868    
;;;869        /* Update window. */
;;;870        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
000028  6d65              LDR      r5,[r4,#0x54]
00002a  68fa              LDR      r2,[r7,#0xc]  ; seqno
;;;871           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
;;;872           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
00002c  6908              LDR      r0,[r1,#0x10]
00002e  6849              LDR      r1,[r1,#4]
000030  eb0c0903          ADD      r9,r12,r3             ;867
000034  ebb50802          SUBS     r8,r5,r2              ;870
000038  d408              BMI      |L6.76|
00003a  4295              CMP      r5,r2                 ;871
00003c  d101              BNE      |L6.66|
00003e  1a1d              SUBS     r5,r3,r0              ;871
000040  d404              BMI      |L6.76|
                  |L6.66|
000042  4283              CMP      r3,r0
000044  d114              BNE      |L6.112|
000046  89cb              LDRH     r3,[r1,#0xe]
000048  4563              CMP      r3,r12
00004a  d911              BLS      |L6.112|
                  |L6.76|
;;;873          pcb->snd_wnd = tcphdr->wnd;
00004c  89cb              LDRH     r3,[r1,#0xe]
00004e  f8a43060          STRH     r3,[r4,#0x60]
;;;874          /* keep track of the biggest window announced by the remote host to calculate
;;;875             the maximum segment size */
;;;876          if (pcb->snd_wnd_max < tcphdr->wnd) {
000052  f8b45062          LDRH     r5,[r4,#0x62]
000056  89c9              LDRH     r1,[r1,#0xe]
000058  428d              CMP      r5,r1
00005a  d201              BCS      |L6.96|
;;;877            pcb->snd_wnd_max = tcphdr->wnd;
00005c  f8a41062          STRH     r1,[r4,#0x62]
                  |L6.96|
000060  e9c42015          STRD     r2,r0,[r4,#0x54]
;;;878          }
;;;879          pcb->snd_wl1 = seqno;
;;;880          pcb->snd_wl2 = ackno;
;;;881          if (pcb->snd_wnd == 0) {
;;;882            if (pcb->persist_backoff == 0) {
;;;883              /* start persist timer */
;;;884              pcb->persist_cnt = 0;
;;;885              pcb->persist_backoff = 1;
;;;886            }
;;;887          } else if (pcb->persist_backoff > 0) {
000064  f8941095          LDRB     r1,[r4,#0x95]
000068  b15b              CBZ      r3,|L6.130|
00006a  b109              CBZ      r1,|L6.112|
;;;888            /* stop persist timer */
;;;889              pcb->persist_backoff = 0;
00006c  f8846095          STRB     r6,[r4,#0x95]
                  |L6.112|
;;;890          }
;;;891          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
;;;892    #if TCP_WND_DEBUG
;;;893        } else {
;;;894          if (pcb->snd_wnd != tcphdr->wnd) {
;;;895            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;896                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;897                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;898                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;899          }
;;;900    #endif /* TCP_WND_DEBUG */
;;;901        }
;;;902    
;;;903        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;904         * duplicate ack if:
;;;905         * 1) It doesn't ACK new data 
;;;906         * 2) length of received packet is zero (i.e. no payload) 
;;;907         * 3) the advertised window hasn't changed 
;;;908         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;909         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;910         * 
;;;911         * If it passes all five, should process as a dupack: 
;;;912         * a) dupacks < 3: do nothing 
;;;913         * b) dupacks == 3: fast retransmit 
;;;914         * c) dupacks > 3: increase cwnd 
;;;915         * 
;;;916         * If it only passes 1-3, should reset dupack counter (and add to
;;;917         * stats, which we don't do in lwIP)
;;;918         *
;;;919         * If it only passes 1, should reset dupack counter
;;;920         *
;;;921         */
;;;922    
;;;923        /* Clause 1 */
;;;924        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
000070  6ca2              LDR      r2,[r4,#0x48]
000072  1a81              SUBS     r1,r0,r2
000074  2900              CMP      r1,#0
000076  dc36              BGT      |L6.230|
;;;925          pcb->acked = 0;
000078  f8a46064          STRH     r6,[r4,#0x64]
;;;926          /* Clause 2 */
;;;927          if (tcplen == 0) {
00007c  8879              LDRH     r1,[r7,#2]  ; tcplen
00007e  b141              CBZ      r1,|L6.146|
000080  e02e              B        |L6.224|
                  |L6.130|
000082  2900              CMP      r1,#0                 ;882
000084  d1f4              BNE      |L6.112|
000086  f8846094          STRB     r6,[r4,#0x94]         ;884
00008a  2101              MOVS     r1,#1                 ;885
00008c  f8841095          STRB     r1,[r4,#0x95]         ;885
000090  e7ee              B        |L6.112|
                  |L6.146|
;;;928            /* Clause 3 */
;;;929            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
000092  f8b43060          LDRH     r3,[r4,#0x60]
000096  6da1              LDR      r1,[r4,#0x58]
000098  440b              ADD      r3,r3,r1
00009a  454b              CMP      r3,r9
00009c  d120              BNE      |L6.224|
;;;930              /* Clause 4 */
;;;931              if (pcb->rtime >= 0) {
00009e  f9b41034          LDRSH    r1,[r4,#0x34]
0000a2  2900              CMP      r1,#0
0000a4  db1c              BLT      |L6.224|
;;;932                /* Clause 5 */
;;;933                if (pcb->lastack == ackno) {
0000a6  4282              CMP      r2,r0
0000a8  d11a              BNE      |L6.224|
;;;934                  found_dupack = 1;
;;;935                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
0000aa  f8940047          LDRB     r0,[r4,#0x47]
0000ae  1c41              ADDS     r1,r0,#1
0000b0  b2c9              UXTB     r1,r1
0000b2  4281              CMP      r1,r0
0000b4  d901              BLS      |L6.186|
;;;936                    ++pcb->dupacks;
0000b6  f8841047          STRB     r1,[r4,#0x47]
                  |L6.186|
;;;937                  }
;;;938                  if (pcb->dupacks > 3) {
0000ba  f8940047          LDRB     r0,[r4,#0x47]
0000be  2803              CMP      r0,#3
0000c0  d909              BLS      |L6.214|
;;;939                    /* Inflate the congestion window, but not if it means that
;;;940                       the value overflows. */
;;;941                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0000c2  f8b4004c          LDRH     r0,[r4,#0x4c]
0000c6  8ee1              LDRH     r1,[r4,#0x36]
0000c8  4401              ADD      r1,r1,r0
0000ca  b289              UXTH     r1,r1
0000cc  4281              CMP      r1,r0
0000ce  d901              BLS      |L6.212|
;;;942                      pcb->cwnd += pcb->mss;
0000d0  f8a4104c          STRH     r1,[r4,#0x4c]
                  |L6.212|
0000d4  e0c4              B        |L6.608|
                  |L6.214|
;;;943                    }
;;;944                  } else if (pcb->dupacks == 3) {
0000d6  d1fd              BNE      |L6.212|
;;;945                    /* Do fast retransmit */
;;;946                    tcp_rexmit_fast(pcb);
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       tcp_rexmit_fast
0000de  e0bf              B        |L6.608|
                  |L6.224|
;;;947                  }
;;;948                }
;;;949              }
;;;950            }
;;;951          }
;;;952          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;953           * count of consecutive duplicate acks */
;;;954          if (!found_dupack) {
;;;955            pcb->dupacks = 0;
0000e0  f8846047          STRB     r6,[r4,#0x47]
0000e4  e0bc              B        |L6.608|
                  |L6.230|
;;;956          }
;;;957        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
0000e6  2901              CMP      r1,#1
0000e8  d47e              BMI      |L6.488|
0000ea  6d22              LDR      r2,[r4,#0x50]
0000ec  1a82              SUBS     r2,r0,r2
0000ee  2a00              CMP      r2,#0
0000f0  dc7a              BGT      |L6.488|
;;;958          /* We come here when the ACK acknowledges new data. */
;;;959    
;;;960          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;961             in fast retransmit. Also reset the congestion window to the
;;;962             slow start threshold. */
;;;963          if (pcb->flags & TF_INFR) {
0000f2  7fa2              LDRB     r2,[r4,#0x1e]
0000f4  0753              LSLS     r3,r2,#29
0000f6  d506              BPL      |L6.262|
;;;964            pcb->flags &= ~TF_INFR;
0000f8  f0220204          BIC      r2,r2,#4
0000fc  77a2              STRB     r2,[r4,#0x1e]
;;;965            pcb->cwnd = pcb->ssthresh;
0000fe  f8b4204e          LDRH     r2,[r4,#0x4e]
000102  f8a4204c          STRH     r2,[r4,#0x4c]
                  |L6.262|
;;;966          }
;;;967    
;;;968          /* Reset the number of retransmissions. */
;;;969          pcb->nrtx = 0;
000106  f8846046          STRB     r6,[r4,#0x46]
;;;970    
;;;971          /* Reset the retransmission time-out. */
;;;972          pcb->rto = (pcb->sa >> 3) + pcb->sv;
00010a  f8b42042          LDRH     r2,[r4,#0x42]
00010e  f9b43040          LDRSH    r3,[r4,#0x40]
000112  eb0202e3          ADD      r2,r2,r3,ASR #3
000116  f8a42044          STRH     r2,[r4,#0x44]
;;;973    
;;;974          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;975          pcb->acked = (u16_t)(ackno - pcb->lastack);
00011a  e000              B        |L6.286|
                  |L6.284|
00011c  e0dc              B        |L6.728|
                  |L6.286|
00011e  f8a41064          STRH     r1,[r4,#0x64]
;;;976    
;;;977          pcb->snd_buf += pcb->acked;
000122  f8b42066          LDRH     r2,[r4,#0x66]
000126  4411              ADD      r1,r1,r2
000128  f8a41066          STRH     r1,[r4,#0x66]
;;;978    
;;;979          /* Reset the fast retransmit variables. */
;;;980          pcb->dupacks = 0;
00012c  f8846047          STRB     r6,[r4,#0x47]
;;;981          pcb->lastack = ackno;
;;;982    
;;;983          /* Update the congestion control variables (cwnd and
;;;984             ssthresh). */
;;;985          if (pcb->state >= ESTABLISHED) {
;;;986            if (pcb->cwnd < pcb->ssthresh) {
000130  64a0              STR      r0,[r4,#0x48]
000132  f8b4004c          LDRH     r0,[r4,#0x4c]
000136  f8b4104e          LDRH     r1,[r4,#0x4e]
00013a  4288              CMP      r0,r1
;;;987              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
;;;988                pcb->cwnd += pcb->mss;
;;;989              }
;;;990              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
;;;991            } else {
;;;992              u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
00013c  8ee1              LDRH     r1,[r4,#0x36]
00013e  d204              BCS      |L6.330|
000140  4401              ADD      r1,r1,r0              ;987
000142  b289              UXTH     r1,r1                 ;987
000144  4281              CMP      r1,r0                 ;987
000146  d807              BHI      |L6.344|
000148  e039              B        |L6.446|
                  |L6.330|
00014a  4349              MULS     r1,r1,r1
00014c  fb91f1f0          SDIV     r1,r1,r0
000150  4401              ADD      r1,r1,r0
000152  b289              UXTH     r1,r1
;;;993              if (new_cwnd > pcb->cwnd) {
000154  4288              CMP      r0,r1
000156  d232              BCS      |L6.446|
                  |L6.344|
;;;994                pcb->cwnd = new_cwnd;
000158  f8a4104c          STRH     r1,[r4,#0x4c]
00015c  e02f              B        |L6.446|
                  |L6.350|
;;;995              }
;;;996              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
;;;997            }
;;;998          }
;;;999          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
;;;1000                                       ackno,
;;;1001                                       pcb->unacked != NULL?
;;;1002                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1003                                       pcb->unacked != NULL?
;;;1004                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1005   
;;;1006         /* Remove segment from the unacknowledged list if the incoming
;;;1007            ACK acknowlegdes them. */
;;;1008         while (pcb->unacked != NULL &&
;;;1009                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1010                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1011           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
;;;1012                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1013                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1014                                         TCP_TCPLEN(pcb->unacked)));
;;;1015   
;;;1016           next = pcb->unacked;
;;;1017           pcb->unacked = pcb->unacked->next;
00015e  6828              LDR      r0,[r5,#0]
;;;1018   
;;;1019           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1020           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000160  6720              STR      r0,[r4,#0x70]
000162  6868              LDR      r0,[r5,#4]
000164  f7fffffe          BL       pbuf_clen
000168  f8b41068          LDRH     r1,[r4,#0x68]
00016c  4288              CMP      r0,r1
00016e  d903              BLS      |L6.376|
000170  a0a8              ADR      r0,|L6.1044|
000172  f7fffffe          BL       __2printf
                  |L6.374|
000176  e7fe              B        |L6.374|
                  |L6.376|
;;;1021           /* Prevent ACK for FIN to generate a sent event */
;;;1022           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000178  f8b40064          LDRH     r0,[r4,#0x64]
00017c  b150              CBZ      r0,|L6.404|
00017e  6928              LDR      r0,[r5,#0x10]
000180  8980              LDRH     r0,[r0,#0xc]
000182  f7fffffe          BL       lwip_ntohs
000186  07c0              LSLS     r0,r0,#31
000188  d004              BEQ      |L6.404|
;;;1023             pcb->acked--;
00018a  f8b40064          LDRH     r0,[r4,#0x64]
00018e  1e40              SUBS     r0,r0,#1
000190  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.404|
;;;1024           }
;;;1025   
;;;1026           pcb->snd_queuelen -= pbuf_clen(next->p);
000194  6868              LDR      r0,[r5,#4]
000196  f7fffffe          BL       pbuf_clen
00019a  f8341f68          LDRH     r1,[r4,#0x68]!
00019e  1a08              SUBS     r0,r1,r0
0001a0  8020              STRH     r0,[r4,#0]
;;;1027           tcp_seg_free(next);
0001a2  4628              MOV      r0,r5
0001a4  f7fffffe          BL       tcp_seg_free
;;;1028   
;;;1029           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
;;;1030           if (pcb->snd_queuelen != 0) {
0001a8  f8340968          LDRH     r0,[r4],#-0x68
0001ac  b138              CBZ      r0,|L6.446|
;;;1031             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
0001ae  6f20              LDR      r0,[r4,#0x70]
0001b0  b938              CBNZ     r0,|L6.450|
0001b2  6ee0              LDR      r0,[r4,#0x6c]
0001b4  bb00              CBNZ     r0,|L6.504|
0001b6  a0a1              ADR      r0,|L6.1084|
0001b8  f7fffffe          BL       __2printf
                  |L6.444|
0001bc  e7fe              B        |L6.444|
                  |L6.446|
0001be  6f20              LDR      r0,[r4,#0x70]         ;1008
0001c0  b1d0              CBZ      r0,|L6.504|
                  |L6.450|
0001c2  6900              LDR      r0,[r0,#0x10]         ;1009
0001c4  6840              LDR      r0,[r0,#4]            ;1009
0001c6  f7fffffe          BL       lwip_ntohl
0001ca  4605              MOV      r5,r0                 ;1009
0001cc  6f20              LDR      r0,[r4,#0x70]         ;1009
0001ce  6900              LDR      r0,[r0,#0x10]         ;1009
0001d0  8980              LDRH     r0,[r0,#0xc]          ;1009
0001d2  f7fffffe          BL       lwip_ntohs
0001d6  0780              LSLS     r0,r0,#30             ;1009
0001d8  d000              BEQ      |L6.476|
0001da  2001              MOVS     r0,#1                 ;1009
                  |L6.476|
0001dc  4428              ADD      r0,r0,r5              ;1009
0001de  6f25              LDR      r5,[r4,#0x70]         ;1009
0001e0  8929              LDRH     r1,[r5,#8]            ;1009
0001e2  4408              ADD      r0,r0,r1              ;1009
0001e4  6939              LDR      r1,[r7,#0x10]         ;1009  ; ackno
0001e6  e000              B        |L6.490|
                  |L6.488|
0001e8  e00a              B        |L6.512|
                  |L6.490|
0001ea  1a40              SUBS     r0,r0,r1              ;1009
0001ec  2800              CMP      r0,#0                 ;1009
0001ee  ddb6              BLE      |L6.350|
;;;1032                         pcb->unsent != NULL);
;;;1033           }
;;;1034         }
;;;1035   
;;;1036         /* If there's nothing left to acknowledge, stop the retransmit
;;;1037            timer, otherwise reset it to start again */
;;;1038         if(pcb->unacked == NULL)
0001f0  b115              CBZ      r5,|L6.504|
;;;1039           pcb->rtime = -1;
;;;1040         else
;;;1041           pcb->rtime = 0;
0001f2  86a6              STRH     r6,[r4,#0x34]
                  |L6.500|
;;;1042   
;;;1043         pcb->polltmr = 0;
0001f4  77e6              STRB     r6,[r4,#0x1f]
0001f6  e033              B        |L6.608|
                  |L6.504|
0001f8  f04f30ff          MOV      r0,#0xffffffff        ;1039
0001fc  86a0              STRH     r0,[r4,#0x34]         ;1039
0001fe  e7f9              B        |L6.500|
                  |L6.512|
;;;1044       } else {
;;;1045         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1046         pcb->acked = 0;
000200  f8a46064          STRH     r6,[r4,#0x64]
000204  e02c              B        |L6.608|
                  |L6.518|
;;;1047       }
;;;1048   
;;;1049       /* We go through the ->unsent list to see if any of the segments
;;;1050          on the list are acknowledged by the ACK. This may seem
;;;1051          strange since an "unsent" segment shouldn't be acked. The
;;;1052          rationale is that lwIP puts all outstanding segments on the
;;;1053          ->unsent list after a retransmission, so these segments may
;;;1054          in fact have been sent once. */
;;;1055       while (pcb->unsent != NULL &&
;;;1056              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1057                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1058         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
;;;1059                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1060                                       TCP_TCPLEN(pcb->unsent)));
;;;1061   
;;;1062         next = pcb->unsent;
;;;1063         pcb->unsent = pcb->unsent->next;
000206  6828              LDR      r0,[r5,#0]
;;;1064   #if TCP_OVERSIZE
;;;1065         if (pcb->unsent == NULL) {
000208  66e0              STR      r0,[r4,#0x6c]
00020a  b908              CBNZ     r0,|L6.528|
;;;1066           pcb->unsent_oversize = 0;
00020c  f8a4606a          STRH     r6,[r4,#0x6a]
                  |L6.528|
;;;1067         }
;;;1068   #endif /* TCP_OVERSIZE */ 
;;;1069         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1070         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000210  6868              LDR      r0,[r5,#4]
000212  f7fffffe          BL       pbuf_clen
000216  f8b41068          LDRH     r1,[r4,#0x68]
00021a  4288              CMP      r0,r1
00021c  d903              BLS      |L6.550|
00021e  a07d              ADR      r0,|L6.1044|
000220  f7fffffe          BL       __2printf
                  |L6.548|
000224  e7fe              B        |L6.548|
                  |L6.550|
;;;1071         /* Prevent ACK for FIN to generate a sent event */
;;;1072         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000226  f8b40064          LDRH     r0,[r4,#0x64]
00022a  b150              CBZ      r0,|L6.578|
00022c  6928              LDR      r0,[r5,#0x10]
00022e  8980              LDRH     r0,[r0,#0xc]
000230  f7fffffe          BL       lwip_ntohs
000234  07c0              LSLS     r0,r0,#31
000236  d004              BEQ      |L6.578|
;;;1073           pcb->acked--;
000238  f8b40064          LDRH     r0,[r4,#0x64]
00023c  1e40              SUBS     r0,r0,#1
00023e  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.578|
;;;1074         }
;;;1075         pcb->snd_queuelen -= pbuf_clen(next->p);
000242  6868              LDR      r0,[r5,#4]
000244  f7fffffe          BL       pbuf_clen
000248  f8341f68          LDRH     r1,[r4,#0x68]!
00024c  1a08              SUBS     r0,r1,r0
00024e  8020              STRH     r0,[r4,#0]
;;;1076         tcp_seg_free(next);
000250  4628              MOV      r0,r5
000252  f7fffffe          BL       tcp_seg_free
;;;1077         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
;;;1078         if (pcb->snd_queuelen != 0) {
000256  f8340968          LDRH     r0,[r4],#-0x68
00025a  b108              CBZ      r0,|L6.608|
;;;1079           LWIP_ASSERT("tcp_receive: valid queue length",
00025c  6f20              LDR      r0,[r4,#0x70]
00025e  b3e8              CBZ      r0,|L6.732|
                  |L6.608|
000260  6ee0              LDR      r0,[r4,#0x6c]         ;1055
000262  b1b8              CBZ      r0,|L6.660|
                  |L6.612|
000264  6900              LDR      r0,[r0,#0x10]         ;1056
000266  6840              LDR      r0,[r0,#4]            ;1056
000268  f7fffffe          BL       lwip_ntohl
00026c  4605              MOV      r5,r0                 ;1056
00026e  6ee0              LDR      r0,[r4,#0x6c]         ;1056
000270  6900              LDR      r0,[r0,#0x10]         ;1056
000272  8980              LDRH     r0,[r0,#0xc]          ;1056
000274  f7fffffe          BL       lwip_ntohs
000278  0780              LSLS     r0,r0,#30             ;1056
00027a  d000              BEQ      |L6.638|
00027c  2001              MOVS     r0,#1                 ;1056
                  |L6.638|
00027e  4428              ADD      r0,r0,r5              ;1056
000280  6ee5              LDR      r5,[r4,#0x6c]         ;1056
000282  8929              LDRH     r1,[r5,#8]            ;1056
000284  4401              ADD      r1,r1,r0              ;1056
000286  6938              LDR      r0,[r7,#0x10]         ;1056  ; ackno
000288  1a41              SUBS     r1,r0,r1              ;1056
00028a  d403              BMI      |L6.660|
00028c  6d21              LDR      r1,[r4,#0x50]         ;1056
00028e  1a40              SUBS     r0,r0,r1              ;1056
000290  2800              CMP      r0,#0                 ;1056
000292  ddb8              BLE      |L6.518|
                  |L6.660|
;;;1080             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1081         }
;;;1082       }
;;;1083       /* End of ACK for new data processing. */
;;;1084   
;;;1085       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
;;;1086                                   pcb->rttest, pcb->rtseq, ackno));
;;;1087   
;;;1088       /* RTT estimation calculations. This is done by checking if the
;;;1089          incoming segment acknowledges the segment we use to take a
;;;1090          round-trip time measurement. */
;;;1091       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
000294  6ba0              LDR      r0,[r4,#0x38]
000296  b1f8              CBZ      r0,|L6.728|
000298  6be1              LDR      r1,[r4,#0x3c]
00029a  693a              LDR      r2,[r7,#0x10]  ; ackno
00029c  1a89              SUBS     r1,r1,r2
00029e  d51b              BPL      |L6.728|
;;;1092         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1093            and a round-trip shouldn't be that long... */
;;;1094         m = (s16_t)(tcp_ticks - pcb->rttest);
0002a0  496e              LDR      r1,|L6.1116|
0002a2  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
0002a4  1a08              SUBS     r0,r1,r0
;;;1095   
;;;1096         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
;;;1097                                     m, m * TCP_SLOW_INTERVAL));
;;;1098   
;;;1099         /* This is taken directly from VJs original code in his paper */
;;;1100         m = m - (pcb->sa >> 3);
0002a6  f9b41040          LDRSH    r1,[r4,#0x40]
0002aa  eba000e1          SUB      r0,r0,r1,ASR #3
0002ae  b200              SXTH     r0,r0
;;;1101         pcb->sa += m;
0002b0  4401              ADD      r1,r1,r0
0002b2  b209              SXTH     r1,r1
0002b4  f8a41040          STRH     r1,[r4,#0x40]
;;;1102         if (m < 0) {
0002b8  2800              CMP      r0,#0
0002ba  da01              BGE      |L6.704|
;;;1103           m = -m;
0002bc  4240              RSBS     r0,r0,#0
0002be  b200              SXTH     r0,r0
                  |L6.704|
;;;1104         }
;;;1105         m = m - (pcb->sv >> 2);
0002c0  f9b42042          LDRSH    r2,[r4,#0x42]
0002c4  eba000a2          SUB      r0,r0,r2,ASR #2
;;;1106         pcb->sv += m;
0002c8  4410              ADD      r0,r0,r2
0002ca  f8a40042          STRH     r0,[r4,#0x42]
;;;1107         pcb->rto = (pcb->sa >> 3) + pcb->sv;
0002ce  eb0000e1          ADD      r0,r0,r1,ASR #3
0002d2  f8a40044          STRH     r0,[r4,#0x44]
;;;1108   
;;;1109         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
;;;1110                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1111   
;;;1112         pcb->rttest = 0;
0002d6  63a6              STR      r6,[r4,#0x38]
                  |L6.728|
;;;1113       }
;;;1114     }
;;;1115   
;;;1116     /* If the incoming segment contains data, we must process it
;;;1117        further unless the pcb already received a FIN.
;;;1118        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1119        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1120     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
0002d8  887b              LDRH     r3,[r7,#2]  ; tcplen
0002da  e000              B        |L6.734|
                  |L6.732|
0002dc  e01c              B        |L6.792|
                  |L6.734|
0002de  2b00              CMP      r3,#0
0002e0  d07d              BEQ      |L6.990|
0002e2  7e20              LDRB     r0,[r4,#0x18]
0002e4  2807              CMP      r0,#7
0002e6  d27a              BCS      |L6.990|
;;;1121       /* This code basically does three things:
;;;1122   
;;;1123       +) If the incoming segment contains data that is the next
;;;1124       in-sequence data, this data is passed to the application. This
;;;1125       might involve trimming the first edge of the data. The rcv_nxt
;;;1126       variable and the advertised window are adjusted.
;;;1127   
;;;1128       +) If the incoming segment has data that is above the next
;;;1129       sequence number expected (->rcv_nxt), the segment is placed on
;;;1130       the ->ooseq queue. This is done by finding the appropriate
;;;1131       place in the ->ooseq queue (which is ordered by sequence
;;;1132       number) and trim the segment in both ends if needed. An
;;;1133       immediate ACK is sent to indicate that we received an
;;;1134       out-of-sequence segment.
;;;1135   
;;;1136       +) Finally, we check if the first segment on the ->ooseq queue
;;;1137       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1138       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1139       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1140       segments that are now on sequence are chained onto the
;;;1141       incoming segment so that we only need to call the application
;;;1142       once.
;;;1143       */
;;;1144   
;;;1145       /* First, we check if we must trim the first edge. We have to do
;;;1146          this if the sequence number of the incoming segment is less
;;;1147          than rcv_nxt, and the sequence number plus the length of the
;;;1148          segment is larger than rcv_nxt. */
;;;1149       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1150             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1151       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
0002e8  6aa1              LDR      r1,[r4,#0x28]
0002ea  68fa              LDR      r2,[r7,#0xc]  ; seqno
;;;1152         /* Trimming the first edge is done by pushing the payload
;;;1153            pointer in the pbuf downwards. This is somewhat tricky since
;;;1154            we do not want to discard the full contents of the pbuf up to
;;;1155            the new starting point of the data since we have to keep the
;;;1156            TCP header which is present in the first pbuf in the chain.
;;;1157   
;;;1158            What is done is really quite a nasty hack: the first pbuf in
;;;1159            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1160            able to deallocate the whole pbuf, we cannot change this
;;;1161            inseg.p pointer to point to any of the later pbufs in the
;;;1162            chain. Instead, we point the ->payload pointer in the first
;;;1163            pbuf to data in one of the later pbufs. We also set the
;;;1164            inseg.data pointer to point to the right place. This way, the
;;;1165            ->p pointer will still point to the first pbuf, but the
;;;1166            ->p->payload pointer will point to data in another pbuf.
;;;1167   
;;;1168            After we are done with adjusting the pbuf pointers we must
;;;1169            adjust the ->data pointer in the seg and the segment
;;;1170            length.*/
;;;1171   
;;;1172         off = pcb->rcv_nxt - seqno;
;;;1173         p = inseg.p;
0002ec  f8df8170          LDR      r8,|L6.1120|
0002f0  1a88              SUBS     r0,r1,r2              ;1151
0002f2  2801              CMP      r0,#1                 ;1151
0002f4  d450              BMI      |L6.920|
0002f6  4413              ADD      r3,r3,r2              ;1151
0002f8  1acb              SUBS     r3,r1,r3              ;1151
0002fa  1c5b              ADDS     r3,r3,#1              ;1151
0002fc  2b00              CMP      r3,#0                 ;1151
0002fe  dc4b              BGT      |L6.920|
;;;1174         LWIP_ASSERT("inseg.p != NULL", inseg.p);
000300  f8d82004          LDR      r2,[r8,#4]  ; inseg
000304  4645              MOV      r5,r8                 ;1173
000306  b172              CBZ      r2,|L6.806|
;;;1175         LWIP_ASSERT("insane offset!", (off < 0x7fff));
000308  f64771ff          MOV      r1,#0x7fff
00030c  4288              CMP      r0,r1
00030e  db0e              BLT      |L6.814|
000310  a054              ADR      r0,|L6.1124|
000312  f7fffffe          BL       __2printf
                  |L6.790|
000316  e7fe              B        |L6.790|
                  |L6.792|
000318  6ee0              LDR      r0,[r4,#0x6c]         ;1079
00031a  2800              CMP      r0,#0                 ;1079
00031c  d1a2              BNE      |L6.612|
00031e  a047              ADR      r0,|L6.1084|
000320  f7fffffe          BL       __2printf
                  |L6.804|
000324  e7fe              B        |L6.804|
                  |L6.806|
000326  a053              ADR      r0,|L6.1140|
000328  f7fffffe          BL       __2printf
                  |L6.812|
00032c  e7fe              B        |L6.812|
                  |L6.814|
;;;1176         if (inseg.p->len < off) {
00032e  8951              LDRH     r1,[r2,#0xa]
000330  4281              CMP      r1,r0
000332  da1a              BGE      |L6.874|
;;;1177           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
000334  8911              LDRH     r1,[r2,#8]
000336  4281              CMP      r1,r0
000338  da03              BGE      |L6.834|
00033a  a052              ADR      r0,|L6.1156|
00033c  f7fffffe          BL       __2printf
                  |L6.832|
000340  e7fe              B        |L6.832|
                  |L6.834|
;;;1178           new_tot_len = (u16_t)(inseg.p->tot_len - off);
000342  1a09              SUBS     r1,r1,r0
000344  b28b              UXTH     r3,r1
;;;1179           while (p->len < off) {
000346  e003              B        |L6.848|
                  |L6.840|
;;;1180             off -= p->len;
;;;1181             /* KJM following line changed (with addition of new_tot_len var)
;;;1182                to fix bug #9076
;;;1183                inseg.p->tot_len -= p->len; */
;;;1184             p->tot_len = new_tot_len;
000348  8113              STRH     r3,[r2,#8]
;;;1185             p->len = 0;
00034a  8156              STRH     r6,[r2,#0xa]
;;;1186             p = p->next;
00034c  6812              LDR      r2,[r2,#0]
00034e  1a40              SUBS     r0,r0,r1              ;1180
                  |L6.848|
000350  8951              LDRH     r1,[r2,#0xa]          ;1179
000352  4281              CMP      r1,r0                 ;1179
000354  dbf8              BLT      |L6.840|
;;;1187           }
;;;1188           if(pbuf_header(p, (s16_t)-off)) {
000356  4240              RSBS     r0,r0,#0
000358  b201              SXTH     r1,r0
00035a  4610              MOV      r0,r2
00035c  f7fffffe          BL       pbuf_header
000360  b168              CBZ      r0,|L6.894|
;;;1189             /* Do we need to cope with this failing?  Assert for now */
;;;1190             LWIP_ASSERT("pbuf_header failed", 0);
000362  a04c              ADR      r0,|L6.1172|
000364  f7fffffe          BL       __2printf
                  |L6.872|
000368  e7fe              B        |L6.872|
                  |L6.874|
;;;1191           }
;;;1192         } else {
;;;1193           if(pbuf_header(inseg.p, (s16_t)-off)) {
00036a  4240              RSBS     r0,r0,#0
00036c  b201              SXTH     r1,r0
00036e  4610              MOV      r0,r2
000370  f7fffffe          BL       pbuf_header
000374  b118              CBZ      r0,|L6.894|
;;;1194             /* Do we need to cope with this failing?  Assert for now */
;;;1195             LWIP_ASSERT("pbuf_header failed", 0);
000376  a047              ADR      r0,|L6.1172|
000378  f7fffffe          BL       __2printf
                  |L6.892|
00037c  e7fe              B        |L6.892|
                  |L6.894|
;;;1196           }
;;;1197         }
;;;1198         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
00037e  89ba              LDRH     r2,[r7,#0xc]  ; seqno
000380  6aa0              LDR      r0,[r4,#0x28]
000382  8929              LDRH     r1,[r5,#8]  ; inseg
000384  1a82              SUBS     r2,r0,r2
000386  1a89              SUBS     r1,r1,r2
000388  8129              STRH     r1,[r5,#8]
;;;1199         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
00038a  60f8              STR      r0,[r7,#0xc]  ; seqno
00038c  6929              LDR      r1,[r5,#0x10]  ; inseg
00038e  6048              STR      r0,[r1,#4]
;;;1200       }
;;;1201       else {
;;;1202         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1203           /* the whole segment is < rcv_nxt */
;;;1204           /* must be a duplicate of a packet that has already been correctly handled */
;;;1205   
;;;1206           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
;;;1207           tcp_ack_now(pcb);
;;;1208         }
;;;1209       }
;;;1210   
;;;1211       /* The sequence number must be within the window (above rcv_nxt
;;;1212          and below rcv_nxt + rcv_wnd) in order to be further
;;;1213          processed. */
;;;1214       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
000390  6aa1              LDR      r1,[r4,#0x28]
000392  1a40              SUBS     r0,r0,r1
000394  d507              BPL      |L6.934|
                  |L6.918|
000396  e26a              B        |L6.2158|
                  |L6.920|
000398  1a50              SUBS     r0,r2,r1              ;1202
00039a  d504              BPL      |L6.934|
00039c  7fa0              LDRB     r0,[r4,#0x1e]         ;1207
00039e  f0400002          ORR      r0,r0,#2              ;1207
0003a2  77a0              STRB     r0,[r4,#0x1e]         ;1207
0003a4  e263              B        |L6.2158|
                  |L6.934|
0003a6  8da0              LDRH     r0,[r4,#0x2c]
0003a8  180a              ADDS     r2,r1,r0
0003aa  68f8              LDR      r0,[r7,#0xc]  ; seqno
0003ac  1a82              SUBS     r2,r0,r2
0003ae  1c52              ADDS     r2,r2,#1
0003b0  2a00              CMP      r2,#0
0003b2  dcf0              BGT      |L6.918|
;;;1215                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1216         if (pcb->rcv_nxt == seqno) {
0003b4  4281              CMP      r1,r0
0003b6  d177              BNE      |L6.1192|
;;;1217           /* The incoming segment is the next in sequence. We check if
;;;1218              we have to trim the end of the segment and update rcv_nxt
;;;1219              and pass the data to the application. */
;;;1220           tcplen = TCP_TCPLEN(&inseg);
0003b8  f8d80010          LDR      r0,[r8,#0x10]  ; inseg
0003bc  4645              MOV      r5,r8
0003be  8980              LDRH     r0,[r0,#0xc]
0003c0  f7fffffe          BL       lwip_ntohs
0003c4  0780              LSLS     r0,r0,#30
0003c6  d000              BEQ      |L6.970|
0003c8  2001              MOVS     r0,#1
                  |L6.970|
0003ca  8929              LDRH     r1,[r5,#8]  ; inseg
0003cc  46a9              MOV      r9,r5
0003ce  4408              ADD      r0,r0,r1
0003d0  b280              UXTH     r0,r0
0003d2  8078              STRH     r0,[r7,#2]
;;;1221   
;;;1222           if (tcplen > pcb->rcv_wnd) {
0003d4  8da1              LDRH     r1,[r4,#0x2c]
0003d6  4281              CMP      r1,r0
0003d8  d267              BCS      |L6.1194|
;;;1223             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1224                         ("tcp_receive: other end overran receive window"
;;;1225                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1226                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1227             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0003da  464d              MOV      r5,r9
0003dc  e000              B        |L6.992|
                  |L6.990|
0003de  e24b              B        |L6.2168|
                  |L6.992|
0003e0  f8d90010          LDR      r0,[r9,#0x10]  ; inseg
0003e4  8980              LDRH     r0,[r0,#0xc]
0003e6  f7fffffe          BL       lwip_ntohs
0003ea  07c0              LSLS     r0,r0,#31
0003ec  d06b              BEQ      |L6.1222|
;;;1228               /* Must remove the FIN from the header as we're trimming 
;;;1229                * that byte of sequence-space from the packet */
;;;1230               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
0003ee  6928              LDR      r0,[r5,#0x10]  ; inseg
0003f0  8980              LDRH     r0,[r0,#0xc]
0003f2  e05b              B        |L6.1196|
                  |L6.1012|
0003f4  7463705f          DCB      "tcp_receive: wrong state",0
0003f8  72656365
0003fc  6976653a
000400  2077726f
000404  6e672073
000408  74617465
00040c  00      
00040d  00                DCB      0
00040e  00                DCB      0
00040f  00                DCB      0
                  |L6.1040|
                          DCD      ||.data||
                  |L6.1044|
000414  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
000418  3e736e64
00041c  5f717565
000420  75656c65
000424  6e203e3d
000428  20706275
00042c  665f636c
000430  656e286e
000434  6578742d
000438  3e702900
                  |L6.1084|
00043c  7463705f          DCB      "tcp_receive: valid queue length",0
000440  72656365
000444  6976653a
000448  2076616c
00044c  69642071
000450  75657565
000454  206c656e
000458  67746800
                  |L6.1116|
                          DCD      tcp_ticks
                  |L6.1120|
                          DCD      ||.bss||
                  |L6.1124|
000464  696e7361          DCB      "insane offset!",0
000468  6e65206f
00046c  66667365
000470  742100  
000473  00                DCB      0
                  |L6.1140|
000474  696e7365          DCB      "inseg.p != NULL",0
000478  672e7020
00047c  213d204e
000480  554c4c00
                  |L6.1156|
000484  70627566          DCB      "pbuf too short!",0
000488  20746f6f
00048c  2073686f
000490  72742100
                  |L6.1172|
000494  70627566          DCB      "pbuf_header failed",0
000498  5f686561
00049c  64657220
0004a0  6661696c
0004a4  656400  
0004a7  00                DCB      0
                  |L6.1192|
0004a8  e12c              B        |L6.1796|
                  |L6.1194|
0004aa  e031              B        |L6.1296|
                  |L6.1196|
0004ac  f7fffffe          BL       lwip_ntohs
0004b0  f000003e          AND      r0,r0,#0x3e
0004b4  f7fffffe          BL       lwip_htons
0004b8  4601              MOV      r1,r0
0004ba  6928              LDR      r0,[r5,#0x10]  ; inseg
0004bc  8982              LDRH     r2,[r0,#0xc]
0004be  f422527c          BIC      r2,r2,#0x3f00
0004c2  4311              ORRS     r1,r1,r2
0004c4  8181              STRH     r1,[r0,#0xc]
                  |L6.1222|
;;;1231             }
;;;1232             /* Adjust length of segment to fit in the window. */
;;;1233             inseg.len = pcb->rcv_wnd;
0004c6  8da0              LDRH     r0,[r4,#0x2c]
0004c8  8128              STRH     r0,[r5,#8]
;;;1234             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
0004ca  6928              LDR      r0,[r5,#0x10]  ; inseg
0004cc  8980              LDRH     r0,[r0,#0xc]
0004ce  f7fffffe          BL       lwip_ntohs
0004d2  0780              LSLS     r0,r0,#30
0004d4  d502              BPL      |L6.1244|
;;;1235               inseg.len -= 1;
0004d6  8928              LDRH     r0,[r5,#8]  ; inseg
0004d8  1e40              SUBS     r0,r0,#1
0004da  8128              STRH     r0,[r5,#8]
                  |L6.1244|
;;;1236             }
;;;1237             pbuf_realloc(inseg.p, inseg.len);
0004dc  8929              LDRH     r1,[r5,#8]  ; inseg
0004de  6868              LDR      r0,[r5,#4]  ; inseg
0004e0  f7fffffe          BL       pbuf_realloc
;;;1238             tcplen = TCP_TCPLEN(&inseg);
0004e4  6928              LDR      r0,[r5,#0x10]  ; inseg
0004e6  8980              LDRH     r0,[r0,#0xc]
0004e8  f7fffffe          BL       lwip_ntohs
0004ec  0780              LSLS     r0,r0,#30
0004ee  d000              BEQ      |L6.1266|
0004f0  2001              MOVS     r0,#1
                  |L6.1266|
0004f2  8929              LDRH     r1,[r5,#8]  ; inseg
0004f4  4408              ADD      r0,r0,r1
0004f6  b280              UXTH     r0,r0
0004f8  8078              STRH     r0,[r7,#2]
;;;1239             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
0004fa  8da2              LDRH     r2,[r4,#0x2c]
0004fc  6aa1              LDR      r1,[r4,#0x28]
0004fe  4411              ADD      r1,r1,r2
000500  68fa              LDR      r2,[r7,#0xc]  ; seqno
000502  4410              ADD      r0,r0,r2
000504  4288              CMP      r0,r1
000506  d003              BEQ      |L6.1296|
000508  a0e2              ADR      r0,|L6.2196|
00050a  f7fffffe          BL       __2printf
                  |L6.1294|
00050e  e7fe              B        |L6.1294|
                  |L6.1296|
;;;1240                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1241           }
;;;1242   #if TCP_QUEUE_OOSEQ
;;;1243           /* Received in-sequence data, adjust ooseq data if:
;;;1244              - FIN has been received or
;;;1245              - inseq overlaps with ooseq */
;;;1246           if (pcb->ooseq != NULL) {
000510  6f60              LDR      r0,[r4,#0x74]
000512  b3e8              CBZ      r0,|L6.1424|
;;;1247             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000514  f8d90010          LDR      r0,[r9,#0x10]  ; inseg
000518  8980              LDRH     r0,[r0,#0xc]
00051a  f7fffffe          BL       lwip_ntohs
00051e  07c0              LSLS     r0,r0,#31
000520  d104              BNE      |L6.1324|
000522  e007              B        |L6.1332|
                  |L6.1316|
;;;1248               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1249                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1250               /* Received in-order FIN means anything that was received
;;;1251                * out of order must now have been received in-order, so
;;;1252                * bin the ooseq queue */
;;;1253               while (pcb->ooseq != NULL) {
;;;1254                 struct tcp_seg *old_ooseq = pcb->ooseq;
;;;1255                 pcb->ooseq = pcb->ooseq->next;
000524  6801              LDR      r1,[r0,#0]
;;;1256                 tcp_seg_free(old_ooseq);
000526  6761              STR      r1,[r4,#0x74]
000528  f7fffffe          BL       tcp_seg_free
                  |L6.1324|
00052c  6f60              LDR      r0,[r4,#0x74]         ;1253
00052e  2800              CMP      r0,#0                 ;1253
000530  d1f8              BNE      |L6.1316|
000532  e069              B        |L6.1544|
                  |L6.1332|
;;;1257               }
;;;1258             } else {
;;;1259               next = pcb->ooseq;
;;;1260               /* Remove all segments on ooseq that are covered by inseg already.
;;;1261                * FIN is copied from ooseq to inseg if present. */
;;;1262               while (next &&
000534  6f65              LDR      r5,[r4,#0x74]
000536  e021              B        |L6.1404|
                  |L6.1336|
;;;1263                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1264                                  next->tcphdr->seqno + next->len)) {
;;;1265                 /* inseg cannot have FIN here (already processed above) */
;;;1266                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
000538  8980              LDRH     r0,[r0,#0xc]
00053a  f7fffffe          BL       lwip_ntohs
00053e  07c0              LSLS     r0,r0,#31
000540  d018              BEQ      |L6.1396|
;;;1267                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
000542  f8d90010          LDR      r0,[r9,#0x10]  ; inseg
000546  46c8              MOV      r8,r9
000548  8980              LDRH     r0,[r0,#0xc]
00054a  f7fffffe          BL       lwip_ntohs
00054e  0780              LSLS     r0,r0,#30
000550  d410              BMI      |L6.1396|
;;;1268                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
000552  2001              MOVS     r0,#1
000554  f7fffffe          BL       lwip_htons
000558  f8d81010          LDR      r1,[r8,#0x10]  ; inseg
00055c  898a              LDRH     r2,[r1,#0xc]
00055e  4310              ORRS     r0,r0,r2
000560  8188              STRH     r0,[r1,#0xc]
;;;1269                   tcplen = TCP_TCPLEN(&inseg);
000562  f7fffffe          BL       lwip_ntohs
000566  0780              LSLS     r0,r0,#30
000568  d000              BEQ      |L6.1388|
00056a  2001              MOVS     r0,#1
                  |L6.1388|
00056c  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000570  4408              ADD      r0,r0,r1
000572  8078              STRH     r0,[r7,#2]
                  |L6.1396|
;;;1270                 }
;;;1271                 prev = next;
;;;1272                 next = next->next;
000574  4628              MOV      r0,r5
000576  682d              LDR      r5,[r5,#0]
;;;1273                 tcp_seg_free(prev);
000578  f7fffffe          BL       tcp_seg_free
                  |L6.1404|
00057c  b3f5              CBZ      r5,|L6.1532|
00057e  6928              LDR      r0,[r5,#0x10]         ;1263
000580  892a              LDRH     r2,[r5,#8]            ;1263
000582  887b              LDRH     r3,[r7,#2]            ;1263  ; tcplen
000584  6841              LDR      r1,[r0,#4]            ;1263
000586  4411              ADD      r1,r1,r2              ;1263
000588  68fa              LDR      r2,[r7,#0xc]          ;1263  ; seqno
00058a  441a              ADD      r2,r2,r3              ;1263
00058c  1a51              SUBS     r1,r2,r1              ;1263
00058e  e000              B        |L6.1426|
                  |L6.1424|
000590  e03a              B        |L6.1544|
                  |L6.1426|
000592  d5d1              BPL      |L6.1336|
;;;1274               }
;;;1275               /* Now trim right side of inseg if it overlaps with the first
;;;1276                * segment on ooseq */
;;;1277               if (next &&
;;;1278                   TCP_SEQ_GT(seqno + tcplen,
000594  68f8              LDR      r0,[r7,#0xc]  ; seqno
000596  b299              UXTH     r1,r3
000598  1842              ADDS     r2,r0,r1
00059a  6929              LDR      r1,[r5,#0x10]
00059c  6849              LDR      r1,[r1,#4]
00059e  1a52              SUBS     r2,r2,r1
0005a0  2a00              CMP      r2,#0
0005a2  dd30              BLE      |L6.1542|
;;;1279                              next->tcphdr->seqno)) {
;;;1280                 /* inseg cannot have FIN here (already processed above) */
;;;1281                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
0005a4  1a08              SUBS     r0,r1,r0
0005a6  f8a90008          STRH     r0,[r9,#8]
;;;1282                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
0005aa  f8d90010          LDR      r0,[r9,#0x10]  ; inseg
0005ae  46b8              MOV      r8,r7                 ;1281
0005b0  8980              LDRH     r0,[r0,#0xc]
0005b2  f7fffffe          BL       lwip_ntohs
0005b6  0780              LSLS     r0,r0,#30
0005b8  d504              BPL      |L6.1476|
;;;1283                   inseg.len -= 1;
0005ba  f8b91008          LDRH     r1,[r9,#8]  ; inseg
0005be  1e49              SUBS     r1,r1,#1
0005c0  f8a91008          STRH     r1,[r9,#8]
                  |L6.1476|
;;;1284                 }
;;;1285                 pbuf_realloc(inseg.p, inseg.len);
0005c4  f8b91008          LDRH     r1,[r9,#8]  ; inseg
0005c8  f8d90004          LDR      r0,[r9,#4]  ; inseg
0005cc  f7fffffe          BL       pbuf_realloc
;;;1286                 tcplen = TCP_TCPLEN(&inseg);
0005d0  f8d90010          LDR      r0,[r9,#0x10]  ; inseg
0005d4  8980              LDRH     r0,[r0,#0xc]
0005d6  f7fffffe          BL       lwip_ntohs
0005da  0780              LSLS     r0,r0,#30
0005dc  d000              BEQ      |L6.1504|
0005de  2001              MOVS     r0,#1
                  |L6.1504|
0005e0  f8b91008          LDRH     r1,[r9,#8]  ; inseg
0005e4  4408              ADD      r0,r0,r1
0005e6  b280              UXTH     r0,r0
0005e8  f8a80002          STRH     r0,[r8,#2]
;;;1287                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
0005ec  f8d8100c          LDR      r1,[r8,#0xc]  ; seqno
0005f0  4408              ADD      r0,r0,r1
0005f2  6929              LDR      r1,[r5,#0x10]
0005f4  6849              LDR      r1,[r1,#4]
0005f6  4288              CMP      r0,r1
0005f8  d005              BEQ      |L6.1542|
0005fa  e000              B        |L6.1534|
                  |L6.1532|
0005fc  e003              B        |L6.1542|
                  |L6.1534|
0005fe  a0b3              ADR      r0,|L6.2252|
000600  f7fffffe          BL       __2printf
                  |L6.1540|
000604  e7fe              B        |L6.1540|
                  |L6.1542|
;;;1288                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1289               }
;;;1290               pcb->ooseq = next;
000606  6765              STR      r5,[r4,#0x74]
                  |L6.1544|
;;;1291             }
;;;1292           }
;;;1293   #endif /* TCP_QUEUE_OOSEQ */
;;;1294   
;;;1295           pcb->rcv_nxt = seqno + tcplen;
000608  8878              LDRH     r0,[r7,#2]  ; tcplen
00060a  68f9              LDR      r1,[r7,#0xc]  ; seqno
00060c  4401              ADD      r1,r1,r0
;;;1296   
;;;1297           /* Update the receiver's (our) window. */
;;;1298           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
00060e  62a1              STR      r1,[r4,#0x28]
000610  8da1              LDRH     r1,[r4,#0x2c]
000612  4281              CMP      r1,r0
000614  d203              BCS      |L6.1566|
000616  a0bc              ADR      r0,|L6.2312|
000618  f7fffffe          BL       __2printf
                  |L6.1564|
00061c  e7fe              B        |L6.1564|
                  |L6.1566|
;;;1299           pcb->rcv_wnd -= tcplen;
00061e  1a08              SUBS     r0,r1,r0
000620  85a0              STRH     r0,[r4,#0x2c]
;;;1300   
;;;1301           tcp_update_rcv_ann_wnd(pcb);
000622  4620              MOV      r0,r4
000624  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1302   
;;;1303           /* If there is data in the segment, we make preparations to
;;;1304              pass this up to the application. The ->recv_data variable
;;;1305              is used for holding the pbuf that goes to the
;;;1306              application. The code for reassembling out-of-sequence data
;;;1307              chains its data on this pbuf as well.
;;;1308   
;;;1309              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1310              be used to indicate to the application that the remote side has
;;;1311              closed its end of the connection. */
;;;1312           if (inseg.p->tot_len > 0) {
000628  f8d90004          LDR      r0,[r9,#4]  ; inseg
00062c  4649              MOV      r1,r9
00062e  8902              LDRH     r2,[r0,#8]
000630  b10a              CBZ      r2,|L6.1590|
;;;1313             recv_data = inseg.p;
;;;1314             /* Since this pbuf now is the responsibility of the
;;;1315                application, we delete our reference to it so that we won't
;;;1316                (mistakingly) deallocate it. */
;;;1317             inseg.p = NULL;
000632  6178              STR      r0,[r7,#0x14]  ; recv_data
000634  604e              STR      r6,[r1,#4]  ; inseg
                  |L6.1590|
;;;1318           }
;;;1319           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000636  f8d90010          LDR      r0,[r9,#0x10]  ; inseg
00063a  8980              LDRH     r0,[r0,#0xc]
00063c  f7fffffe          BL       lwip_ntohs
000640  07c0              LSLS     r0,r0,#31
000642  d04d              BEQ      |L6.1760|
;;;1320             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
;;;1321             recv_flags |= TF_GOT_FIN;
000644  7878              LDRB     r0,[r7,#1]  ; recv_flags
000646  f0400020          ORR      r0,r0,#0x20
00064a  7078              STRB     r0,[r7,#1]
00064c  e048              B        |L6.1760|
                  |L6.1614|
;;;1322           }
;;;1323   
;;;1324   #if TCP_QUEUE_OOSEQ
;;;1325           /* We now check if we have segments on the ->ooseq queue that
;;;1326              are now in sequence. */
;;;1327           while (pcb->ooseq != NULL &&
;;;1328                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1329   
;;;1330             cseg = pcb->ooseq;
;;;1331             seqno = pcb->ooseq->tcphdr->seqno;
;;;1332   
;;;1333             pcb->rcv_nxt += TCP_TCPLEN(cseg);
00064e  60f9              STR      r1,[r7,#0xc]  ; seqno
000650  8980              LDRH     r0,[r0,#0xc]
000652  f7fffffe          BL       lwip_ntohs
000656  0780              LSLS     r0,r0,#30
000658  d000              BEQ      |L6.1628|
00065a  2001              MOVS     r0,#1
                  |L6.1628|
00065c  892a              LDRH     r2,[r5,#8]
00065e  6aa1              LDR      r1,[r4,#0x28]
000660  4411              ADD      r1,r1,r2
000662  4408              ADD      r0,r0,r1
;;;1334             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
000664  62a0              STR      r0,[r4,#0x28]
000666  6928              LDR      r0,[r5,#0x10]
000668  8980              LDRH     r0,[r0,#0xc]
00066a  f7fffffe          BL       lwip_ntohs
00066e  0780              LSLS     r0,r0,#30
000670  d000              BEQ      |L6.1652|
000672  2001              MOVS     r0,#1
                  |L6.1652|
000674  8929              LDRH     r1,[r5,#8]
000676  4408              ADD      r0,r0,r1
000678  8da1              LDRH     r1,[r4,#0x2c]
00067a  4288              CMP      r0,r1
00067c  d903              BLS      |L6.1670|
00067e  a0aa              ADR      r0,|L6.2344|
000680  f7fffffe          BL       __2printf
                  |L6.1668|
000684  e7fe              B        |L6.1668|
                  |L6.1670|
;;;1335                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1336             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
000686  6928              LDR      r0,[r5,#0x10]
000688  8980              LDRH     r0,[r0,#0xc]
00068a  f7fffffe          BL       lwip_ntohs
00068e  0780              LSLS     r0,r0,#30
000690  d000              BEQ      |L6.1684|
000692  2001              MOVS     r0,#1
                  |L6.1684|
000694  8929              LDRH     r1,[r5,#8]
000696  4408              ADD      r0,r0,r1
000698  8da1              LDRH     r1,[r4,#0x2c]
00069a  1a08              SUBS     r0,r1,r0
00069c  85a0              STRH     r0,[r4,#0x2c]
;;;1337   
;;;1338             tcp_update_rcv_ann_wnd(pcb);
00069e  4620              MOV      r0,r4
0006a0  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1339   
;;;1340             if (cseg->p->tot_len > 0) {
0006a4  6869              LDR      r1,[r5,#4]
0006a6  8908              LDRH     r0,[r1,#8]
0006a8  b130              CBZ      r0,|L6.1720|
;;;1341               /* Chain this pbuf onto the pbuf that we will pass to
;;;1342                  the application. */
;;;1343               if (recv_data) {
0006aa  6978              LDR      r0,[r7,#0x14]  ; recv_data
0006ac  b110              CBZ      r0,|L6.1716|
;;;1344                 pbuf_cat(recv_data, cseg->p);
0006ae  f7fffffe          BL       pbuf_cat
0006b2  e000              B        |L6.1718|
                  |L6.1716|
;;;1345               } else {
;;;1346                 recv_data = cseg->p;
0006b4  6179              STR      r1,[r7,#0x14]  ; recv_data
                  |L6.1718|
;;;1347               }
;;;1348               cseg->p = NULL;
0006b6  606e              STR      r6,[r5,#4]
                  |L6.1720|
;;;1349             }
;;;1350             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
0006b8  6928              LDR      r0,[r5,#0x10]
0006ba  8980              LDRH     r0,[r0,#0xc]
0006bc  f7fffffe          BL       lwip_ntohs
0006c0  07c0              LSLS     r0,r0,#31
0006c2  d008              BEQ      |L6.1750|
;;;1351               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
;;;1352               recv_flags |= TF_GOT_FIN;
0006c4  7878              LDRB     r0,[r7,#1]  ; recv_flags
0006c6  f0400020          ORR      r0,r0,#0x20
0006ca  7078              STRB     r0,[r7,#1]
;;;1353               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
0006cc  7e20              LDRB     r0,[r4,#0x18]
0006ce  2804              CMP      r0,#4
0006d0  d101              BNE      |L6.1750|
;;;1354                 pcb->state = CLOSE_WAIT;
0006d2  2007              MOVS     r0,#7
0006d4  7620              STRB     r0,[r4,#0x18]
                  |L6.1750|
;;;1355               } 
;;;1356             }
;;;1357   
;;;1358             pcb->ooseq = cseg->next;
0006d6  6828              LDR      r0,[r5,#0]
;;;1359             tcp_seg_free(cseg);
0006d8  6760              STR      r0,[r4,#0x74]
0006da  4628              MOV      r0,r5
0006dc  f7fffffe          BL       tcp_seg_free
                  |L6.1760|
0006e0  6f65              LDR      r5,[r4,#0x74]         ;1327
0006e2  b125              CBZ      r5,|L6.1774|
0006e4  6928              LDR      r0,[r5,#0x10]         ;1328
0006e6  6aa2              LDR      r2,[r4,#0x28]         ;1328
0006e8  6841              LDR      r1,[r0,#4]            ;1328
0006ea  4291              CMP      r1,r2                 ;1328
0006ec  d0af              BEQ      |L6.1614|
                  |L6.1774|
;;;1360           }
;;;1361   #endif /* TCP_QUEUE_OOSEQ */
;;;1362   
;;;1363   
;;;1364           /* Acknowledge the segment(s). */
;;;1365           tcp_ack(pcb);
0006ee  7fa0              LDRB     r0,[r4,#0x1e]
0006f0  07c1              LSLS     r1,r0,#31
0006f2  d002              BEQ      |L6.1786|
0006f4  f0200001          BIC      r0,r0,#1
0006f8  e0c9              B        |L6.2190|
                  |L6.1786|
0006fa  f0400001          ORR      r0,r0,#1
                  |L6.1790|
0006fe  77a0              STRB     r0,[r4,#0x1e]
                  |L6.1792|
;;;1366   
;;;1367         } else {
;;;1368           /* We get here if the incoming segment is out-of-sequence. */
;;;1369           tcp_send_empty_ack(pcb);
;;;1370   #if TCP_QUEUE_OOSEQ
;;;1371           /* We queue the segment on the ->ooseq queue. */
;;;1372           if (pcb->ooseq == NULL) {
;;;1373             pcb->ooseq = tcp_seg_copy(&inseg);
;;;1374           } else {
;;;1375             /* If the queue is not empty, we walk through the queue and
;;;1376                try to find a place where the sequence number of the
;;;1377                incoming segment is between the sequence numbers of the
;;;1378                previous and the next segment on the ->ooseq queue. That is
;;;1379                the place where we put the incoming segment. If needed, we
;;;1380                trim the second edges of the previous and the incoming
;;;1381                segment so that it will fit into the sequence.
;;;1382   
;;;1383                If the incoming segment has the same sequence number as a
;;;1384                segment on the ->ooseq queue, we discard the segment that
;;;1385                contains less data. */
;;;1386   
;;;1387             prev = NULL;
;;;1388             for(next = pcb->ooseq; next != NULL; next = next->next) {
;;;1389               if (seqno == next->tcphdr->seqno) {
;;;1390                 /* The sequence number of the incoming segment is the
;;;1391                    same as the sequence number of the segment on
;;;1392                    ->ooseq. We check the lengths to see which one to
;;;1393                    discard. */
;;;1394                 if (inseg.len > next->len) {
;;;1395                   /* The incoming segment is larger than the old
;;;1396                      segment. We replace some segments with the new
;;;1397                      one. */
;;;1398                   cseg = tcp_seg_copy(&inseg);
;;;1399                   if (cseg != NULL) {
;;;1400                     if (prev != NULL) {
;;;1401                       prev->next = cseg;
;;;1402                     } else {
;;;1403                       pcb->ooseq = cseg;
;;;1404                     }
;;;1405                     tcp_oos_insert_segment(cseg, next);
;;;1406                   }
;;;1407                   break;
;;;1408                 } else {
;;;1409                   /* Either the lenghts are the same or the incoming
;;;1410                      segment was smaller than the old one; in either
;;;1411                      case, we ditch the incoming segment. */
;;;1412                   break;
;;;1413                 }
;;;1414               } else {
;;;1415                 if (prev == NULL) {
;;;1416                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
;;;1417                     /* The sequence number of the incoming segment is lower
;;;1418                        than the sequence number of the first segment on the
;;;1419                        queue. We put the incoming segment first on the
;;;1420                        queue. */
;;;1421                     cseg = tcp_seg_copy(&inseg);
;;;1422                     if (cseg != NULL) {
;;;1423                       pcb->ooseq = cseg;
;;;1424                       tcp_oos_insert_segment(cseg, next);
;;;1425                     }
;;;1426                     break;
;;;1427                   }
;;;1428                 } else {
;;;1429                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1430                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1431                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
;;;1432                     /* The sequence number of the incoming segment is in
;;;1433                        between the sequence numbers of the previous and
;;;1434                        the next segment on ->ooseq. We trim trim the previous
;;;1435                        segment, delete next segments that included in received segment
;;;1436                        and trim received, if needed. */
;;;1437                     cseg = tcp_seg_copy(&inseg);
;;;1438                     if (cseg != NULL) {
;;;1439                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
;;;1440                         /* We need to trim the prev segment. */
;;;1441                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
;;;1442                         pbuf_realloc(prev->p, prev->len);
;;;1443                       }
;;;1444                       prev->next = cseg;
;;;1445                       tcp_oos_insert_segment(cseg, next);
;;;1446                     }
;;;1447                     break;
;;;1448                   }
;;;1449                 }
;;;1450                 /* If the "next" segment is the last segment on the
;;;1451                    ooseq queue, we add the incoming segment to the end
;;;1452                    of the list. */
;;;1453                 if (next->next == NULL &&
;;;1454                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
;;;1455                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
;;;1456                     /* segment "next" already contains all data */
;;;1457                     break;
;;;1458                   }
;;;1459                   next->next = tcp_seg_copy(&inseg);
;;;1460                   if (next->next != NULL) {
;;;1461                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
;;;1462                       /* We need to trim the last segment. */
;;;1463                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
;;;1464                       pbuf_realloc(next->p, next->len);
;;;1465                     }
;;;1466                     /* check if the remote side overruns our receive window */
;;;1467                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
;;;1468                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1469                                   ("tcp_receive: other end overran receive window"
;;;1470                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1471                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1472                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
;;;1473                         /* Must remove the FIN from the header as we're trimming 
;;;1474                          * that byte of sequence-space from the packet */
;;;1475                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
;;;1476                       }
;;;1477                       /* Adjust length of segment to fit in the window. */
;;;1478                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
;;;1479                       pbuf_realloc(next->next->p, next->next->len);
;;;1480                       tcplen = TCP_TCPLEN(next->next);
;;;1481                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
;;;1482                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1483                     }
;;;1484                   }
;;;1485                   break;
;;;1486                 }
;;;1487               }
;;;1488               prev = next;
;;;1489             }
;;;1490           }
;;;1491   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1492           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1493              and throw away everything above that limit. */
;;;1494           ooseq_blen = 0;
;;;1495           ooseq_qlen = 0;
;;;1496           prev = NULL;
;;;1497           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1498             struct pbuf *p = next->p;
;;;1499             ooseq_blen += p->tot_len;
;;;1500             ooseq_qlen += pbuf_clen(p);
;;;1501             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1502                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1503                /* too much ooseq data, dump this and everything after it */
;;;1504                tcp_segs_free(next);
;;;1505                if (prev == NULL) {
;;;1506                  /* first ooseq segment is too much, dump the whole queue */
;;;1507                  pcb->ooseq = NULL;
;;;1508                } else {
;;;1509                  /* just dump 'next' and everything after it */
;;;1510                  prev->next = NULL;
;;;1511                }
;;;1512                break;
;;;1513             }
;;;1514           }
;;;1515   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517         }
;;;1518       } else {
;;;1519         /* The incoming segment is not withing the window. */
;;;1520         tcp_send_empty_ack(pcb);
;;;1521       }
;;;1522     } else {
;;;1523       /* Segments with length 0 is taken care of here. Segments that
;;;1524          fall out of the window are ACKed. */
;;;1525       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1526         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1527       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
;;;1528         tcp_ack_now(pcb);
;;;1529       }
;;;1530     }
;;;1531   }
000700  e8bd87f0          POP      {r4-r10,pc}
                  |L6.1796|
000704  4620              MOV      r0,r4                 ;1369
000706  f7fffffe          BL       tcp_send_empty_ack
00070a  6f65              LDR      r5,[r4,#0x74]         ;1372
00070c  b19d              CBZ      r5,|L6.1846|
00070e  68f8              LDR      r0,[r7,#0xc]          ;870
000710  2600              MOVS     r6,#0                 ;1387
                  |L6.1810|
000712  6929              LDR      r1,[r5,#0x10]         ;1389
000714  6849              LDR      r1,[r1,#4]            ;1389
000716  4281              CMP      r1,r0                 ;1389
000718  d112              BNE      |L6.1856|
00071a  f8b80008          LDRH     r0,[r8,#8]            ;1394  ; inseg
00071e  8929              LDRH     r1,[r5,#8]            ;1394
000720  4288              CMP      r0,r1                 ;1394
000722  d9ed              BLS      |L6.1792|
000724  488a              LDR      r0,|L6.2384|
000726  f7fffffe          BL       tcp_seg_copy
00072a  2800              CMP      r0,#0                 ;1399
00072c  d0e8              BEQ      |L6.1792|
00072e  b396              CBZ      r6,|L6.1942|
000730  6030              STR      r0,[r6,#0]            ;1401
                  |L6.1842|
000732  4629              MOV      r1,r5                 ;1405
000734  e024              B        |L6.1920|
                  |L6.1846|
000736  4886              LDR      r0,|L6.2384|
000738  f7fffffe          BL       tcp_seg_copy
00073c  6760              STR      r0,[r4,#0x74]         ;1373
00073e  e7df              B        |L6.1792|
                  |L6.1856|
000740  b316              CBZ      r6,|L6.1928|
000742  6932              LDR      r2,[r6,#0x10]         ;1431
000744  6852              LDR      r2,[r2,#4]            ;1431
000746  1a82              SUBS     r2,r0,r2              ;1431
000748  2a01              CMP      r2,#1                 ;1431
00074a  d426              BMI      |L6.1946|
00074c  1a42              SUBS     r2,r0,r1              ;1431
00074e  1c52              ADDS     r2,r2,#1              ;1431
000750  2a00              CMP      r2,#0                 ;1431
000752  dc22              BGT      |L6.1946|
000754  487e              LDR      r0,|L6.2384|
000756  f7fffffe          BL       tcp_seg_copy
00075a  0004              MOVS     r4,r0                 ;1437
00075c  d0d0              BEQ      |L6.1792|
00075e  6930              LDR      r0,[r6,#0x10]         ;1439
000760  8931              LDRH     r1,[r6,#8]            ;1439
000762  6840              LDR      r0,[r0,#4]            ;1439
000764  1842              ADDS     r2,r0,r1              ;1439
000766  68f9              LDR      r1,[r7,#0xc]          ;1439  ; seqno
000768  1a52              SUBS     r2,r2,r1              ;1439
00076a  2a00              CMP      r2,#0                 ;1439
00076c  dd05              BLE      |L6.1914|
00076e  1a08              SUBS     r0,r1,r0              ;1441
000770  b281              UXTH     r1,r0                 ;1441
000772  8131              STRH     r1,[r6,#8]            ;1441
000774  6870              LDR      r0,[r6,#4]            ;1442
000776  f7fffffe          BL       pbuf_realloc
                  |L6.1914|
00077a  4629              MOV      r1,r5                 ;1445
00077c  4620              MOV      r0,r4                 ;1445
00077e  6034              STR      r4,[r6,#0]            ;1445
                  |L6.1920|
000780  e8bd47f0          POP      {r4-r10,lr}           ;1445
000784  f7ffbffe          B.W      tcp_oos_insert_segment
                  |L6.1928|
000788  1a42              SUBS     r2,r0,r1              ;1416
00078a  d506              BPL      |L6.1946|
00078c  4870              LDR      r0,|L6.2384|
00078e  f7fffffe          BL       tcp_seg_copy
000792  2800              CMP      r0,#0                 ;1422
                  |L6.1940|
000794  d0b4              BEQ      |L6.1792|
                  |L6.1942|
000796  6760              STR      r0,[r4,#0x74]         ;1424
000798  e7cb              B        |L6.1842|
                  |L6.1946|
00079a  682a              LDR      r2,[r5,#0]            ;1453
00079c  bbf2              CBNZ     r2,|L6.2076|
00079e  1a41              SUBS     r1,r0,r1              ;1454
0007a0  2900              CMP      r1,#0                 ;1454
0007a2  dd5f              BLE      |L6.2148|
0007a4  6928              LDR      r0,[r5,#0x10]         ;1455
0007a6  8980              LDRH     r0,[r0,#0xc]          ;1455
0007a8  f7fffffe          BL       lwip_ntohs
0007ac  07c0              LSLS     r0,r0,#31             ;1455
0007ae  d1a7              BNE      |L6.1792|
0007b0  4867              LDR      r0,|L6.2384|
0007b2  f7fffffe          BL       tcp_seg_copy
0007b6  6028              STR      r0,[r5,#0]            ;1460
0007b8  2800              CMP      r0,#0                 ;1460
0007ba  d0a1              BEQ      |L6.1792|
0007bc  6928              LDR      r0,[r5,#0x10]         ;1461
0007be  8929              LDRH     r1,[r5,#8]            ;1461
0007c0  6840              LDR      r0,[r0,#4]            ;1461
0007c2  1842              ADDS     r2,r0,r1              ;1461
0007c4  68f9              LDR      r1,[r7,#0xc]          ;1461  ; seqno
0007c6  1a52              SUBS     r2,r2,r1              ;1461
0007c8  2a00              CMP      r2,#0                 ;1461
0007ca  dd05              BLE      |L6.2008|
0007cc  1a08              SUBS     r0,r1,r0              ;1463
0007ce  b281              UXTH     r1,r0                 ;1463
0007d0  8129              STRH     r1,[r5,#8]            ;1463
0007d2  6868              LDR      r0,[r5,#4]            ;1464
0007d4  f7fffffe          BL       pbuf_realloc
                  |L6.2008|
0007d8  8da1              LDRH     r1,[r4,#0x2c]         ;1467
0007da  6aa0              LDR      r0,[r4,#0x28]         ;1467
0007dc  68fa              LDR      r2,[r7,#0xc]          ;1467  ; seqno
0007de  4408              ADD      r0,r0,r1              ;1467
0007e0  8879              LDRH     r1,[r7,#2]            ;1467  ; tcplen
0007e2  4411              ADD      r1,r1,r2              ;1467
0007e4  4288              CMP      r0,r1                 ;1467
0007e6  d28b              BCS      |L6.1792|
0007e8  6828              LDR      r0,[r5,#0]            ;1472
0007ea  6900              LDR      r0,[r0,#0x10]         ;1472
0007ec  8980              LDRH     r0,[r0,#0xc]          ;1472
0007ee  f7fffffe          BL       lwip_ntohs
0007f2  07c0              LSLS     r0,r0,#31             ;1472
0007f4  d010              BEQ      |L6.2072|
0007f6  6828              LDR      r0,[r5,#0]            ;1475
0007f8  6900              LDR      r0,[r0,#0x10]         ;1475
0007fa  8980              LDRH     r0,[r0,#0xc]          ;1475
0007fc  f7fffffe          BL       lwip_ntohs
000800  f000003e          AND      r0,r0,#0x3e           ;1475
000804  f7fffffe          BL       lwip_htons
000808  4601              MOV      r1,r0                 ;1475
00080a  6828              LDR      r0,[r5,#0]            ;1475
00080c  6900              LDR      r0,[r0,#0x10]         ;1475
00080e  8982              LDRH     r2,[r0,#0xc]          ;1475
000810  f422527c          BIC      r2,r2,#0x3f00         ;1475
000814  4311              ORRS     r1,r1,r2              ;1475
000816  8181              STRH     r1,[r0,#0xc]          ;1475
                  |L6.2072|
000818  8d20              LDRH     r0,[r4,#0x28]         ;1478
00081a  e000              B        |L6.2078|
                  |L6.2076|
00081c  e022              B        |L6.2148|
                  |L6.2078|
00081e  8da1              LDRH     r1,[r4,#0x2c]         ;1478
000820  4408              ADD      r0,r0,r1              ;1478
000822  89b9              LDRH     r1,[r7,#0xc]          ;1478  ; seqno
000824  1a40              SUBS     r0,r0,r1              ;1478
000826  b281              UXTH     r1,r0                 ;1478
000828  6828              LDR      r0,[r5,#0]            ;1478
00082a  8101              STRH     r1,[r0,#8]            ;1478
00082c  6828              LDR      r0,[r5,#0]            ;1479
00082e  6840              LDR      r0,[r0,#4]            ;1479
000830  f7fffffe          BL       pbuf_realloc
000834  6828              LDR      r0,[r5,#0]            ;1480
000836  6900              LDR      r0,[r0,#0x10]         ;1480
000838  8980              LDRH     r0,[r0,#0xc]          ;1480
00083a  f7fffffe          BL       lwip_ntohs
00083e  0780              LSLS     r0,r0,#30             ;1480
000840  d000              BEQ      |L6.2116|
000842  2001              MOVS     r0,#1                 ;1480
                  |L6.2116|
000844  6829              LDR      r1,[r5,#0]            ;1480
000846  8909              LDRH     r1,[r1,#8]            ;1480
000848  4408              ADD      r0,r0,r1              ;1480
00084a  b280              UXTH     r0,r0                 ;1480
00084c  8078              STRH     r0,[r7,#2]            ;1480
00084e  8da2              LDRH     r2,[r4,#0x2c]         ;1481
000850  6aa1              LDR      r1,[r4,#0x28]         ;1481
000852  4411              ADD      r1,r1,r2              ;1481
000854  68fa              LDR      r2,[r7,#0xc]          ;1481  ; seqno
000856  4410              ADD      r0,r0,r2              ;1481
000858  4288              CMP      r0,r1                 ;1481
00085a  d09b              BEQ      |L6.1940|
00085c  a00d              ADR      r0,|L6.2196|
00085e  f7fffffe          BL       __2printf
                  |L6.2146|
000862  e7fe              B        |L6.2146|
                  |L6.2148|
000864  462e              MOV      r6,r5                 ;1488
000866  0015              MOVS     r5,r2                 ;1388
000868  f47faf53          BNE      |L6.1810|
                  |L6.2156|
00086c  e748              B        |L6.1792|
                  |L6.2158|
00086e  4620              MOV      r0,r4                 ;1520
000870  e8bd47f0          POP      {r4-r10,lr}           ;1520
000874  f7ffbffe          B.W      tcp_send_empty_ack
                  |L6.2168|
000878  6aa0              LDR      r0,[r4,#0x28]         ;1527
00087a  68f9              LDR      r1,[r7,#0xc]          ;1527  ; seqno
00087c  1a0a              SUBS     r2,r1,r0              ;1527
00087e  d405              BMI      |L6.2188|
000880  8da2              LDRH     r2,[r4,#0x2c]         ;1527
000882  4410              ADD      r0,r0,r2              ;1527
000884  1a08              SUBS     r0,r1,r0              ;1527
000886  1c40              ADDS     r0,r0,#1              ;1527
000888  2800              CMP      r0,#0                 ;1527
00088a  ddef              BLE      |L6.2156|
                  |L6.2188|
00088c  7fa0              LDRB     r0,[r4,#0x1e]         ;1528
                  |L6.2190|
00088e  f0400002          ORR      r0,r0,#2              ;1528
000892  e734              B        |L6.1790|
;;;1532   
                          ENDP

                  |L6.2196|
000894  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
000898  72656365
00089c  6976653a
0008a0  20736567
0008a4  6d656e74
0008a8  206e6f74
0008ac  20747269
0008b0  6d6d6564
0008b4  20636f72
0008b8  72656374
0008bc  6c792074
0008c0  6f207263
0008c4  765f776e
0008c8  640a    
0008ca  00                DCB      0
0008cb  00                DCB      0
                  |L6.2252|
0008cc  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
0008d0  72656365
0008d4  6976653a
0008d8  20736567
0008dc  6d656e74
0008e0  206e6f74
0008e4  20747269
0008e8  6d6d6564
0008ec  20636f72
0008f0  72656374
0008f4  6c792074
0008f8  6f206f6f
0008fc  73657120
000900  717565  
000903  75650a00          DCB      "ue\n",0
000907  00                DCB      0
                  |L6.2312|
000908  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
00090c  72656365
000910  6976653a
000914  20746370
000918  6c656e20
00091c  3e207263
000920  765f776e
000924  640a00  
000927  00                DCB      0
                  |L6.2344|
000928  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
00092c  72656365
000930  6976653a
000934  206f6f73
000938  65712074
00093c  63706c65
000940  6e203e20
000944  7263765f
000948  776e640a
00094c  00      
00094d  00                DCB      0
00094e  00                DCB      0
00094f  00                DCB      0
                  |L6.2384|
                          DCD      ||.bss||

                          AREA ||i.tcp_timewait_input||, CODE, READONLY, ALIGN=2

                  tcp_timewait_input PROC
;;;528    static err_t
;;;529    tcp_timewait_input(struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;530    {
;;;531      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;532      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;533       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;534       *   acceptable since we only send ACKs)
;;;535       * - second check the RST bit (... return) */
;;;536      if (flags & TCP_RST)  {
000002  4c16              LDR      r4,|L7.92|
000004  7822              LDRB     r2,[r4,#0]  ; flags
000006  0751              LSLS     r1,r2,#29
000008  d426              BMI      |L7.88|
00000a  4621              MOV      r1,r4
;;;537        return ERR_OK;
;;;538      }
;;;539      /* - fourth, check the SYN bit, */
;;;540      if (flags & TCP_SYN) {
00000c  0793              LSLS     r3,r2,#30
;;;541        /* If an incoming segment is not acceptable, an acknowledgment
;;;542           should be sent in reply */
;;;543        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;544          /* If the SYN is in the window it is an error, send a reset */
;;;545          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
00000e  8849              LDRH     r1,[r1,#2]
000010  d514              BPL      |L7.60|
000012  6a83              LDR      r3,[r0,#0x28]         ;543
000014  68e2              LDR      r2,[r4,#0xc]          ;543  ; seqno
000016  1ad5              SUBS     r5,r2,r3              ;543
000018  d415              BMI      |L7.70|
00001a  8d85              LDRH     r5,[r0,#0x2c]         ;543
00001c  442b              ADD      r3,r3,r5              ;543
00001e  1ad3              SUBS     r3,r2,r3              ;543
000020  2b00              CMP      r3,#0                 ;543
000022  dc10              BGT      |L7.70|
000024  6860              LDR      r0,[r4,#4]  ; tcphdr
000026  4411              ADD      r1,r1,r2
000028  4a0e              LDR      r2,|L7.100|
00002a  8803              LDRH     r3,[r0,#0]
00002c  8840              LDRH     r0,[r0,#2]
00002e  e9cd0300          STRD     r0,r3,[sp,#0]
000032  4b0b              LDR      r3,|L7.96|
000034  6920              LDR      r0,[r4,#0x10]  ; ackno
000036  f7fffffe          BL       tcp_rst
;;;546            tcphdr->dest, tcphdr->src);
;;;547          return ERR_OK;
00003a  e00d              B        |L7.88|
                  |L7.60|
;;;548        }
;;;549      } else if (flags & TCP_FIN) {
00003c  07d2              LSLS     r2,r2,#31
00003e  d002              BEQ      |L7.70|
;;;550        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;551             Restart the 2 MSL time-wait timeout.*/
;;;552        pcb->tmr = tcp_ticks;
000040  4a09              LDR      r2,|L7.104|
000042  6812              LDR      r2,[r2,#0]  ; tcp_ticks
000044  6242              STR      r2,[r0,#0x24]
                  |L7.70|
;;;553      }
;;;554    
;;;555      if ((tcplen > 0))  {
000046  b139              CBZ      r1,|L7.88|
;;;556        /* Acknowledge data, FIN or out-of-window SYN */
;;;557        pcb->flags |= TF_ACK_NOW;
000048  7f81              LDRB     r1,[r0,#0x1e]
00004a  f0410102          ORR      r1,r1,#2
00004e  7781              STRB     r1,[r0,#0x1e]
;;;558        return tcp_output(pcb);
000050  e8bd407c          POP      {r2-r6,lr}
000054  f7ffbffe          B.W      tcp_output
                  |L7.88|
;;;559      }
;;;560      return ERR_OK;
000058  2000              MOVS     r0,#0
;;;561    }
00005a  bd7c              POP      {r2-r6,pc}
;;;562    
                          ENDP

                  |L7.92|
                          DCD      ||.data||
                  |L7.96|
                          DCD      current_iphdr_src
                  |L7.100|
                          DCD      current_iphdr_dest
                  |L7.104|
                          DCD      tcp_ticks

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  flags
000000  00                DCB      0x00
                  recv_flags
000001  00                DCB      0x00
                  tcplen
000002  0000              DCB      0x00,0x00
                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000
