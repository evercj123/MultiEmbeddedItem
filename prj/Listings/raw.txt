; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\raw.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\raw.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\raw.crf ..\lwip\src\core\raw.c]
                          THUMB

                          AREA ||i.raw_bind||, CODE, READONLY, ALIGN=1

                  raw_bind PROC
;;;141    err_t
;;;142    raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
000000  b101              CBZ      r1,|L1.4|
;;;143    {
;;;144      ip_addr_set(&pcb->local_ip, ipaddr);
000002  6809              LDR      r1,[r1,#0]
                  |L1.4|
;;;145      return ERR_OK;
000004  6001              STR      r1,[r0,#0]
000006  2000              MOVS     r0,#0
;;;146    }
000008  4770              BX       lr
;;;147    
                          ENDP


                          AREA ||i.raw_connect||, CODE, READONLY, ALIGN=1

                  raw_connect PROC
;;;161    err_t
;;;162    raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
000000  b101              CBZ      r1,|L2.4|
;;;163    {
;;;164      ip_addr_set(&pcb->remote_ip, ipaddr);
000002  6809              LDR      r1,[r1,#0]
                  |L2.4|
;;;165      return ERR_OK;
000004  6041              STR      r1,[r0,#4]
000006  2000              MOVS     r0,#0
;;;166    }
000008  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.raw_input||, CODE, READONLY, ALIGN=2

                  raw_input PROC
;;;75     u8_t
;;;76     raw_input(struct pbuf *p, struct netif *inp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;77     {
000004  4607              MOV      r7,r0
;;;78       struct raw_pcb *pcb, *prev;
;;;79       struct ip_hdr *iphdr;
;;;80       s16_t proto;
;;;81       u8_t eaten = 0;
;;;82     
;;;83       LWIP_UNUSED_ARG(inp);
;;;84     
;;;85       iphdr = (struct ip_hdr *)p->payload;
000006  6840              LDR      r0,[r0,#4]
;;;86       proto = IPH_PROTO(iphdr);
;;;87     
;;;88       prev = NULL;
;;;89       pcb = raw_pcbs;
000008  f8df905c          LDR      r9,|L3.104|
00000c  2600              MOVS     r6,#0                 ;81
00000e  f8908009          LDRB     r8,[r0,#9]            ;86
000012  4635              MOV      r5,r6                 ;88
000014  f8d94000          LDR      r4,[r9,#0]            ;77  ; raw_pcbs
000018  e021              B        |L3.94|
                  |L3.26|
;;;90       /* loop through all raw pcbs until the packet is eaten by one */
;;;91       /* this allows multiple pcbs to match against the packet by design */
;;;92       while ((eaten == 0) && (pcb != NULL)) {
;;;93         if ((pcb->protocol == proto) &&
00001a  7c21              LDRB     r1,[r4,#0x10]
00001c  4541              CMP      r1,r8
00001e  d11b              BNE      |L3.88|
;;;94             (ip_addr_isany(&pcb->local_ip) ||
000020  b12c              CBZ      r4,|L3.46|
000022  6820              LDR      r0,[r4,#0]
000024  b118              CBZ      r0,|L3.46|
;;;95              ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
000026  4911              LDR      r1,|L3.108|
000028  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
00002a  4288              CMP      r0,r1
00002c  d114              BNE      |L3.88|
                  |L3.46|
;;;96     #if IP_SOF_BROADCAST_RECV
;;;97           /* broadcast filter? */
;;;98           if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
;;;99     #endif /* IP_SOF_BROADCAST_RECV */
;;;100          {
;;;101            /* receive callback function available? */
;;;102            if (pcb->recv != NULL) {
00002e  f8d4c014          LDR      r12,[r4,#0x14]
000032  f1bc0f00          CMP      r12,#0
000036  d00f              BEQ      |L3.88|
;;;103              /* the receive callback function did not eat the packet? */
;;;104              if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
000038  4b0d              LDR      r3,|L3.112|
00003a  463a              MOV      r2,r7
00003c  4621              MOV      r1,r4
00003e  69a0              LDR      r0,[r4,#0x18]
000040  47e0              BLX      r12
000042  b148              CBZ      r0,|L3.88|
;;;105                /* receive function ate the packet */
;;;106                p = NULL;
000044  2700              MOVS     r7,#0
;;;107                eaten = 1;
000046  2601              MOVS     r6,#1
;;;108                if (prev != NULL) {
000048  b135              CBZ      r5,|L3.88|
;;;109                /* move the pcb to the front of raw_pcbs so that is
;;;110                   found faster next time */
;;;111                  prev->next = pcb->next;
00004a  68e0              LDR      r0,[r4,#0xc]
;;;112                  pcb->next = raw_pcbs;
00004c  60e8              STR      r0,[r5,#0xc]
00004e  f8d91000          LDR      r1,[r9,#0]  ; raw_pcbs
;;;113                  raw_pcbs = pcb;
000052  60e1              STR      r1,[r4,#0xc]
000054  f8c94000          STR      r4,[r9,#0]  ; raw_pcbs
                  |L3.88|
;;;114                }
;;;115              }
;;;116            }
;;;117            /* no receive callback function was set for this raw PCB */
;;;118          }
;;;119          /* drop the packet */
;;;120        }
;;;121        prev = pcb;
000058  4625              MOV      r5,r4
;;;122        pcb = pcb->next;
00005a  68e4              LDR      r4,[r4,#0xc]
00005c  b90e              CBNZ     r6,|L3.98|
                  |L3.94|
00005e  2c00              CMP      r4,#0                 ;92
000060  d1db              BNE      |L3.26|
                  |L3.98|
;;;123      }
;;;124      return eaten;
000062  4630              MOV      r0,r6
;;;125    }
000064  e8bd87f0          POP      {r4-r10,pc}
;;;126    
                          ENDP

                  |L3.104|
                          DCD      ||.data||
                  |L3.108|
                          DCD      current_iphdr_dest
                  |L3.112|
                          DCD      current_iphdr_src

                          AREA ||i.raw_new||, CODE, READONLY, ALIGN=2

                  raw_new PROC
;;;330    struct raw_pcb *
;;;331    raw_new(u8_t proto)
000000  b570              PUSH     {r4-r6,lr}
;;;332    {
000002  4605              MOV      r5,r0
;;;333      struct raw_pcb *pcb;
;;;334    
;;;335      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));
;;;336    
;;;337      pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       memp_malloc
00000a  0004              MOVS     r4,r0
;;;338      /* could allocate RAW PCB? */
;;;339      if (pcb != NULL) {
00000c  d009              BEQ      |L4.34|
;;;340        /* initialize PCB to all zeroes */
;;;341        memset(pcb, 0, sizeof(struct raw_pcb));
00000e  211c              MOVS     r1,#0x1c
000010  f7fffffe          BL       __aeabi_memclr4
;;;342        pcb->protocol = proto;
000014  7425              STRB     r5,[r4,#0x10]
;;;343        pcb->ttl = RAW_TTL;
000016  20ff              MOVS     r0,#0xff
000018  72a0              STRB     r0,[r4,#0xa]
;;;344        pcb->next = raw_pcbs;
00001a  4803              LDR      r0,|L4.40|
00001c  6801              LDR      r1,[r0,#0]  ; raw_pcbs
;;;345        raw_pcbs = pcb;
00001e  60e1              STR      r1,[r4,#0xc]
000020  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L4.34|
;;;346      }
;;;347      return pcb;
000022  4620              MOV      r0,r4
;;;348    }
000024  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||.data||

                          AREA ||i.raw_recv||, CODE, READONLY, ALIGN=1

                  raw_recv PROC
;;;182    void
;;;183    raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
000000  e9c01205          STRD     r1,r2,[r0,#0x14]
;;;184    {
;;;185      /* remember recv() callback and user data */
;;;186      pcb->recv = recv;
;;;187      pcb->recv_arg = recv_arg;
;;;188    }
000004  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||i.raw_remove||, CODE, READONLY, ALIGN=2

                  raw_remove PROC
;;;299    void
;;;300    raw_remove(struct raw_pcb *pcb)
000000  4909              LDR      r1,|L6.40|
;;;301    {
;;;302      struct raw_pcb *pcb2;
;;;303      /* pcb to be removed is first in list? */
;;;304      if (raw_pcbs == pcb) {
000002  680a              LDR      r2,[r1,#0]  ; raw_pcbs
000004  4282              CMP      r2,r0
000006  d109              BNE      |L6.28|
;;;305        /* make list start at 2nd pcb */
;;;306        raw_pcbs = raw_pcbs->next;
000008  68d2              LDR      r2,[r2,#0xc]
00000a  600a              STR      r2,[r1,#0]  ; raw_pcbs
00000c  e008              B        |L6.32|
                  |L6.14|
;;;307        /* pcb not 1st in list */
;;;308      } else {
;;;309        for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
;;;310          /* find pcb in raw_pcbs list */
;;;311          if (pcb2->next != NULL && pcb2->next == pcb) {
00000e  68d1              LDR      r1,[r2,#0xc]
000010  b119              CBZ      r1,|L6.26|
000012  4281              CMP      r1,r0
000014  d101              BNE      |L6.26|
;;;312            /* remove pcb from list */
;;;313            pcb2->next = pcb->next;
000016  68c1              LDR      r1,[r0,#0xc]
000018  60d1              STR      r1,[r2,#0xc]
                  |L6.26|
00001a  460a              MOV      r2,r1                 ;309
                  |L6.28|
00001c  2a00              CMP      r2,#0                 ;309
00001e  d1f6              BNE      |L6.14|
                  |L6.32|
;;;314          }
;;;315        }
;;;316      }
;;;317      memp_free(MEMP_RAW_PCB, pcb);
000020  4601              MOV      r1,r0
000022  2000              MOVS     r0,#0
000024  f7ffbffe          B.W      memp_free
;;;318    }
;;;319    
                          ENDP

                  |L6.40|
                          DCD      ||.data||

                          AREA ||i.raw_send||, CODE, READONLY, ALIGN=1

                  raw_send PROC
;;;285    err_t
;;;286    raw_send(struct raw_pcb *pcb, struct pbuf *p)
000000  1d02              ADDS     r2,r0,#4
;;;287    {
;;;288      return raw_sendto(pcb, p, &pcb->remote_ip);
000002  f7ffbffe          B.W      raw_sendto
;;;289    }
;;;290    
                          ENDP


                          AREA ||i.raw_sendto||, CODE, READONLY, ALIGN=2

                  raw_sendto PROC
;;;202    err_t
;;;203    raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
000000  b5fe              PUSH     {r1-r7,lr}
;;;204    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
000006  4617              MOV      r7,r2
;;;205      err_t err;
;;;206      struct netif *netif;
;;;207      ip_addr_t *src_ip;
;;;208      struct pbuf *q; /* q will be sent down the stack */
;;;209      
;;;210      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
;;;211      
;;;212      /* not enough space to add an IP header to first pbuf in given p chain? */
;;;213      if (pbuf_header(p, IP_HLEN)) {
000008  2114              MOVS     r1,#0x14
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       pbuf_header
000010  b180              CBZ      r0,|L8.52|
;;;214        /* allocate header in new pbuf */
;;;215        q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
000012  2200              MOVS     r2,#0
000014  4611              MOV      r1,r2
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       pbuf_alloc
00001c  0005              MOVS     r5,r0
;;;216        /* new header pbuf could not be allocated? */
;;;217        if (q == NULL) {
00001e  d006              BEQ      |L8.46|
;;;218          LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
;;;219          return ERR_MEM;
;;;220        }
;;;221        if (p->tot_len != 0) {
000020  8930              LDRH     r0,[r6,#8]
000022  b190              CBZ      r0,|L8.74|
;;;222          /* chain header q in front of given pbuf p */
;;;223          pbuf_chain(q, p);
000024  4631              MOV      r1,r6
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       pbuf_chain
00002c  e00d              B        |L8.74|
                  |L8.46|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;219
;;;224        }
;;;225        /* { first pbuf q points to header pbuf } */
;;;226        LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;227      }  else {
;;;228        /* first pbuf q equals given pbuf */
;;;229        q = p;
;;;230        if(pbuf_header(q, -IP_HLEN)) {
;;;231          LWIP_ASSERT("Can't restore header we just removed!", 0);
;;;232          return ERR_MEM;
;;;233        }
;;;234      }
;;;235    
;;;236      if ((netif = ip_route(ipaddr)) == NULL) {
;;;237        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;238          ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
;;;239        /* free any temporary header pbuf allocated by pbuf_header() */
;;;240        if (q != p) {
;;;241          pbuf_free(q);
;;;242        }
;;;243        return ERR_RTE;
;;;244      }
;;;245    
;;;246    #if IP_SOF_BROADCAST
;;;247      /* broadcast filter? */
;;;248      if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(ipaddr, netif)) {
;;;249        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;250        /* free any temporary header pbuf allocated by pbuf_header() */
;;;251        if (q != p) {
;;;252          pbuf_free(q);
;;;253        }
;;;254        return ERR_VAL;
;;;255      }
;;;256    #endif /* IP_SOF_BROADCAST */
;;;257    
;;;258      if (ip_addr_isany(&pcb->local_ip)) {
;;;259        /* use outgoing network interface IP address as source address */
;;;260        src_ip = &(netif->ip_addr);
;;;261      } else {
;;;262        /* use RAW PCB local IP address as source address */
;;;263        src_ip = &(pcb->local_ip);
;;;264      }
;;;265    
;;;266      NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;267      err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
;;;268      NETIF_SET_HWADDRHINT(netif, NULL);
;;;269    
;;;270      /* did we chain a header earlier? */
;;;271      if (q != p) {
;;;272        /* free the header */
;;;273        pbuf_free(q);
;;;274      }
;;;275      return err;
;;;276    }
000032  bdfe              POP      {r1-r7,pc}
                  |L8.52|
000034  4635              MOV      r5,r6                 ;229
000036  f06f0113          MVN      r1,#0x13              ;230
00003a  4630              MOV      r0,r6                 ;230
00003c  f7fffffe          BL       pbuf_header
000040  b118              CBZ      r0,|L8.74|
000042  a014              ADR      r0,|L8.148|
000044  f7fffffe          BL       __2printf
                  |L8.72|
000048  e7fe              B        |L8.72|
                  |L8.74|
00004a  4638              MOV      r0,r7                 ;236
00004c  f7fffffe          BL       ip_route
000050  b1a8              CBZ      r0,|L8.126|
000052  b1e4              CBZ      r4,|L8.142|
000054  6821              LDR      r1,[r4,#0]            ;258
000056  b1d1              CBZ      r1,|L8.142|
000058  4621              MOV      r1,r4                 ;263
                  |L8.90|
00005a  7c22              LDRB     r2,[r4,#0x10]         ;267
00005c  7a63              LDRB     r3,[r4,#9]            ;267
00005e  e9cd3200          STRD     r3,r2,[sp,#0]         ;267
000062  9002              STR      r0,[sp,#8]            ;267
000064  7aa3              LDRB     r3,[r4,#0xa]          ;267
000066  463a              MOV      r2,r7                 ;267
000068  4628              MOV      r0,r5                 ;267
00006a  f7fffffe          BL       ip_output_if
00006e  4604              MOV      r4,r0                 ;267
000070  42b5              CMP      r5,r6                 ;271
000072  d002              BEQ      |L8.122|
000074  4628              MOV      r0,r5                 ;273
000076  f7fffffe          BL       pbuf_free
                  |L8.122|
00007a  4620              MOV      r0,r4                 ;275
00007c  bdfe              POP      {r1-r7,pc}
                  |L8.126|
00007e  42b5              CMP      r5,r6                 ;240
000080  d002              BEQ      |L8.136|
000082  4628              MOV      r0,r5                 ;241
000084  f7fffffe          BL       pbuf_free
                  |L8.136|
000088  f06f0003          MVN      r0,#3                 ;243
00008c  bdfe              POP      {r1-r7,pc}
                  |L8.142|
00008e  1d01              ADDS     r1,r0,#4              ;260
000090  e7e3              B        |L8.90|
;;;277    
                          ENDP

000092  0000              DCW      0x0000
                  |L8.148|
000094  43616e27          DCB      "Can't restore header we just removed!",0
000098  74207265
00009c  73746f72
0000a0  65206865
0000a4  61646572
0000a8  20776520
0000ac  6a757374
0000b0  2072656d
0000b4  6f766564
0000b8  2100    
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  raw_pcbs
                          DCD      0x00000000
