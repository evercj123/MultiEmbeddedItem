; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\etharp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\etharp.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\etharp.crf ..\lwip\src\netif\etharp.c]
                          THUMB

                          AREA ||i.etharp_arp_input||, CODE, READONLY, ALIGN=2

                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;689    {
000004  4690              MOV      r8,r2
000006  4689              MOV      r9,r1
000008  0005              MOVS     r5,r0
00000a  d00b              BEQ      |L1.36|
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
00000c  4940              LDR      r1,|L1.272|
00000e  f8b8200a          LDRH     r2,[r8,#0xa]          ;703
;;;708        ETHARP_STATS_INC(etharp.drop);
000012  8bc8              LDRH     r0,[r1,#0x1e]
000014  1c40              ADDS     r0,r0,#1
000016  b280              UXTH     r0,r0
000018  2a2a              CMP      r2,#0x2a              ;703
00001a  d208              BCS      |L1.46|
00001c  8c4a              LDRH     r2,[r1,#0x22]         ;707  ; lwip_stats
00001e  1c52              ADDS     r2,r2,#1              ;707
000020  844a              STRH     r2,[r1,#0x22]         ;707
;;;709        pbuf_free(p);
;;;710        return;
000022  e019              B        |L1.88|
                  |L1.36|
000024  a03b              ADR      r0,|L1.276|
000026  f7fffffe          BL       __2printf
                  |L1.42|
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812        /* request was not directed to us */
;;;813        } else {
;;;814          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;815          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;816        }
;;;817        break;
;;;818      case PP_HTONS(ARP_REPLY):
;;;819        /* ARP reply. We already updated the ARP cache earlier. */
;;;820        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;821    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;822        /* DHCP wants to know about ARP replies from any host with an
;;;823         * IP address also offered to us by the DHCP server. We do not
;;;824         * want to take a duplicate IP address on a single network.
;;;825         * @todo How should we handle redundant (fail-over) interfaces? */
;;;826        dhcp_arp_reply(netif, &sipaddr);
;;;827    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;828        break;
;;;829      default:
;;;830        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;831        ETHARP_STATS_INC(etharp.err);
;;;832        break;
;;;833      }
;;;834      /* free ARP packet */
;;;835      pbuf_free(p);
;;;836    }
00002a  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.46|
00002e  f8d86004          LDR      r6,[r8,#4]            ;714
000032  f44f7b80          MOV      r11,#0x100            ;722
000036  4634              MOV      r4,r6                 ;714
000038  f8342f0e          LDRH     r2,[r4,#0xe]!         ;722
00003c  455a              CMP      r2,r11                ;722
00003e  d108              BNE      |L1.82|
000040  7922              LDRB     r2,[r4,#4]            ;723
000042  2a06              CMP      r2,#6                 ;723
000044  d105              BNE      |L1.82|
000046  7962              LDRB     r2,[r4,#5]            ;724
000048  2a04              CMP      r2,#4                 ;724
00004a  d102              BNE      |L1.82|
00004c  8862              LDRH     r2,[r4,#2]            ;725
00004e  2a08              CMP      r2,#8                 ;725
000050  d004              BEQ      |L1.92|
                  |L1.82|
000052  8d0a              LDRH     r2,[r1,#0x28]         ;729  ; lwip_stats
000054  1c52              ADDS     r2,r2,#1              ;729
000056  850a              STRH     r2,[r1,#0x28]         ;729
                  |L1.88|
000058  83c8              STRH     r0,[r1,#0x1e]         ;708
00005a  e026              B        |L1.170|
                  |L1.92|
00005c  468a              MOV      r10,r1                ;734
00005e  8b49              LDRH     r1,[r1,#0x1a]         ;734  ; lwip_stats
000060  1c49              ADDS     r1,r1,#1              ;734
000062  f8aa101a          STRH     r1,[r10,#0x1a]        ;734
000066  f8d4000e          LDR      r0,[r4,#0xe]          ;745
00006a  9000              STR      r0,[sp,#0]            ;746
00006c  69a1              LDR      r1,[r4,#0x18]         ;746
00006e  1d28              ADDS     r0,r5,#4              ;749
000070  d005              BEQ      |L1.126|
000072  6868              LDR      r0,[r5,#4]            ;749
000074  b118              CBZ      r0,|L1.126|
000076  4281              CMP      r1,r0                 ;753
000078  d101              BNE      |L1.126|
00007a  2701              MOVS     r7,#1                 ;753
00007c  e000              B        |L1.128|
                  |L1.126|
00007e  2700              MOVS     r7,#0                 ;753
                  |L1.128|
000080  b10f              CBZ      r7,|L1.134|
000082  2301              MOVS     r3,#1                 ;762
000084  e000              B        |L1.136|
                  |L1.134|
000086  2302              MOVS     r3,#2                 ;762
                  |L1.136|
000088  f1040208          ADD      r2,r4,#8              ;762
00008c  4669              MOV      r1,sp                 ;762
00008e  4628              MOV      r0,r5                 ;762
000090  f7fffffe          BL       etharp_update_arp_entry
000094  88e0              LDRH     r0,[r4,#6]            ;765
000096  4558              CMP      r0,r11                ;765
000098  d00b              BEQ      |L1.178|
00009a  f5b07f00          CMP      r0,#0x200             ;765
00009e  d004              BEQ      |L1.170|
0000a0  f8ba102c          LDRH     r1,[r10,#0x2c]        ;831  ; lwip_stats
0000a4  1c49              ADDS     r1,r1,#1              ;831
0000a6  f8aa102c          STRH     r1,[r10,#0x2c]        ;831
                  |L1.170|
0000aa  4640              MOV      r0,r8                 ;835
0000ac  f7fffffe          BL       pbuf_free
0000b0  e7bb              B        |L1.42|
                  |L1.178|
0000b2  2f00              CMP      r7,#0                 ;774
0000b4  d0f9              BEQ      |L1.170|
0000b6  2002              MOVS     r0,#2                 ;780
0000b8  f7fffffe          BL       lwip_htons
0000bc  80e0              STRH     r0,[r4,#6]            ;780
0000be  f8d4000e          LDR      r0,[r4,#0xe]          ;782
0000c2  61a0              STR      r0,[r4,#0x18]         ;782
0000c4  6868              LDR      r0,[r5,#4]            ;783
0000c6  f8c4000e          STR      r0,[r4,#0xe]          ;783
0000ca  f8950022          LDRB     r0,[r5,#0x22]         ;785
0000ce  2806              CMP      r0,#6                 ;785
0000d0  d003              BEQ      |L1.218|
0000d2  4814              LDR      r0,|L1.292|
0000d4  f7fffffe          BL       __2printf
                  |L1.216|
0000d8  e7fe              B        |L1.216|
                  |L1.218|
0000da  68a0              LDR      r0,[r4,#8]            ;794
0000dc  f8c40012          STR      r0,[r4,#0x12]         ;794
0000e0  89a0              LDRH     r0,[r4,#0xc]          ;794
0000e2  82e0              STRH     r0,[r4,#0x16]         ;794
0000e4  68a0              LDR      r0,[r4,#8]            ;798
0000e6  6030              STR      r0,[r6,#0]            ;798
0000e8  89a0              LDRH     r0,[r4,#0xc]          ;798
0000ea  80b0              STRH     r0,[r6,#4]            ;798
0000ec  f8d91000          LDR      r1,[r9,#0]            ;800
0000f0  60a1              STR      r1,[r4,#8]            ;800
0000f2  f8b90004          LDRH     r0,[r9,#4]            ;800
0000f6  81a0              STRH     r0,[r4,#0xc]          ;800
0000f8  f8d91000          LDR      r1,[r9,#0]            ;801
0000fc  f8c61006          STR      r1,[r6,#6]            ;801
000100  f8b90004          LDRH     r0,[r9,#4]            ;801
000104  8170              STRH     r0,[r6,#0xa]          ;801
000106  69aa              LDR      r2,[r5,#0x18]         ;807
000108  4641              MOV      r1,r8                 ;807
00010a  4628              MOV      r0,r5                 ;807
00010c  4790              BLX      r2                    ;807
00010e  e7cc              B        |L1.170|
;;;837    
                          ENDP

                  |L1.272|
                          DCD      lwip_stats
                  |L1.276|
000114  6e657469          DCB      "netif != NULL",0
000118  6620213d
00011c  204e554c
000120  4c00    
000122  00                DCB      0
000123  00                DCB      0
                  |L1.292|
                          DCD      ||.conststring||

                          AREA ||i.etharp_cleanup_netif||, CODE, READONLY, ALIGN=2

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;584        u8_t state = arp_table[i].state;
000002  4e0a              LDR      r6,|L2.44|
000004  4605              MOV      r5,r0                 ;580
000006  2400              MOVS     r4,#0                 ;583
                  |L2.8|
000008  eb040084          ADD      r0,r4,r4,LSL #2
00000c  eb060080          ADD      r0,r6,r0,LSL #2
000010  7c81              LDRB     r1,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
000012  b129              CBZ      r1,|L2.32|
000014  6880              LDR      r0,[r0,#8]
000016  42a8              CMP      r0,r5
000018  d102              BNE      |L2.32|
;;;586          etharp_free_entry(i);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       etharp_free_entry
                  |L2.32|
000020  1c64              ADDS     r4,r4,#1
000022  b2e4              UXTB     r4,r4                 ;583
000024  2c0a              CMP      r4,#0xa               ;583
000026  d3ef              BCC      |L2.8|
;;;587        }
;;;588      }
;;;589    }
000028  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      ||.bss||

                          AREA ||i.etharp_find_addr||, CODE, READONLY, ALIGN=2

                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
000000  b570              PUSH     {r4-r6,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
000002  461c              MOV      r4,r3
000004  0015              MOVS     r5,r2
000006  4608              MOV      r0,r1
000008  d013              BEQ      |L3.50|
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
00000a  b194              CBZ      r4,|L3.50|
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
00000c  2102              MOVS     r1,#2
00000e  f7fffffe          BL       etharp_find_entry
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
000012  2800              CMP      r0,#0
000014  db11              BLT      |L3.58|
000016  490a              LDR      r1,|L3.64|
000018  eb000280          ADD      r2,r0,r0,LSL #2
00001c  eb010182          ADD      r1,r1,r2,LSL #2
000020  7c8a              LDRB     r2,[r1,#0x12]
000022  2a02              CMP      r2,#2
000024  d309              BCC      |L3.58|
;;;615          *eth_ret = &arp_table[i].ethaddr;
000026  f101020c          ADD      r2,r1,#0xc
00002a  1d09              ADDS     r1,r1,#4
;;;616          *ip_ret = &arp_table[i].ipaddr;
00002c  602a              STR      r2,[r5,#0]
;;;617          return i;
00002e  6021              STR      r1,[r4,#0]
;;;618      }
;;;619      return -1;
;;;620    }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  a004              ADR      r0,|L3.68|
000034  f7fffffe          BL       __2printf
                  |L3.56|
000038  e7fe              B        |L3.56|
                  |L3.58|
00003a  f04f30ff          MOV      r0,#0xffffffff        ;619
00003e  bd70              POP      {r4-r6,pc}
;;;621    
                          ENDP

                  |L3.64|
                          DCD      ||.bss||
                  |L3.68|
000044  6574685f          DCB      "eth_ret != NULL && ip_ret != NULL",0
000048  72657420
00004c  213d204e
000050  554c4c20
000054  26262069
000058  705f7265
00005c  7420213d
000060  204e554c
000064  4c00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.etharp_find_entry||, CODE, READONLY, ALIGN=2

                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
000000  e92d5ff3          PUSH     {r0,r1,r4-r12,lr}
;;;267    {
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
000004  f04f0b0a          MOV      r11,#0xa
;;;269      s8_t empty = ARP_TABLE_SIZE;
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
000008  2100              MOVS     r1,#0
00000a  4604              MOV      r4,r0                 ;267
00000c  46da              MOV      r10,r11               ;268
00000e  4658              MOV      r0,r11                ;269
000010  4688              MOV      r8,r1
000012  468c              MOV      r12,r1
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
000014  46d9              MOV      r9,r11
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
000016  460f              MOV      r7,r1
                  |L4.24|
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;292        u8_t state = arp_table[i].state;
000018  4b42              LDR      r3,|L4.292|
00001a  eb010e81          ADD      lr,r1,r1,LSL #2
00001e  eb03038e          ADD      r3,r3,lr,LSL #2
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
000022  280a              CMP      r0,#0xa
000024  7c9a              LDRB     r2,[r3,#0x12]         ;292
000026  d008              BEQ      |L4.58|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
;;;296          /* remember first empty entry */
;;;297          empty = i;
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
000028  b1ea              CBZ      r2,|L4.102|
                  |L4.42|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
00002a  2a01              CMP      r2,#1
00002c  d009              BEQ      |L4.66|
00002e  2a02              CMP      r2,#2
000030  d207              BCS      |L4.66|
000032  a03d              ADR      r0,|L4.296|
000034  f7fffffe          BL       __2printf
                  |L4.56|
000038  e7fe              B        |L4.56|
                  |L4.58|
00003a  2a00              CMP      r2,#0                 ;294
00003c  d1f5              BNE      |L4.42|
00003e  b248              SXTB     r0,r1                 ;297
000040  e011              B        |L4.102|
                  |L4.66|
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
000042  b134              CBZ      r4,|L4.82|
000044  6825              LDR      r5,[r4,#0]
000046  685e              LDR      r6,[r3,#4]
000048  42b5              CMP      r5,r6
00004a  d102              BNE      |L4.82|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
00004c  b248              SXTB     r0,r1
                  |L4.78|
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
00004e  e8bd9ffc          POP      {r2-r12,pc}
                  |L4.82|
000052  2a01              CMP      r2,#1                 ;308
000054  d01a              BEQ      |L4.140|
000056  2a02              CMP      r2,#2                 ;324
000058  d305              BCC      |L4.102|
00005a  7cda              LDRB     r2,[r3,#0x13]         ;331
00005c  4562              CMP      r2,r12                ;331
00005e  d302              BCC      |L4.102|
000060  fa4ffa81          SXTB     r10,r1                ;332
000064  4694              MOV      r12,r2                ;333
                  |L4.102|
000066  1c49              ADDS     r1,r1,#1              ;333
000068  b2c9              UXTB     r1,r1                 ;291
00006a  290a              CMP      r1,#0xa               ;291
00006c  d3d4              BCC      |L4.24|
00006e  9901              LDR      r1,[sp,#4]            ;342
000070  f04f32ff          MOV      r2,#0xffffffff        ;346
000074  0789              LSLS     r1,r1,#30             ;342
000076  d43e              BMI      |L4.246|
000078  280a              CMP      r0,#0xa               ;344
00007a  d019              BEQ      |L4.176|
00007c  da1b              BGE      |L4.182|
00007e  b2c5              UXTB     r5,r0                 ;360
000080  2d0a              CMP      r5,#0xa               ;391
000082  d33d              BCC      |L4.256|
000084  a038              ADR      r0,|L4.360|
000086  f7fffffe          BL       __2printf
                  |L4.138|
00008a  e7fe              B        |L4.138|
                  |L4.140|
00008c  4a25              LDR      r2,|L4.292|
00008e  f852202e          LDR      r2,[r2,lr,LSL #2]     ;310
000092  b132              CBZ      r2,|L4.162|
000094  7cde              LDRB     r6,[r3,#0x13]         ;311
000096  42be              CMP      r6,r7                 ;311
000098  d3e5              BCC      |L4.102|
00009a  fa4ff981          SXTB     r9,r1                 ;312
00009e  4637              MOV      r7,r6                 ;313
0000a0  e7e1              B        |L4.102|
                  |L4.162|
0000a2  7cdd              LDRB     r5,[r3,#0x13]         ;318
0000a4  4545              CMP      r5,r8                 ;318
0000a6  d3de              BCC      |L4.102|
0000a8  fa4ffb81          SXTB     r11,r1                ;319
0000ac  46a8              MOV      r8,r5                 ;320
0000ae  e7da              B        |L4.102|
                  |L4.176|
0000b0  9801              LDR      r0,[sp,#4]            ;344
0000b2  07c0              LSLS     r0,r0,#31             ;344
0000b4  d01f              BEQ      |L4.246|
                  |L4.182|
0000b6  f1ba0f0a          CMP      r10,#0xa              ;364
0000ba  da0b              BGE      |L4.212|
0000bc  f00a05ff          AND      r5,r10,#0xff          ;366
0000c0  4818              LDR      r0,|L4.292|
0000c2  eb050185          ADD      r1,r5,r5,LSL #2       ;369
0000c6  f8500021          LDR      r0,[r0,r1,LSL #2]     ;369
0000ca  b170              CBZ      r0,|L4.234|
0000cc  a02b              ADR      r0,|L4.380|
0000ce  f7fffffe          BL       __2printf
                  |L4.210|
0000d2  e7fe              B        |L4.210|
                  |L4.212|
0000d4  f1bb0f0a          CMP      r11,#0xa              ;371
0000d8  da02              BGE      |L4.224|
0000da  f00b05ff          AND      r5,r11,#0xff          ;373
0000de  e004              B        |L4.234|
                  |L4.224|
0000e0  f1b90f0a          CMP      r9,#0xa               ;376
0000e4  da07              BGE      |L4.246|
0000e6  f00905ff          AND      r5,r9,#0xff           ;378
                  |L4.234|
0000ea  2d0a              CMP      r5,#0xa               ;387
0000ec  d305              BCC      |L4.250|
0000ee  a01e              ADR      r0,|L4.360|
0000f0  f7fffffe          BL       __2printf
                  |L4.244|
0000f4  e7fe              B        |L4.244|
                  |L4.246|
0000f6  4610              MOV      r0,r2                 ;383
0000f8  e7a9              B        |L4.78|
                  |L4.250|
0000fa  4628              MOV      r0,r5                 ;388
0000fc  f7fffffe          BL       etharp_free_entry
                  |L4.256|
000100  4808              LDR      r0,|L4.292|
000102  eb050185          ADD      r1,r5,r5,LSL #2       ;392
000106  eb000081          ADD      r0,r0,r1,LSL #2       ;392
00010a  7c81              LDRB     r1,[r0,#0x12]         ;392
00010c  b119              CBZ      r1,|L4.278|
00010e  a021              ADR      r0,|L4.404|
000110  f7fffffe          BL       __2printf
                  |L4.276|
000114  e7fe              B        |L4.276|
                  |L4.278|
000116  b10c              CBZ      r4,|L4.284|
000118  6821              LDR      r1,[r4,#0]            ;398
00011a  6041              STR      r1,[r0,#4]            ;398
                  |L4.284|
00011c  2100              MOVS     r1,#0                 ;400
00011e  74c1              STRB     r1,[r0,#0x13]         ;400
000120  b268              SXTB     r0,r5                 ;401
000122  e794              B        |L4.78|
;;;403    
                          ENDP

                  |L4.292|
                          DCD      ||.bss||
                  |L4.296|
000128  73746174          DCB      "state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_"
00012c  65203d3d
000130  20455448
000134  4152505f
000138  53544154
00013c  455f5045
000140  4e44494e
000144  47207c7c
000148  20737461
00014c  7465203e
000150  3d204554
000154  48415250
000158  5f535441
00015c  54455f  
00015f  53544142          DCB      "STABLE",0
000163  4c4500  
000166  00                DCB      0
000167  00                DCB      0
                  |L4.360|
000168  69203c20          DCB      "i < ARP_TABLE_SIZE",0
00016c  4152505f
000170  5441424c
000174  455f5349
000178  5a4500  
00017b  00                DCB      0
                  |L4.380|
00017c  6172705f          DCB      "arp_table[i].q == NULL",0
000180  7461626c
000184  655b695d
000188  2e71203d
00018c  3d204e55
000190  4c4c00  
000193  00                DCB      0
                  |L4.404|
000194  6172705f          DCB      "arp_table[i].state == ETHARP_STATE_EMPTY",0
000198  7461626c
00019c  655b695d
0001a0  2e737461
0001a4  7465203d
0001a8  3d204554
0001ac  48415250
0001b0  5f535441
0001b4  54455f45
0001b8  4d505459
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||i.etharp_free_entry||, CODE, READONLY, ALIGN=2

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
000002  4e0c              LDR      r6,|L5.52|
000004  eb000480          ADD      r4,r0,r0,LSL #2
000008  2500              MOVS     r5,#0
00000a  f8560024          LDR      r0,[r6,r4,LSL #2]
00000e  b118              CBZ      r0,|L5.24|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;185        free_etharp_q(arp_table[i].q);
000010  f7fffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
000014  f8465024          STR      r5,[r6,r4,LSL #2]
                  |L5.24|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
000018  eb060084          ADD      r0,r6,r4,LSL #2
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
;;;193      arp_table[i].netif = NULL;
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
;;;195      arp_table[i].ethaddr = ethzero;
00001c  4906              LDR      r1,|L5.56|
00001e  7485              STRB     r5,[r0,#0x12]         ;189
000020  74c5              STRB     r5,[r0,#0x13]         ;192
000022  6085              STR      r5,[r0,#8]            ;194
000024  6045              STR      r5,[r0,#4]
000026  f8d12006          LDR      r2,[r1,#6]  ; ethzero
00002a  60c2              STR      r2,[r0,#0xc]
00002c  8949              LDRH     r1,[r1,#0xa]  ; ethzero
00002e  8201              STRH     r1,[r0,#0x10]
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
000030  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      ||.bss||
                  |L5.56|
                          DCD      ||.constdata||

                          AREA ||i.etharp_output||, CODE, READONLY, ALIGN=2

                  etharp_output PROC
;;;878    err_t
;;;879    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;880    {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  0004              MOVS     r4,r0
00000a  d00e              BEQ      |L6.42|
;;;881      struct eth_addr *dest;
;;;882      struct eth_addr mcastaddr;
;;;883      ip_addr_t *dst_addr = ipaddr;
;;;884    
;;;885      LWIP_ASSERT("netif != NULL", netif != NULL);
;;;886      LWIP_ASSERT("q != NULL", q != NULL);
00000c  b18e              CBZ      r6,|L6.50|
;;;887      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
00000e  b1a5              CBZ      r5,|L6.58|
;;;888    
;;;889      /* make room for Ethernet header - should not fail */
;;;890      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
000010  210e              MOVS     r1,#0xe
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pbuf_header
;;;891        /* bail out */
;;;892        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;893          ("etharp_output: could not allocate room for header.\n"));
;;;894        LINK_STATS_INC(link.lenerr);
000018  4f43              LDR      r7,|L6.296|
00001a  b190              CBZ      r0,|L6.66|
00001c  8978              LDRH     r0,[r7,#0xa]  ; lwip_stats
00001e  1c40              ADDS     r0,r0,#1
000020  8178              STRH     r0,[r7,#0xa]
;;;895        return ERR_BUF;
000022  f06f0001          MVN      r0,#1
                  |L6.38|
;;;896      }
;;;897    
;;;898      /* Determine on destination hardware address. Broadcasts and multicasts
;;;899       * are special, other IP addresses are looked up in the ARP table. */
;;;900    
;;;901      /* broadcast destination IP address? */
;;;902      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;903        /* broadcast on Ethernet also */
;;;904        dest = (struct eth_addr *)&ethbroadcast;
;;;905      /* multicast destination IP address? */
;;;906      } else if (ip_addr_ismulticast(ipaddr)) {
;;;907        /* Hash IP multicast address to MAC address.*/
;;;908        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;909        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;910        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;911        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;912        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;913        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;914        /* destination Ethernet address is multicast */
;;;915        dest = &mcastaddr;
;;;916      /* unicast destination IP address? */
;;;917      } else {
;;;918        s8_t i;
;;;919        /* outside local network? if so, this can neither be a global broadcast nor
;;;920           a subnet broadcast. */
;;;921        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
;;;922            !ip_addr_islinklocal(ipaddr)) {
;;;923    #if LWIP_AUTOIP
;;;924          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;925            sizeof(struct eth_hdr));
;;;926          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;927             a link-local source address must always be "directly to its destination
;;;928             on the same physical link. The host MUST NOT send the packet to any
;;;929             router for forwarding". */
;;;930          if (!ip_addr_islinklocal(&iphdr->src))
;;;931    #endif /* LWIP_AUTOIP */
;;;932          {
;;;933            /* interface has default gateway? */
;;;934            if (!ip_addr_isany(&netif->gw)) {
;;;935              /* send to hardware address of default gateway IP address */
;;;936              dst_addr = &(netif->gw);
;;;937            /* no default gateway available */
;;;938            } else {
;;;939              /* no route to destination error (default gateway missing) */
;;;940              return ERR_RTE;
;;;941            }
;;;942          }
;;;943        }
;;;944    #if LWIP_NETIF_HWADDRHINT
;;;945        if (netif->addr_hint != NULL) {
;;;946          /* per-pcb cached entry was given */
;;;947          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;948          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;949    #endif /* LWIP_NETIF_HWADDRHINT */
;;;950            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
;;;951                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
;;;952              /* the per-pcb-cached entry is stable and the right one! */
;;;953              ETHARP_STATS_INC(etharp.cachehit);
;;;954              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;955            }
;;;956    #if LWIP_NETIF_HWADDRHINT
;;;957          }
;;;958        }
;;;959    #endif /* LWIP_NETIF_HWADDRHINT */
;;;960    
;;;961        /* find stable entry: do this here since this is a critical path for
;;;962           throughput and etharp_find_entry() is kind of slow */
;;;963        for (i = 0; i < ARP_TABLE_SIZE; i++) {
;;;964          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;965              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;966            /* found an existing, stable entry */
;;;967            ETHARP_SET_HINT(netif, i);
;;;968            return etharp_output_to_arp_index(netif, q, i);
;;;969          }
;;;970        }
;;;971        /* no stable entry found, use the (slower) query function:
;;;972           queue on destination Ethernet address belonging to ipaddr */
;;;973        return etharp_query(netif, dst_addr, q);
;;;974      }
;;;975    
;;;976      /* continuation for multicast/broadcast destinations */
;;;977      /* obtain source Ethernet address of the given interface */
;;;978      /* send packet directly on the link */
;;;979      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;980    }
000026  e8bd81fc          POP      {r2-r8,pc}
                  |L6.42|
00002a  a040              ADR      r0,|L6.300|
00002c  f7fffffe          BL       __2printf
                  |L6.48|
000030  e7fe              B        |L6.48|
                  |L6.50|
000032  a042              ADR      r0,|L6.316|
000034  f7fffffe          BL       __2printf
                  |L6.56|
000038  e7fe              B        |L6.56|
                  |L6.58|
00003a  a043              ADR      r0,|L6.328|
00003c  f7fffffe          BL       __2printf
                  |L6.64|
000040  e7fe              B        |L6.64|
                  |L6.66|
000042  4621              MOV      r1,r4                 ;902
000044  6828              LDR      r0,[r5,#0]            ;902
000046  f7fffffe          BL       ip4_addr_isbroadcast
00004a  b108              CBZ      r0,|L6.80|
00004c  4b42              LDR      r3,|L6.344|
00004e  e042              B        |L6.214|
                  |L6.80|
000050  6828              LDR      r0,[r5,#0]            ;906
000052  f3c01103          UBFX     r1,r0,#4,#4           ;906
000056  290e              CMP      r1,#0xe               ;906
000058  d028              BEQ      |L6.172|
00005a  68a1              LDR      r1,[r4,#8]            ;921
00005c  6863              LDR      r3,[r4,#4]            ;921
00005e  ea000201          AND      r2,r0,r1              ;921
000062  400b              ANDS     r3,r3,r1              ;921
000064  429a              CMP      r2,r3                 ;921
000066  d00b              BEQ      |L6.128|
000068  b280              UXTH     r0,r0                 ;922
00006a  f5a0417e          SUB      r1,r0,#0xfe00         ;922
00006e  39a9              SUBS     r1,r1,#0xa9           ;922
000070  d006              BEQ      |L6.128|
000072  f1140f0c          CMN      r4,#0xc               ;934
000076  d036              BEQ      |L6.230|
000078  68e0              LDR      r0,[r4,#0xc]          ;934
00007a  b398              CBZ      r0,|L6.228|
00007c  f104050c          ADD      r5,r4,#0xc            ;936
                  |L6.128|
000080  4b36              LDR      r3,|L6.348|
000082  4a37              LDR      r2,|L6.352|
000084  7818              LDRB     r0,[r3,#0]            ;950  ; etharp_cached_entry
000086  eb000180          ADD      r1,r0,r0,LSL #2       ;950
00008a  eb020181          ADD      r1,r2,r1,LSL #2       ;950
00008e  f891c012          LDRB     r12,[r1,#0x12]        ;950
000092  f1bc0f02          CMP      r12,#2                ;950
000096  d329              BCC      |L6.236|
000098  f8d5c000          LDR      r12,[r5,#0]           ;951
00009c  6849              LDR      r1,[r1,#4]            ;951
00009e  458c              CMP      r12,r1                ;951
0000a0  d124              BNE      |L6.236|
0000a2  8df9              LDRH     r1,[r7,#0x2e]         ;953  ; lwip_stats
0000a4  4602              MOV      r2,r0                 ;953
0000a6  1c49              ADDS     r1,r1,#1              ;953
0000a8  85f9              STRH     r1,[r7,#0x2e]         ;953
0000aa  e02d              B        |L6.264|
                  |L6.172|
0000ac  2001              MOVS     r0,#1                 ;908
0000ae  f88d0000          STRB     r0,[sp,#0]            ;908
0000b2  2000              MOVS     r0,#0                 ;909
0000b4  f88d0001          STRB     r0,[sp,#1]            ;909
0000b8  205e              MOVS     r0,#0x5e              ;910
0000ba  f88d0002          STRB     r0,[sp,#2]            ;910
0000be  7868              LDRB     r0,[r5,#1]            ;911
0000c0  466b              MOV      r3,sp                 ;915
0000c2  f000007f          AND      r0,r0,#0x7f           ;911
0000c6  f88d0003          STRB     r0,[sp,#3]            ;911
0000ca  78a8              LDRB     r0,[r5,#2]            ;912
0000cc  f88d0004          STRB     r0,[sp,#4]            ;912
0000d0  78e8              LDRB     r0,[r5,#3]            ;913
0000d2  f88d0005          STRB     r0,[sp,#5]            ;913
                  |L6.214|
0000d6  f1040223          ADD      r2,r4,#0x23           ;979
0000da  4631              MOV      r1,r6                 ;979
0000dc  4620              MOV      r0,r4                 ;979
0000de  f7fffffe          BL       etharp_send_ip
0000e2  e7a0              B        |L6.38|
                  |L6.228|
0000e4  e7ff              B        |L6.230|
                  |L6.230|
0000e6  f06f0003          MVN      r0,#3                 ;940
0000ea  e79c              B        |L6.38|
                  |L6.236|
0000ec  2000              MOVS     r0,#0                 ;963
                  |L6.238|
0000ee  eb000180          ADD      r1,r0,r0,LSL #2       ;964
0000f2  eb020181          ADD      r1,r2,r1,LSL #2       ;964
0000f6  7c8f              LDRB     r7,[r1,#0x12]         ;964
0000f8  2f02              CMP      r7,#2                 ;964
0000fa  d30a              BCC      |L6.274|
0000fc  682f              LDR      r7,[r5,#0]            ;965
0000fe  6849              LDR      r1,[r1,#4]            ;965
000100  428f              CMP      r7,r1                 ;965
000102  d106              BNE      |L6.274|
000104  b2c2              UXTB     r2,r0                 ;967
000106  701a              STRB     r2,[r3,#0]            ;967
                  |L6.264|
000108  4631              MOV      r1,r6                 ;968
00010a  4620              MOV      r0,r4                 ;968
00010c  f7fffffe          BL       etharp_output_to_arp_index
000110  e789              B        |L6.38|
                  |L6.274|
000112  1c40              ADDS     r0,r0,#1
000114  b240              SXTB     r0,r0                 ;963
000116  280a              CMP      r0,#0xa               ;963
000118  dbe9              BLT      |L6.238|
00011a  4632              MOV      r2,r6                 ;973
00011c  4629              MOV      r1,r5                 ;973
00011e  4620              MOV      r0,r4                 ;973
000120  f7fffffe          BL       etharp_query
000124  e77f              B        |L6.38|
;;;981    
                          ENDP

000126  0000              DCW      0x0000
                  |L6.296|
                          DCD      lwip_stats
                  |L6.300|
00012c  6e657469          DCB      "netif != NULL",0
000130  6620213d
000134  204e554c
000138  4c00    
00013a  00                DCB      0
00013b  00                DCB      0
                  |L6.316|
00013c  7120213d          DCB      "q != NULL",0
000140  204e554c
000144  4c00    
000146  00                DCB      0
000147  00                DCB      0
                  |L6.328|
000148  69706164          DCB      "ipaddr != NULL",0
00014c  64722021
000150  3d204e55
000154  4c4c00  
000157  00                DCB      0
                  |L6.344|
                          DCD      ||.constdata||
                  |L6.348|
                          DCD      ||.data||
                  |L6.352|
                          DCD      ||.bss||

                          AREA ||i.etharp_output_to_arp_index||, CODE, READONLY, ALIGN=2

                  etharp_output_to_arp_index PROC
;;;841    static err_t
;;;842    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;843    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;844      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
000006  4810              LDR      r0,|L7.72|
000008  eb020182          ADD      r1,r2,r2,LSL #2
00000c  eb000481          ADD      r4,r0,r1,LSL #2
000010  7ca0              LDRB     r0,[r4,#0x12]
000012  2802              CMP      r0,#2
000014  d203              BCS      |L7.30|
000016  a00d              ADR      r0,|L7.76|
000018  f7fffffe          BL       __2printf
                  |L7.28|
00001c  e7fe              B        |L7.28|
                  |L7.30|
;;;845                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;846      /* if arp table entry is about to expire: re-request it,
;;;847         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;848         network with ARP requests if this address is used frequently. */
;;;849      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
00001e  d109              BNE      |L7.52|
;;;850          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
000020  7ce0              LDRB     r0,[r4,#0x13]
000022  28e4              CMP      r0,#0xe4
000024  d306              BCC      |L7.52|
;;;851        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
000026  1d21              ADDS     r1,r4,#4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       etharp_request
00002e  b908              CBNZ     r0,|L7.52|
;;;852          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
000030  2003              MOVS     r0,#3
000032  74a0              STRB     r0,[r4,#0x12]
                  |L7.52|
;;;853        }
;;;854      }
;;;855      
;;;856      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
000034  f104030c          ADD      r3,r4,#0xc
000038  f1050223          ADD      r2,r5,#0x23
00003c  4631              MOV      r1,r6
00003e  4628              MOV      r0,r5
000040  e8bd4070          POP      {r4-r6,lr}
000044  f7ffbffe          B.W      etharp_send_ip
;;;857        &arp_table[arp_idx].ethaddr);
;;;858    }
;;;859    
                          ENDP

                  |L7.72|
                          DCD      ||.bss||
                  |L7.76|
00004c  6172705f          DCB      "arp_table[arp_idx].state >= ETHARP_STATE_STABLE",0
000050  7461626c
000054  655b6172
000058  705f6964
00005c  785d2e73
000060  74617465
000064  203e3d20
000068  45544841
00006c  52505f53
000070  54415445
000074  5f535441
000078  424c4500

                          AREA ||i.etharp_query||, CODE, READONLY, ALIGN=2

                  etharp_query PROC
;;;1015   err_t
;;;1016   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1017   {
000004  b082              SUB      sp,sp,#8
000006  460e              MOV      r6,r1
;;;1018     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
000008  9802              LDR      r0,[sp,#8]
00000a  4615              MOV      r5,r2                 ;1017
00000c  3023              ADDS     r0,r0,#0x23
;;;1019     err_t result = ERR_MEM;
;;;1020     s8_t i; /* ARP entry index */
;;;1021   
;;;1022     /* non-unicast address? */
;;;1023     if (ip_addr_isbroadcast(ipaddr, netif) ||
00000e  9000              STR      r0,[sp,#0]
000010  6808              LDR      r0,[r1,#0]
000012  f04f3bff          MOV      r11,#0xffffffff       ;1019
000016  9902              LDR      r1,[sp,#8]
000018  f7fffffe          BL       ip4_addr_isbroadcast
00001c  b9c0              CBNZ     r0,|L8.80|
;;;1024         ip_addr_ismulticast(ipaddr) ||
00001e  6830              LDR      r0,[r6,#0]
000020  f3c01103          UBFX     r1,r0,#4,#4
000024  290e              CMP      r1,#0xe
000026  d013              BEQ      |L8.80|
;;;1025         ip_addr_isany(ipaddr)) {
000028  b196              CBZ      r6,|L8.80|
00002a  b188              CBZ      r0,|L8.80|
;;;1026       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
;;;1027       return ERR_ARG;
;;;1028     }
;;;1029   
;;;1030     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1031     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
00002c  2101              MOVS     r1,#1
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       etharp_find_entry
;;;1032   
;;;1033     /* could not find or create entry? */
;;;1034     if (i < 0) {
;;;1035       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1036       if (q) {
;;;1037         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1038         ETHARP_STATS_INC(etharp.memerr);
000034  f8dfa0e4          LDR      r10,|L8.284|
000038  0004              MOVS     r4,r0                 ;1031
00003a  d50c              BPL      |L8.86|
00003c  b125              CBZ      r5,|L8.72|
00003e  f8ba0024          LDRH     r0,[r10,#0x24]  ; lwip_stats
000042  1c40              ADDS     r0,r0,#1
000044  f8aa0024          STRH     r0,[r10,#0x24]
                  |L8.72|
;;;1039       }
;;;1040       return (err_t)i;
000048  4620              MOV      r0,r4
                  |L8.74|
;;;1041     }
;;;1042   
;;;1043     /* mark a fresh entry as pending (we just sent a request) */
;;;1044     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
;;;1045       arp_table[i].state = ETHARP_STATE_PENDING;
;;;1046     }
;;;1047   
;;;1048     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1049     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
;;;1050     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1051      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1052   
;;;1053     /* do we have a pending entry? or an implicit query request? */
;;;1054     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
;;;1055       /* try to resolve it; send out ARP request */
;;;1056       result = etharp_request(netif, ipaddr);
;;;1057       if (result != ERR_OK) {
;;;1058         /* ARP request couldn't be sent */
;;;1059         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1060            since this failure could be temporary, and the next packet calling
;;;1061            etharp_query again could lead to sending the queued packets. */
;;;1062       }
;;;1063       if (q == NULL) {
;;;1064         return result;
;;;1065       }
;;;1066     }
;;;1067   
;;;1068     /* packet given? */
;;;1069     LWIP_ASSERT("q != NULL", q != NULL);
;;;1070     /* stable entry? */
;;;1071     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1072       /* we have a valid IP->Ethernet address mapping */
;;;1073       ETHARP_SET_HINT(netif, i);
;;;1074       /* send the packet */
;;;1075       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1076     /* pending entry? (either just created or already pending */
;;;1077     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1078       /* entry is still pending, queue the given packet 'q' */
;;;1079       struct pbuf *p;
;;;1080       int copy_needed = 0;
;;;1081       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1082        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1083        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1084       p = q;
;;;1085       while (p) {
;;;1086         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1087         if(p->type != PBUF_ROM) {
;;;1088           copy_needed = 1;
;;;1089           break;
;;;1090         }
;;;1091         p = p->next;
;;;1092       }
;;;1093       if(copy_needed) {
;;;1094         /* copy the whole packet into new pbufs */
;;;1095         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1096         if(p != NULL) {
;;;1097           if (pbuf_copy(p, q) != ERR_OK) {
;;;1098             pbuf_free(p);
;;;1099             p = NULL;
;;;1100           }
;;;1101         }
;;;1102       } else {
;;;1103         /* referencing the old pbuf is enough */
;;;1104         p = q;
;;;1105         pbuf_ref(p);
;;;1106       }
;;;1107       /* packet could be taken over? */
;;;1108       if (p != NULL) {
;;;1109         /* queue packet ... */
;;;1110   #if ARP_QUEUEING
;;;1111         struct etharp_q_entry *new_entry;
;;;1112         /* allocate a new arp queue entry */
;;;1113         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1114         if (new_entry != NULL) {
;;;1115           new_entry->next = 0;
;;;1116           new_entry->p = p;
;;;1117           if(arp_table[i].q != NULL) {
;;;1118             /* queue was already existent, append the new entry to the end */
;;;1119             struct etharp_q_entry *r;
;;;1120             r = arp_table[i].q;
;;;1121             while (r->next != NULL) {
;;;1122               r = r->next;
;;;1123             }
;;;1124             r->next = new_entry;
;;;1125           } else {
;;;1126             /* queue did not exist, first item in queue */
;;;1127             arp_table[i].q = new_entry;
;;;1128           }
;;;1129           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1130           result = ERR_OK;
;;;1131         } else {
;;;1132           /* the pool MEMP_ARP_QUEUE is empty */
;;;1133           pbuf_free(p);
;;;1134           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1135           result = ERR_MEM;
;;;1136         }
;;;1137   #else /* ARP_QUEUEING */
;;;1138         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1139         if (arp_table[i].q != NULL) {
;;;1140           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1141           pbuf_free(arp_table[i].q);
;;;1142         }
;;;1143         arp_table[i].q = p;
;;;1144         result = ERR_OK;
;;;1145         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1146   #endif /* ARP_QUEUEING */
;;;1147       } else {
;;;1148         ETHARP_STATS_INC(etharp.memerr);
;;;1149         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1150         result = ERR_MEM;
;;;1151       }
;;;1152     }
;;;1153     return result;
;;;1154   }
00004a  b005              ADD      sp,sp,#0x14
00004c  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.80|
000050  f06f000d          MVN      r0,#0xd               ;1027
000054  e7f9              B        |L8.74|
                  |L8.86|
000056  f8df90c8          LDR      r9,|L8.288|
00005a  eb040884          ADD      r8,r4,r4,LSL #2       ;1044
00005e  eb090788          ADD      r7,r9,r8,LSL #2       ;1044
000062  7cb8              LDRB     r0,[r7,#0x12]         ;1044
000064  b138              CBZ      r0,|L8.118|
000066  2801              CMP      r0,#1                 ;1049
000068  d009              BEQ      |L8.126|
00006a  2802              CMP      r0,#2                 ;1049
00006c  d206              BCS      |L8.124|
00006e  a02d              ADR      r0,|L8.292|
000070  f7fffffe          BL       __2printf
                  |L8.116|
000074  e7fe              B        |L8.116|
                  |L8.118|
000076  2001              MOVS     r0,#1                 ;1045
000078  74b8              STRB     r0,[r7,#0x12]         ;1045
00007a  e000              B        |L8.126|
                  |L8.124|
00007c  b94d              CBNZ     r5,|L8.146|
                  |L8.126|
00007e  4631              MOV      r1,r6                 ;1056
000080  9802              LDR      r0,[sp,#8]            ;1056
000082  f7fffffe          BL       etharp_request
000086  2d00              CMP      r5,#0                 ;1063
000088  d0df              BEQ      |L8.74|
00008a  7cb9              LDRB     r1,[r7,#0x12]         ;1071
00008c  464e              MOV      r6,r9                 ;1071
00008e  2902              CMP      r1,#2                 ;1071
000090  d30b              BCC      |L8.170|
                  |L8.146|
000092  482e              LDR      r0,|L8.332|
000094  f107030c          ADD      r3,r7,#0xc            ;1075
000098  4629              MOV      r1,r5                 ;1075
00009a  7004              STRB     r4,[r0,#0]            ;1073
00009c  9a00              LDR      r2,[sp,#0]            ;1075
00009e  9802              LDR      r0,[sp,#8]            ;1075
0000a0  b005              ADD      sp,sp,#0x14           ;1075
0000a2  e8bd4ff0          POP      {r4-r11,lr}           ;1075
0000a6  f7ffbffe          B.W      etharp_send_ip
                  |L8.170|
0000aa  2901              CMP      r1,#1                 ;1077
0000ac  d1cd              BNE      |L8.74|
0000ae  2000              MOVS     r0,#0                 ;1080
0000b0  462c              MOV      r4,r5                 ;1084
                  |L8.178|
0000b2  8961              LDRH     r1,[r4,#0xa]          ;1086
0000b4  8922              LDRH     r2,[r4,#8]            ;1086
0000b6  4291              CMP      r1,r2                 ;1086
0000b8  d105              BNE      |L8.198|
0000ba  6821              LDR      r1,[r4,#0]            ;1086
0000bc  b119              CBZ      r1,|L8.198|
0000be  a024              ADR      r0,|L8.336|
0000c0  f7fffffe          BL       __2printf
                  |L8.196|
0000c4  e7fe              B        |L8.196|
                  |L8.198|
0000c6  7b21              LDRB     r1,[r4,#0xc]          ;1087
0000c8  2901              CMP      r1,#1                 ;1087
0000ca  d103              BNE      |L8.212|
0000cc  6824              LDR      r4,[r4,#0]            ;1091
0000ce  2c00              CMP      r4,#0                 ;1091
0000d0  d1ef              BNE      |L8.178|
0000d2  b170              CBZ      r0,|L8.242|
                  |L8.212|
0000d4  8921              LDRH     r1,[r4,#8]            ;1095
0000d6  2200              MOVS     r2,#0                 ;1095
0000d8  2003              MOVS     r0,#3                 ;1095
0000da  f7fffffe          BL       pbuf_alloc
0000de  0004              MOVS     r4,r0                 ;1095
0000e0  d015              BEQ      |L8.270|
0000e2  4629              MOV      r1,r5                 ;1097
0000e4  f7fffffe          BL       pbuf_copy
0000e8  b140              CBZ      r0,|L8.252|
0000ea  4620              MOV      r0,r4                 ;1098
0000ec  f7fffffe          BL       pbuf_free
0000f0  e00d              B        |L8.270|
                  |L8.242|
0000f2  462c              MOV      r4,r5                 ;1104
0000f4  4628              MOV      r0,r5                 ;1105
0000f6  f7fffffe          BL       pbuf_ref
0000fa  b144              CBZ      r4,|L8.270|
                  |L8.252|
0000fc  f8560028          LDR      r0,[r6,r8,LSL #2]     ;1139
000100  b108              CBZ      r0,|L8.262|
000102  f7fffffe          BL       pbuf_free
                  |L8.262|
000106  f8464028          STR      r4,[r6,r8,LSL #2]     ;1143
00010a  2000              MOVS     r0,#0                 ;1144
00010c  e79d              B        |L8.74|
                  |L8.270|
00010e  f8ba0024          LDRH     r0,[r10,#0x24]        ;1148  ; lwip_stats
000112  1c40              ADDS     r0,r0,#1              ;1148
000114  f8aa0024          STRH     r0,[r10,#0x24]        ;1148
000118  4658              MOV      r0,r11                ;1150
00011a  e796              B        |L8.74|
;;;1155   
                          ENDP

                  |L8.284|
                          DCD      lwip_stats
                  |L8.288|
                          DCD      ||.bss||
                  |L8.292|
000124  6172705f          DCB      "arp_table[i].state == PENDING or STABLE",0
000128  7461626c
00012c  655b695d
000130  2e737461
000134  7465203d
000138  3d205045
00013c  4e44494e
000140  47206f72
000144  20535441
000148  424c4500
                  |L8.332|
                          DCD      ||.data||
                  |L8.336|
000150  6e6f2070          DCB      "no packet queues allowed!",0
000154  61636b65
000158  74207175
00015c  65756573
000160  20616c6c
000164  6f776564
000168  2100    
00016a  00                DCB      0
00016b  00                DCB      0

                          AREA ||i.etharp_raw||, CODE, READONLY, ALIGN=2

                  etharp_raw PROC
;;;1174   err_t
;;;1175   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1176              const struct eth_addr *ethdst_addr,
;;;1177              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1178              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1179              const u16_t opcode)
;;;1180   {
000004  4699              MOV      r9,r3
000006  4692              MOV      r10,r2
000008  468b              MOV      r11,r1
00000a  0007              MOVS     r7,r0
00000c  d00f              BEQ      |L9.46|
;;;1181     struct pbuf *p;
;;;1182     err_t result = ERR_OK;
;;;1183     struct eth_hdr *ethhdr;
;;;1184     struct etharp_hdr *hdr;
;;;1185   #if LWIP_AUTOIP
;;;1186     const u8_t * ethdst_hwaddr;
;;;1187   #endif /* LWIP_AUTOIP */
;;;1188   
;;;1189     LWIP_ASSERT("netif != NULL", netif != NULL);
;;;1190   
;;;1191     /* allocate a pbuf for the outgoing ARP request packet */
;;;1192     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
00000e  2200              MOVS     r2,#0
000010  212a              MOVS     r1,#0x2a
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       pbuf_alloc
;;;1193     /* could allocate a pbuf for an ARP request? */
;;;1194     if (p == NULL) {
;;;1195       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;1196         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1197       ETHARP_STATS_INC(etharp.memerr);
000018  f8df80c0          LDR      r8,|L9.220|
00001c  0006              MOVS     r6,r0                 ;1192
00001e  d00a              BEQ      |L9.54|
;;;1198       return ERR_MEM;
;;;1199     }
;;;1200     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
000020  8970              LDRH     r0,[r6,#0xa]
000022  282a              CMP      r0,#0x2a
000024  d210              BCS      |L9.72|
000026  a02e              ADR      r0,|L9.224|
000028  f7fffffe          BL       __2printf
                  |L9.44|
00002c  e7fe              B        |L9.44|
                  |L9.46|
00002e  a039              ADR      r0,|L9.276|
000030  f7fffffe          BL       __2printf
                  |L9.52|
000034  e7fe              B        |L9.52|
                  |L9.54|
000036  f8b80024          LDRH     r0,[r8,#0x24]         ;1197  ; lwip_stats
00003a  1c40              ADDS     r0,r0,#1              ;1197
00003c  f8a80024          STRH     r0,[r8,#0x24]         ;1197
000040  f04f30ff          MOV      r0,#0xffffffff        ;1198
                  |L9.68|
;;;1201                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1202   
;;;1203     ethhdr = (struct eth_hdr *)p->payload;
;;;1204     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1205     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1206     hdr->opcode = htons(opcode);
;;;1207   
;;;1208     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;1209                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1210   #if LWIP_AUTOIP
;;;1211     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1212      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1213      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1214     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1215   #endif /* LWIP_AUTOIP */
;;;1216     /* Write the ARP MAC-Addresses */
;;;1217     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
;;;1218     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
;;;1219     /* Write the Ethernet MAC-Addresses */
;;;1220   #if LWIP_AUTOIP
;;;1221     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1222   #else  /* LWIP_AUTOIP */
;;;1223     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
;;;1224   #endif /* LWIP_AUTOIP */
;;;1225     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
;;;1226     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1227      * structure packing. */ 
;;;1228     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
;;;1229     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
;;;1230   
;;;1231     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
;;;1232     hdr->proto = PP_HTONS(ETHTYPE_IP);
;;;1233     /* set hwlen and protolen */
;;;1234     hdr->hwlen = ETHARP_HWADDR_LEN;
;;;1235     hdr->protolen = sizeof(ip_addr_t);
;;;1236   
;;;1237     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
;;;1238     /* send ARP query */
;;;1239     result = netif->linkoutput(netif, p);
;;;1240     ETHARP_STATS_INC(etharp.xmit);
;;;1241     /* free ARP query packet */
;;;1242     pbuf_free(p);
;;;1243     p = NULL;
;;;1244     /* could not allocate pbuf for ARP request */
;;;1245   
;;;1246     return result;
;;;1247   }
000044  e8bd9ff0          POP      {r4-r12,pc}
                  |L9.72|
000048  6875              LDR      r5,[r6,#4]            ;1206
00004a  980d              LDR      r0,[sp,#0x34]         ;1206
00004c  f105040e          ADD      r4,r5,#0xe            ;1206
000050  f7fffffe          BL       lwip_htons
000054  80e0              STRH     r0,[r4,#6]            ;1206
000056  f8970022          LDRB     r0,[r7,#0x22]         ;1208
00005a  2806              CMP      r0,#6                 ;1208
00005c  d003              BEQ      |L9.102|
00005e  4831              LDR      r0,|L9.292|
000060  f7fffffe          BL       __2printf
                  |L9.100|
000064  e7fe              B        |L9.100|
                  |L9.102|
000066  f8d91000          LDR      r1,[r9,#0]            ;1217
00006a  60a1              STR      r1,[r4,#8]            ;1217
00006c  f8b90004          LDRH     r0,[r9,#4]            ;1217
000070  81a0              STRH     r0,[r4,#0xc]          ;1217
000072  980b              LDR      r0,[sp,#0x2c]         ;1218
000074  6801              LDR      r1,[r0,#0]            ;1218
000076  f8c41012          STR      r1,[r4,#0x12]         ;1218
00007a  8880              LDRH     r0,[r0,#4]            ;1218
00007c  82e0              STRH     r0,[r4,#0x16]         ;1218
00007e  f8da1000          LDR      r1,[r10,#0]           ;1223
000082  6029              STR      r1,[r5,#0]            ;1223
000084  f8ba0004          LDRH     r0,[r10,#4]           ;1223
000088  80a8              STRH     r0,[r5,#4]            ;1223
00008a  f8db1000          LDR      r1,[r11,#0]           ;1225
00008e  f8c51006          STR      r1,[r5,#6]            ;1225
000092  f8bb0004          LDRH     r0,[r11,#4]           ;1225
000096  8168              STRH     r0,[r5,#0xa]          ;1225
000098  980a              LDR      r0,[sp,#0x28]         ;1228
00009a  4631              MOV      r1,r6                 ;1239
00009c  6800              LDR      r0,[r0,#0]            ;1228
00009e  f8c4000e          STR      r0,[r4,#0xe]          ;1228
0000a2  980c              LDR      r0,[sp,#0x30]         ;1229
0000a4  6800              LDR      r0,[r0,#0]            ;1229
0000a6  61a0              STR      r0,[r4,#0x18]         ;1229
0000a8  f44f7080          MOV      r0,#0x100             ;1231
0000ac  8020              STRH     r0,[r4,#0]            ;1231
0000ae  2008              MOVS     r0,#8                 ;1232
0000b0  8060              STRH     r0,[r4,#2]            ;1232
0000b2  2006              MOVS     r0,#6                 ;1234
0000b4  7120              STRB     r0,[r4,#4]            ;1234
0000b6  2004              MOVS     r0,#4                 ;1235
0000b8  7160              STRB     r0,[r4,#5]            ;1235
0000ba  f44f60c1          MOV      r0,#0x608             ;1237
0000be  81a8              STRH     r0,[r5,#0xc]          ;1237
0000c0  69ba              LDR      r2,[r7,#0x18]         ;1239
0000c2  4638              MOV      r0,r7                 ;1239
0000c4  4790              BLX      r2                    ;1239
0000c6  f8b81018          LDRH     r1,[r8,#0x18]         ;1240  ; lwip_stats
0000ca  4604              MOV      r4,r0                 ;1239
0000cc  1c49              ADDS     r1,r1,#1              ;1240
0000ce  f8a81018          STRH     r1,[r8,#0x18]         ;1240
0000d2  4630              MOV      r0,r6                 ;1242
0000d4  f7fffffe          BL       pbuf_free
0000d8  4620              MOV      r0,r4                 ;1246
0000da  e7b3              B        |L9.68|
;;;1248   
                          ENDP

                  |L9.220|
                          DCD      lwip_stats
                  |L9.224|
0000e0  63686563          DCB      "check that first pbuf can hold struct etharp_hdr",0
0000e4  6b207468
0000e8  61742066
0000ec  69727374
0000f0  20706275
0000f4  66206361
0000f8  6e20686f
0000fc  6c642073
000100  74727563
000104  74206574
000108  68617270
00010c  5f686472
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L9.276|
000114  6e657469          DCB      "netif != NULL",0
000118  6620213d
00011c  204e554c
000120  4c00    
000122  00                DCB      0
000123  00                DCB      0
                  |L9.292|
                          DCD      ||.conststring||

                          AREA ||i.etharp_request||, CODE, READONLY, ALIGN=2

                  etharp_request PROC
;;;1258   err_t
;;;1259   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
000000  b51f              PUSH     {r0-r4,lr}
;;;1260   {
;;;1261     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
;;;1262     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
000002  2301              MOVS     r3,#1
000004  4c06              LDR      r4,|L10.32|
000006  1d02              ADDS     r2,r0,#4
000008  e9cd1302          STRD     r1,r3,[sp,#8]
00000c  e9cd2400          STRD     r2,r4,[sp,#0]
000010  f1000323          ADD      r3,r0,#0x23
000014  4619              MOV      r1,r3
000016  1fa2              SUBS     r2,r4,#6
000018  f7fffffe          BL       etharp_raw
;;;1263                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1264                       ipaddr, ARP_REQUEST);
;;;1265   }
00001c  b004              ADD      sp,sp,#0x10
00001e  bd10              POP      {r4,pc}
;;;1266   #endif /* LWIP_ARP */
                          ENDP

                  |L10.32|
                          DCD      ||.constdata||+0x6

                          AREA ||i.etharp_send_ip||, CODE, READONLY, ALIGN=2

                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
000000  b570              PUSH     {r4-r6,lr}
;;;416    {
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
000002  f8905022          LDRB     r5,[r0,#0x22]
000006  684c              LDR      r4,[r1,#4]
000008  2d06              CMP      r5,#6
00000a  d003              BEQ      |L11.20|
00000c  4809              LDR      r0,|L11.52|
00000e  f7fffffe          BL       __2printf
                  |L11.18|
000012  e7fe              B        |L11.18|
                  |L11.20|
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
000014  681d              LDR      r5,[r3,#0]
000016  6025              STR      r5,[r4,#0]
000018  889b              LDRH     r3,[r3,#4]
00001a  80a3              STRH     r3,[r4,#4]
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
00001c  6813              LDR      r3,[r2,#0]
00001e  f8c43006          STR      r3,[r4,#6]
000022  8892              LDRH     r2,[r2,#4]
000024  8162              STRH     r2,[r4,#0xa]
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
000026  2208              MOVS     r2,#8
000028  81a2              STRH     r2,[r4,#0xc]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
00002a  6982              LDR      r2,[r0,#0x18]
00002c  e8bd4070          POP      {r4-r6,lr}
000030  4710              BX       r2
;;;427    }
;;;428    
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      ||.conststring||

                          AREA ||i.etharp_tmr||, CODE, READONLY, ALIGN=2

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;213        u8_t state = arp_table[i].state;
000002  4d10              LDR      r5,|L12.68|
000004  2400              MOVS     r4,#0                 ;212
                  |L12.6|
000006  eb040084          ADD      r0,r4,r4,LSL #2
00000a  eb050080          ADD      r0,r5,r0,LSL #2
00000e  7c82              LDRB     r2,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
000010  b192              CBZ      r2,|L12.56|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
000012  7cc1              LDRB     r1,[r0,#0x13]
000014  1c49              ADDS     r1,r1,#1
000016  b2c9              UXTB     r1,r1
000018  74c1              STRB     r1,[r0,#0x13]
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
00001a  29f0              CMP      r1,#0xf0
00001c  d206              BCS      |L12.44|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
00001e  2a01              CMP      r2,#1
000020  d002              BEQ      |L12.40|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
000022  2a03              CMP      r2,#3
000024  d006              BEQ      |L12.52|
000026  e007              B        |L12.56|
                  |L12.40|
000028  2902              CMP      r1,#2                 ;222
00002a  d305              BCC      |L12.56|
                  |L12.44|
00002c  4620              MOV      r0,r4                 ;227
00002e  f7fffffe          BL       etharp_free_entry
000032  e001              B        |L12.56|
                  |L12.52|
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
000034  2102              MOVS     r1,#2
000036  7481              STRB     r1,[r0,#0x12]
                  |L12.56|
000038  1c64              ADDS     r4,r4,#1
00003a  b2e4              UXTB     r4,r4                 ;212
00003c  2c0a              CMP      r4,#0xa               ;212
00003e  d3e2              BCC      |L12.6|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
000040  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      ||.bss||

                          AREA ||i.etharp_update_arp_entry||, CODE, READONLY, ALIGN=2

                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;449    {
000004  4604              MOV      r4,r0
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
000006  f8900022          LDRB     r0,[r0,#0x22]
00000a  461f              MOV      r7,r3                 ;449
00000c  4615              MOV      r5,r2                 ;449
00000e  460e              MOV      r6,r1                 ;449
000010  2806              CMP      r0,#6
000012  d003              BEQ      |L13.28|
000014  a01c              ADR      r0,|L13.136|
000016  f7fffffe          BL       __2printf
                  |L13.26|
00001a  e7fe              B        |L13.26|
                  |L13.28|
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
00001c  b386              CBZ      r6,|L13.128|
00001e  6830              LDR      r0,[r6,#0]
000020  b370              CBZ      r0,|L13.128|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
000022  4621              MOV      r1,r4
000024  f7fffffe          BL       ip4_addr_isbroadcast
000028  bb50              CBNZ     r0,|L13.128|
;;;459          ip_addr_ismulticast(ipaddr)) {
00002a  7830              LDRB     r0,[r6,#0]
00002c  f3c01003          UBFX     r0,r0,#4,#4
000030  280e              CMP      r0,#0xe
000032  d026              BEQ      |L13.130|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
;;;461        return ERR_ARG;
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
000034  4639              MOV      r1,r7
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       etharp_find_entry
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
00003c  2800              CMP      r0,#0
00003e  db1d              BLT      |L13.124|
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
000040  4a1b              LDR      r2,|L13.176|
000042  eb000180          ADD      r1,r0,r0,LSL #2
000046  eb020081          ADD      r0,r2,r1,LSL #2
00004a  2302              MOVS     r3,#2
00004c  7483              STRB     r3,[r0,#0x12]
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
00004e  6084              STR      r4,[r0,#8]
000050  682b              LDR      r3,[r5,#0]
000052  60c3              STR      r3,[r0,#0xc]
000054  88ab              LDRH     r3,[r5,#4]
000056  8203              STRH     r3,[r0,#0x10]
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
000058  2300              MOVS     r3,#0
00005a  74c3              STRB     r3,[r0,#0x13]
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
00005c  f8526021          LDR      r6,[r2,r1,LSL #2]
000060  b15e              CBZ      r6,|L13.122|
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
000062  f8423021          STR      r3,[r2,r1,LSL #2]
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
000066  462b              MOV      r3,r5
000068  f1040223          ADD      r2,r4,#0x23
00006c  4631              MOV      r1,r6
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       etharp_send_ip
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       pbuf_free
                  |L13.122|
;;;512      }
;;;513      return ERR_OK;
00007a  2000              MOVS     r0,#0
                  |L13.124|
;;;514    }
00007c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.128|
000080  e7ff              B        |L13.130|
                  |L13.130|
000082  f06f000d          MVN      r0,#0xd               ;461
000086  e7f9              B        |L13.124|
;;;515    
                          ENDP

                  |L13.136|
000088  6e657469          DCB      "netif->hwaddr_len == ETHARP_HWADDR_LEN",0
00008c  662d3e68
000090  77616464
000094  725f6c65
000098  6e203d3d
00009c  20455448
0000a0  4152505f
0000a4  48574144
0000a8  44525f4c
0000ac  454e00  
0000af  00                DCB      0
                  |L13.176|
                          DCD      ||.bss||

                          AREA ||i.ethernet_input||, CODE, READONLY, ALIGN=2

                  ethernet_input PROC
;;;1276   err_t
;;;1277   ethernet_input(struct pbuf *p, struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1278   {
000004  4604              MOV      r4,r0
;;;1279     struct eth_hdr* ethhdr;
;;;1280     u16_t type;
;;;1281   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1282     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
;;;1283   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1284   
;;;1285     if (p->len <= SIZEOF_ETH_HDR) {
000006  8940              LDRH     r0,[r0,#0xa]
;;;1286       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1287       ETHARP_STATS_INC(etharp.proterr);
000008  4f26              LDR      r7,|L14.164|
00000a  460d              MOV      r5,r1                 ;1278
00000c  280e              CMP      r0,#0xe               ;1285
00000e  d91e              BLS      |L14.78|
;;;1288       ETHARP_STATS_INC(etharp.drop);
;;;1289       goto free_and_return;
;;;1290     }
;;;1291   
;;;1292     /* points to packet payload, which starts with an Ethernet header */
;;;1293     ethhdr = (struct eth_hdr *)p->payload;
;;;1294     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
;;;1295       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1296        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1297        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1298        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1299        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1300        (unsigned)htons(ethhdr->type)));
;;;1301   
;;;1302     type = ethhdr->type;
000010  6860              LDR      r0,[r4,#4]
;;;1303   #if ETHARP_SUPPORT_VLAN
;;;1304     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1305       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1306       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1307         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1308         ETHARP_STATS_INC(etharp.proterr);
;;;1309         ETHARP_STATS_INC(etharp.drop);
;;;1310         goto free_and_return;
;;;1311       }
;;;1312   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1313   #ifdef ETHARP_VLAN_CHECK_FN
;;;1314       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1315   #elif defined(ETHARP_VLAN_CHECK)
;;;1316       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1317   #endif
;;;1318         /* silently ignore this packet: not for our VLAN */
;;;1319         pbuf_free(p);
;;;1320         return ERR_OK;
;;;1321       }
;;;1322   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1323       type = vlan->tpid;
;;;1324       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1325     }
;;;1326   #endif /* ETHARP_SUPPORT_VLAN */
;;;1327   
;;;1328   #if LWIP_ARP_FILTER_NETIF
;;;1329     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1330   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1331   
;;;1332     if (ethhdr->dest.addr[0] & 1) {
000012  7801              LDRB     r1,[r0,#0]
000014  8986              LDRH     r6,[r0,#0xc]          ;1302
000016  07ca              LSLS     r2,r1,#31
000018  d014              BEQ      |L14.68|
;;;1333       /* this might be a multicast or broadcast packet */
;;;1334       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
00001a  2901              CMP      r1,#1
00001c  d005              BEQ      |L14.42|
;;;1335         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
;;;1336             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
;;;1337           /* mark the pbuf as link-layer multicast */
;;;1338           p->flags |= PBUF_FLAG_LLMCAST;
;;;1339         }
;;;1340       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
00001e  2206              MOVS     r2,#6
000020  4921              LDR      r1,|L14.168|
000022  f7fffffe          BL       memcmp
000026  b148              CBZ      r0,|L14.60|
000028  e00c              B        |L14.68|
                  |L14.42|
00002a  7841              LDRB     r1,[r0,#1]            ;1335
00002c  b951              CBNZ     r1,|L14.68|
00002e  7880              LDRB     r0,[r0,#2]            ;1336
000030  285e              CMP      r0,#0x5e              ;1336
000032  d107              BNE      |L14.68|
000034  7b60              LDRB     r0,[r4,#0xd]          ;1338
000036  f0400010          ORR      r0,r0,#0x10           ;1338
00003a  e002              B        |L14.66|
                  |L14.60|
;;;1341         /* mark the pbuf as link-layer broadcast */
;;;1342         p->flags |= PBUF_FLAG_LLBCAST;
00003c  7b60              LDRB     r0,[r4,#0xd]
00003e  f0400008          ORR      r0,r0,#8
                  |L14.66|
000042  7360              STRB     r0,[r4,#0xd]
                  |L14.68|
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     switch (type) {
000044  2e08              CMP      r6,#8
000046  d009              BEQ      |L14.92|
000048  f5b66fc1          CMP      r6,#0x608
00004c  d019              BEQ      |L14.130|
                  |L14.78|
;;;1347   #if LWIP_ARP
;;;1348       /* IP packet? */
;;;1349       case PP_HTONS(ETHTYPE_IP):
;;;1350         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
;;;1351           goto free_and_return;
;;;1352         }
;;;1353   #if ETHARP_TRUST_IP_MAC
;;;1354         /* update ARP table */
;;;1355         etharp_ip_input(netif, p);
;;;1356   #endif /* ETHARP_TRUST_IP_MAC */
;;;1357         /* skip Ethernet header */
;;;1358         if(pbuf_header(p, -ip_hdr_offset)) {
;;;1359           LWIP_ASSERT("Can't move over header in packet", 0);
;;;1360           goto free_and_return;
;;;1361         } else {
;;;1362           /* pass to IP layer */
;;;1363           ip_input(p, netif);
;;;1364         }
;;;1365         break;
;;;1366         
;;;1367       case PP_HTONS(ETHTYPE_ARP):
;;;1368         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
;;;1369           goto free_and_return;
;;;1370         }
;;;1371         /* pass p to ARP module */
;;;1372         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
;;;1373         break;
;;;1374   #endif /* LWIP_ARP */
;;;1375   #if PPPOE_SUPPORT
;;;1376       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1377         pppoe_disc_input(netif, p);
;;;1378         break;
;;;1379   
;;;1380       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1381         pppoe_data_input(netif, p);
;;;1382         break;
;;;1383   #endif /* PPPOE_SUPPORT */
;;;1384   
;;;1385       default:
;;;1386         ETHARP_STATS_INC(etharp.proterr);
00004e  8d38              LDRH     r0,[r7,#0x28]  ; lwip_stats
000050  1c40              ADDS     r0,r0,#1
000052  8538              STRH     r0,[r7,#0x28]
;;;1387         ETHARP_STATS_INC(etharp.drop);
000054  8bf8              LDRH     r0,[r7,#0x1e]  ; lwip_stats
000056  1c40              ADDS     r0,r0,#1
000058  83f8              STRH     r0,[r7,#0x1e]
;;;1388         goto free_and_return;
00005a  e01f              B        |L14.156|
                  |L14.92|
00005c  f8950029          LDRB     r0,[r5,#0x29]         ;1350
000060  0680              LSLS     r0,r0,#26             ;1350
000062  d51b              BPL      |L14.156|
000064  f06f010d          MVN      r1,#0xd               ;1358
000068  4620              MOV      r0,r4                 ;1358
00006a  f7fffffe          BL       pbuf_header
00006e  b118              CBZ      r0,|L14.120|
000070  a00e              ADR      r0,|L14.172|
000072  f7fffffe          BL       __2printf
                  |L14.118|
000076  e7fe              B        |L14.118|
                  |L14.120|
000078  4629              MOV      r1,r5                 ;1363
00007a  4620              MOV      r0,r4                 ;1363
00007c  f7fffffe          BL       ip_input
000080  e009              B        |L14.150|
                  |L14.130|
000082  f8950029          LDRB     r0,[r5,#0x29]         ;1368
000086  0680              LSLS     r0,r0,#26             ;1368
000088  d508              BPL      |L14.156|
00008a  4622              MOV      r2,r4                 ;1372
00008c  f1050123          ADD      r1,r5,#0x23           ;1372
000090  4628              MOV      r0,r5                 ;1372
000092  f7fffffe          BL       etharp_arp_input
                  |L14.150|
;;;1389     }
;;;1390   
;;;1391     /* This means the pbuf is freed or consumed,
;;;1392        so the caller doesn't have to free it again */
;;;1393     return ERR_OK;
000096  2000              MOVS     r0,#0
;;;1394   
;;;1395   free_and_return:
;;;1396     pbuf_free(p);
;;;1397     return ERR_OK;
;;;1398   }
000098  e8bd81f0          POP      {r4-r8,pc}
                  |L14.156|
00009c  4620              MOV      r0,r4                 ;1396
00009e  f7fffffe          BL       pbuf_free
0000a2  e7f8              B        |L14.150|
;;;1399   #endif /* LWIP_ARP || LWIP_ETHERNET */
                          ENDP

                  |L14.164|
                          DCD      lwip_stats
                  |L14.168|
                          DCD      ||.constdata||
                  |L14.172|
0000ac  43616e27          DCB      "Can't move over header in packet",0
0000b0  74206d6f
0000b4  7665206f
0000b8  76657220
0000bc  68656164
0000c0  65722069
0000c4  6e207061
0000c8  636b6574
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  6e657469          DCB      "netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN"
000004  662d3e68
000008  77616464
00000c  725f6c65
000010  6e206d75
000014  73742062
000018  65207468
00001c  65207361
000020  6d652061
000024  73204554
000028  48415250
00002c  5f485741
000030  4444525f
000034  4c454e  
000037  20666f72          DCB      " for etharp!",0
00003b  20657468
00003f  61727021
000043  00      

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00
