; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\tcp_out.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp_out.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\tcp_out.crf ..\lwip\src\core\tcp_out.c]
                          THUMB

                          AREA ||i.tcp_create_segment||, CODE, READONLY, ALIGN=2

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;160    {
000004  4680              MOV      r8,r0
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000006  9e08              LDR      r6,[sp,#0x20]
000008  469a              MOV      r10,r3                ;160
00000a  4691              MOV      r9,r2                 ;160
00000c  460f              MOV      r7,r1                 ;160
00000e  07f0              LSLS     r0,r6,#31
000010  d000              BEQ      |L1.20|
000012  2004              MOVS     r0,#4
                  |L1.20|
000014  07b1              LSLS     r1,r6,#30
000016  d501              BPL      |L1.28|
000018  210c              MOVS     r1,#0xc
00001a  e000              B        |L1.30|
                  |L1.28|
00001c  2100              MOVS     r1,#0
                  |L1.30|
00001e  1845              ADDS     r5,r0,r1
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
000020  2004              MOVS     r0,#4
000022  f7fffffe          BL       memp_malloc
000026  0004              MOVS     r4,r0
000028  d017              BEQ      |L1.90|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
;;;166        pbuf_free(p);
;;;167        return NULL;
;;;168      }
;;;169      seg->flags = optflags;
00002a  7326              STRB     r6,[r4,#0xc]
;;;170      seg->next = NULL;
00002c  2600              MOVS     r6,#0
00002e  e9c46700          STRD     r6,r7,[r4,#0]
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
000032  8938              LDRH     r0,[r7,#8]
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
000034  2114              MOVS     r1,#0x14
000036  1b40              SUBS     r0,r0,r5              ;172
000038  8120              STRH     r0,[r4,#8]            ;172
00003a  8166              STRH     r6,[r4,#0xa]          ;174
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       pbuf_header
000042  b170              CBZ      r0,|L1.98|
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
000044  4918              LDR      r1,|L1.168|
000046  f8310fa4          LDRH     r0,[r1,#0xa4]!  ; lwip_stats
00004a  1c40              ADDS     r0,r0,#1
00004c  8008              STRH     r0,[r1,#0]
;;;188        tcp_seg_free(seg);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       tcp_seg_free
                  |L1.84|
;;;189        return NULL;
000054  2000              MOVS     r0,#0
                  |L1.86|
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
000056  e8bd87f0          POP      {r4-r10,pc}
                  |L1.90|
00005a  4638              MOV      r0,r7                 ;166
00005c  f7fffffe          BL       pbuf_free
000060  e7f8              B        |L1.84|
                  |L1.98|
000062  6860              LDR      r0,[r4,#4]            ;191
000064  6840              LDR      r0,[r0,#4]            ;191
000066  6120              STR      r0,[r4,#0x10]         ;192
000068  f8b8001a          LDRH     r0,[r8,#0x1a]         ;192
00006c  f7fffffe          BL       lwip_htons
000070  6921              LDR      r1,[r4,#0x10]         ;192
000072  8008              STRH     r0,[r1,#0]            ;192
000074  f8b8001c          LDRH     r0,[r8,#0x1c]         ;193
000078  f7fffffe          BL       lwip_htons
00007c  6921              LDR      r1,[r4,#0x10]         ;193
00007e  8048              STRH     r0,[r1,#2]            ;193
000080  4650              MOV      r0,r10                ;194
000082  f7fffffe          BL       lwip_htonl
000086  6921              LDR      r1,[r4,#0x10]         ;194
000088  6048              STR      r0,[r1,#4]            ;194
00008a  08a8              LSRS     r0,r5,#2              ;196
00008c  0300              LSLS     r0,r0,#12             ;196
00008e  f50040a0          ADD      r0,r0,#0x5000         ;196
000092  ea400009          ORR      r0,r0,r9              ;196
000096  f7fffffe          BL       lwip_htons
00009a  6921              LDR      r1,[r4,#0x10]         ;196
00009c  8188              STRH     r0,[r1,#0xc]          ;196
00009e  6920              LDR      r0,[r4,#0x10]         ;198
0000a0  8246              STRH     r6,[r0,#0x12]         ;198
0000a2  4620              MOV      r0,r4                 ;199
0000a4  e7d7              B        |L1.86|
;;;201    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
                          DCD      lwip_stats

                          AREA ||i.tcp_enqueue_flags||, CODE, READONLY, ALIGN=2

                  tcp_enqueue_flags PROC
;;;721    err_t
;;;722    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;723    {
000004  4604              MOV      r4,r0
;;;724      struct pbuf *p;
;;;725      struct tcp_seg *seg;
;;;726      u8_t optflags = 0;
000006  2700              MOVS     r7,#0
000008  460d              MOV      r5,r1                 ;723
;;;727      u8_t optlen = 0;
;;;728    
;;;729      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;730    
;;;731      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
00000a  0788              LSLS     r0,r1,#30
00000c  d011              BEQ      |L2.50|
;;;732                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;733    
;;;734      /* check for configured max queuelen and possible overflow */
;;;735      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;736        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
;;;737                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;738        TCP_STATS_INC(tcp.memerr);
00000e  4e44              LDR      r6,|L2.288|
000010  f8b41068          LDRH     r1,[r4,#0x68]         ;735
;;;739        pcb->flags |= TF_NAGLEMEMERR;
;;;740        return ERR_MEM;
000014  f04f39ff          MOV      r9,#0xffffffff
000018  f8b6009c          LDRH     r0,[r6,#0x9c]         ;738
00001c  1c40              ADDS     r0,r0,#1              ;738
00001e  b280              UXTH     r0,r0                 ;738
000020  2910              CMP      r1,#0x10              ;735
000022  d30a              BCC      |L2.58|
000024  f8a6009c          STRH     r0,[r6,#0x9c]         ;738
000028  7fa0              LDRB     r0,[r4,#0x1e]         ;739
00002a  f0400080          ORR      r0,r0,#0x80           ;739
00002e  77a0              STRB     r0,[r4,#0x1e]         ;739
000030  e03b              B        |L2.170|
                  |L2.50|
000032  483c              LDR      r0,|L2.292|
000034  f7fffffe          BL       __2printf
                  |L2.56|
000038  e7fe              B        |L2.56|
                  |L2.58|
;;;741      }
;;;742    
;;;743      if (flags & TCP_SYN) {
00003a  07a9              LSLS     r1,r5,#30
00003c  d500              BPL      |L2.64|
;;;744        optflags = TF_SEG_OPTS_MSS;
00003e  2701              MOVS     r7,#1
                  |L2.64|
;;;745      }
;;;746    #if LWIP_TCP_TIMESTAMPS
;;;747      if ((pcb->flags & TF_TIMESTAMP)) {
;;;748        optflags |= TF_SEG_OPTS_TS;
;;;749      }
;;;750    #endif /* LWIP_TCP_TIMESTAMPS */
;;;751      optlen = LWIP_TCP_OPT_LENGTH(optflags);
000040  07f9              LSLS     r1,r7,#31
000042  d000              BEQ      |L2.70|
000044  2104              MOVS     r1,#4
                  |L2.70|
000046  07ba              LSLS     r2,r7,#30
000048  d501              BPL      |L2.78|
00004a  220c              MOVS     r2,#0xc
00004c  e000              B        |L2.80|
                  |L2.78|
00004e  2200              MOVS     r2,#0
                  |L2.80|
000050  eb010802          ADD      r8,r1,r2
;;;752    
;;;753      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;754       * We need one available snd_buf byte to do that.
;;;755       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;756       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;757      if (pcb->snd_buf == 0) {
000054  f8b41066          LDRH     r1,[r4,#0x66]
000058  b169              CBZ      r1,|L2.118|
;;;758        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;759        TCP_STATS_INC(tcp.memerr);
;;;760        return ERR_MEM;
;;;761      }
;;;762    
;;;763      /* Allocate pbuf with room for TCP header + options */
;;;764      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
00005a  2200              MOVS     r2,#0
00005c  4641              MOV      r1,r8
00005e  4610              MOV      r0,r2
000060  f7fffffe          BL       pbuf_alloc
000064  0001              MOVS     r1,r0
000066  d018              BEQ      |L2.154|
;;;765        pcb->flags |= TF_NAGLEMEMERR;
;;;766        TCP_STATS_INC(tcp.memerr);
;;;767        return ERR_MEM;
;;;768      }
;;;769      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
000068  894a              LDRH     r2,[r1,#0xa]
00006a  4542              CMP      r2,r8
00006c  d206              BCS      |L2.124|
00006e  a02e              ADR      r0,|L2.296|
000070  f7fffffe          BL       __2printf
                  |L2.116|
000074  e7fe              B        |L2.116|
                  |L2.118|
000076  f8a6009c          STRH     r0,[r6,#0x9c]         ;759
00007a  e016              B        |L2.170|
                  |L2.124|
;;;770                  (p->len >= optlen));
;;;771    
;;;772      /* Allocate memory for tcp_seg, and fill in fields. */
;;;773      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
00007c  9700              STR      r7,[sp,#0]
00007e  462a              MOV      r2,r5
000080  4620              MOV      r0,r4
000082  6de3              LDR      r3,[r4,#0x5c]
000084  f7fffffe          BL       tcp_create_segment
000088  0001              MOVS     r1,r0
00008a  d006              BEQ      |L2.154|
;;;774        pcb->flags |= TF_NAGLEMEMERR;
;;;775        TCP_STATS_INC(tcp.memerr);
;;;776        return ERR_MEM;
;;;777      }
;;;778      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
00008c  7c08              LDRB     r0,[r1,#0x10]
00008e  0780              LSLS     r0,r0,#30
000090  d00e              BEQ      |L2.176|
000092  a034              ADR      r0,|L2.356|
000094  f7fffffe          BL       __2printf
                  |L2.152|
000098  e7fe              B        |L2.152|
                  |L2.154|
00009a  7fa0              LDRB     r0,[r4,#0x1e]         ;774
00009c  f0400080          ORR      r0,r0,#0x80           ;774
0000a0  77a0              STRB     r0,[r4,#0x1e]         ;774
0000a2  f8360f9c          LDRH     r0,[r6,#0x9c]!        ;775  ; lwip_stats
0000a6  1c40              ADDS     r0,r0,#1              ;775
0000a8  8030              STRH     r0,[r6,#0]            ;775
                  |L2.170|
0000aa  4648              MOV      r0,r9                 ;776
                  |L2.172|
;;;779      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;780    
;;;781      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;782                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;783                   ntohl(seg->tcphdr->seqno),
;;;784                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;785                   (u16_t)flags));
;;;786    
;;;787      /* Now append seg to pcb->unsent queue */
;;;788      if (pcb->unsent == NULL) {
;;;789        pcb->unsent = seg;
;;;790      } else {
;;;791        struct tcp_seg *useg;
;;;792        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;793        useg->next = seg;
;;;794      }
;;;795    #if TCP_OVERSIZE
;;;796      /* The new unsent tail has no space */
;;;797      pcb->unsent_oversize = 0;
;;;798    #endif /* TCP_OVERSIZE */
;;;799    
;;;800      /* SYN and FIN bump the sequence number */
;;;801      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;802        pcb->snd_lbb++;
;;;803        /* optlen does not influence snd_buf */
;;;804        pcb->snd_buf--;
;;;805      }
;;;806      if (flags & TCP_FIN) {
;;;807        pcb->flags |= TF_FIN;
;;;808      }
;;;809    
;;;810      /* update number of segments on the queues */
;;;811      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;812      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;813      if (pcb->snd_queuelen != 0) {
;;;814        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;815          pcb->unacked != NULL || pcb->unsent != NULL);
;;;816      }
;;;817    
;;;818      return ERR_OK;
;;;819    }
0000ac  e8bd83f8          POP      {r3-r9,pc}
                  |L2.176|
0000b0  8908              LDRH     r0,[r1,#8]            ;779
0000b2  b118              CBZ      r0,|L2.188|
0000b4  a031              ADR      r0,|L2.380|
0000b6  f7fffffe          BL       __2printf
                  |L2.186|
0000ba  e7fe              B        |L2.186|
                  |L2.188|
0000bc  6ee0              LDR      r0,[r4,#0x6c]         ;788
0000be  b910              CBNZ     r0,|L2.198|
0000c0  66e1              STR      r1,[r4,#0x6c]         ;789
0000c2  e004              B        |L2.206|
                  |L2.196|
0000c4  4610              MOV      r0,r2                 ;789
                  |L2.198|
0000c6  6802              LDR      r2,[r0,#0]            ;792
0000c8  2a00              CMP      r2,#0                 ;792
0000ca  d1fb              BNE      |L2.196|
0000cc  6001              STR      r1,[r0,#0]            ;793
                  |L2.206|
0000ce  2000              MOVS     r0,#0                 ;797
0000d0  f8a4006a          STRH     r0,[r4,#0x6a]         ;797
0000d4  07a8              LSLS     r0,r5,#30             ;801
0000d6  d007              BEQ      |L2.232|
0000d8  6de0              LDR      r0,[r4,#0x5c]         ;802
0000da  1c40              ADDS     r0,r0,#1              ;802
0000dc  65e0              STR      r0,[r4,#0x5c]         ;804
0000de  f8b40066          LDRH     r0,[r4,#0x66]         ;804
0000e2  1e40              SUBS     r0,r0,#1              ;804
0000e4  f8a40066          STRH     r0,[r4,#0x66]         ;804
                  |L2.232|
0000e8  07e8              LSLS     r0,r5,#31             ;806
0000ea  d003              BEQ      |L2.244|
0000ec  7fa0              LDRB     r0,[r4,#0x1e]         ;807
0000ee  f0400020          ORR      r0,r0,#0x20           ;807
0000f2  77a0              STRB     r0,[r4,#0x1e]         ;807
                  |L2.244|
0000f4  6848              LDR      r0,[r1,#4]            ;811
0000f6  f7fffffe          BL       pbuf_clen
0000fa  f8b41068          LDRH     r1,[r4,#0x68]         ;811
0000fe  4408              ADD      r0,r0,r1              ;811
000100  0400              LSLS     r0,r0,#16             ;811
000102  0c00              LSRS     r0,r0,#16             ;811
000104  f8a40068          STRH     r0,[r4,#0x68]         ;811
000108  d003              BEQ      |L2.274|
00010a  6f20              LDR      r0,[r4,#0x70]         ;814
00010c  b908              CBNZ     r0,|L2.274|
00010e  6ee0              LDR      r0,[r4,#0x6c]         ;814
000110  b108              CBZ      r0,|L2.278|
                  |L2.274|
000112  2000              MOVS     r0,#0                 ;818
000114  e7ca              B        |L2.172|
                  |L2.278|
000116  a024              ADR      r0,|L2.424|
000118  f7fffffe          BL       __2printf
                  |L2.284|
00011c  e7fe              B        |L2.284|
;;;820    
                          ENDP

00011e  0000              DCW      0x0000
                  |L2.288|
                          DCD      lwip_stats
                  |L2.292|
                          DCD      ||.conststring||
                  |L2.296|
000128  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
00012c  656e7175
000130  6575655f
000134  666c6167
000138  733a2063
00013c  6865636b
000140  20746861
000144  74206669
000148  72737420
00014c  70627566
000150  2063616e
000154  20686f6c
000158  64206f70
00015c  746c65  
00015f  6e00              DCB      "n",0
000161  00                DCB      0
000162  00                DCB      0
000163  00                DCB      0
                  |L2.356|
000164  7365672d          DCB      "seg->tcphdr not aligned",0
000168  3e746370
00016c  68647220
000170  6e6f7420
000174  616c6967
000178  6e656400
                  |L2.380|
00017c  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
000180  656e7175
000184  6575655f
000188  666c6167
00018c  733a2069
000190  6e76616c
000194  69642073
000198  65676d65
00019c  6e74206c
0001a0  656e6774
0001a4  6800    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L2.424|
0001a8  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
0001ac  656e7175
0001b0  6575655f
0001b4  666c6167
0001b8  733a2069
0001bc  6e76616c
0001c0  69642071
0001c4  75657565
0001c8  206c656e
0001cc  67746800

                          AREA ||i.tcp_keepalive||, CODE, READONLY, ALIGN=2

                  tcp_keepalive PROC
;;;1363   void
;;;1364   tcp_keepalive(struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;1365   {
000002  4605              MOV      r5,r0
;;;1366     struct pbuf *p;
;;;1367     struct tcp_hdr *tcphdr;
;;;1368   
;;;1369     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1370                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1371                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1372   
;;;1373     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1374                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1375      
;;;1376     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
000004  6d00              LDR      r0,[r0,#0x50]
000006  1e40              SUBS     r0,r0,#1
000008  f7fffffe          BL       lwip_htonl
00000c  4603              MOV      r3,r0
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       tcp_output_alloc_header
000018  0004              MOVS     r4,r0
;;;1377     if(p == NULL) {
00001a  d01d              BEQ      |L3.88|
;;;1378       LWIP_DEBUGF(TCP_DEBUG, 
;;;1379                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1380       return;
;;;1381     }
;;;1382     tcphdr = (struct tcp_hdr *)p->payload;
;;;1383   
;;;1384   #if CHECKSUM_GEN_TCP
;;;1385     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
00001c  8920              LDRH     r0,[r4,#8]
00001e  6866              LDR      r6,[r4,#4]
000020  9000              STR      r0,[sp,#0]
000022  2306              MOVS     r3,#6
000024  1d2a              ADDS     r2,r5,#4
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       inet_chksum_pseudo
00002e  8230              STRH     r0,[r6,#0x10]
;;;1386                                         IP_PROTO_TCP, p->tot_len);
;;;1387   #endif
;;;1388     TCP_STATS_INC(tcp.xmit);
000030  480a              LDR      r0,|L3.92|
;;;1389   
;;;1390     /* Send output to IP */
;;;1391   #if LWIP_NETIF_HWADDRHINT
;;;1392     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1393       &(pcb->addr_hint));
;;;1394   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1395     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
000032  1d2a              ADDS     r2,r5,#4
000034  f8301f90          LDRH     r1,[r0,#0x90]!        ;1388  ; lwip_stats
000038  1c49              ADDS     r1,r1,#1              ;1388
00003a  8001              STRH     r1,[r0,#0]            ;1388
00003c  2106              MOVS     r1,#6
00003e  2000              MOVS     r0,#0
000040  e9cd0100          STRD     r0,r1,[sp,#0]
000044  7aab              LDRB     r3,[r5,#0xa]
000046  4629              MOV      r1,r5
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       ip_output
;;;1396   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1397   
;;;1398     pbuf_free(p);
00004e  4620              MOV      r0,r4
000050  e8bd407c          POP      {r2-r6,lr}
000054  f7ffbffe          B.W      pbuf_free
                  |L3.88|
;;;1399   
;;;1400     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1401                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1402   }
000058  bd7c              POP      {r2-r6,pc}
;;;1403   
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      lwip_stats

                          AREA ||i.tcp_output||, CODE, READONLY, ALIGN=2

                  tcp_output PROC
;;;897    err_t
;;;898    tcp_output(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;899    {
000004  4604              MOV      r4,r0
;;;900      struct tcp_seg *seg, *useg;
;;;901      u32_t wnd, snd_nxt;
;;;902    #if TCP_CWND_DEBUG
;;;903      s16_t i = 0;
;;;904    #endif /* TCP_CWND_DEBUG */
;;;905    
;;;906      /* pcb->state LISTEN not allowed here */
;;;907      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000006  7e00              LDRB     r0,[r0,#0x18]
000008  2801              CMP      r0,#1
00000a  d006              BEQ      |L4.26|
;;;908        pcb->state != LISTEN);
;;;909    
;;;910      /* First, check if we are invoked by the TCP input processing
;;;911         code. If so, we do not output anything. Instead, we rely on the
;;;912         input processing code to call us when input processing is done
;;;913         with. */
;;;914      if (tcp_input_pcb == pcb) {
00000c  4866              LDR      r0,|L4.424|
00000e  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
000010  42a0              CMP      r0,r4
000012  d106              BNE      |L4.34|
                  |L4.20|
;;;915        return ERR_OK;
000014  2000              MOVS     r0,#0
;;;916      }
;;;917    
;;;918      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;919    
;;;920      seg = pcb->unsent;
;;;921    
;;;922      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;923       * because the ->unsent queue is empty or because the window does
;;;924       * not allow it), construct an empty ACK segment and send it.
;;;925       *
;;;926       * If data is to be sent, we will just piggyback the ACK (see below).
;;;927       */
;;;928      if (pcb->flags & TF_ACK_NOW &&
;;;929         (seg == NULL ||
;;;930          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;931         return tcp_send_empty_ack(pcb);
;;;932      }
;;;933    
;;;934      /* useg should point to last segment on unacked queue */
;;;935      useg = pcb->unacked;
;;;936      if (useg != NULL) {
;;;937        for (; useg->next != NULL; useg = useg->next);
;;;938      }
;;;939    
;;;940    #if TCP_OUTPUT_DEBUG
;;;941      if (seg == NULL) {
;;;942        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;943                                       (void*)pcb->unsent));
;;;944      }
;;;945    #endif /* TCP_OUTPUT_DEBUG */
;;;946    #if TCP_CWND_DEBUG
;;;947      if (seg == NULL) {
;;;948        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;949                                     ", cwnd %"U16_F", wnd %"U32_F
;;;950                                     ", seg == NULL, ack %"U32_F"\n",
;;;951                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;952      } else {
;;;953        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;954                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;955                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;956                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;957                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;958                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;959      }
;;;960    #endif /* TCP_CWND_DEBUG */
;;;961      /* data available and window allows it to be sent? */
;;;962      while (seg != NULL &&
;;;963             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;964        LWIP_ASSERT("RST not expected here!", 
;;;965                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;966        /* Stop sending if the nagle algorithm would prevent it
;;;967         * Don't stop:
;;;968         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;969         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;970         *   either seg->next != NULL or pcb->unacked == NULL;
;;;971         *   RST is no sent using tcp_write/tcp_output.
;;;972         */
;;;973        if((tcp_do_output_nagle(pcb) == 0) &&
;;;974          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;975          break;
;;;976        }
;;;977    #if TCP_CWND_DEBUG
;;;978        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;979                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;980                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;981                                pcb->lastack,
;;;982                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;983        ++i;
;;;984    #endif /* TCP_CWND_DEBUG */
;;;985    
;;;986        pcb->unsent = seg->next;
;;;987    
;;;988        if (pcb->state != SYN_SENT) {
;;;989          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;990          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;991        }
;;;992    
;;;993        tcp_output_segment(seg, pcb);
;;;994        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;995        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;996          pcb->snd_nxt = snd_nxt;
;;;997        }
;;;998        /* put segment on unacknowledged list if length > 0 */
;;;999        if (TCP_TCPLEN(seg) > 0) {
;;;1000         seg->next = NULL;
;;;1001         /* unacked list is empty? */
;;;1002         if (pcb->unacked == NULL) {
;;;1003           pcb->unacked = seg;
;;;1004           useg = seg;
;;;1005         /* unacked list is not empty? */
;;;1006         } else {
;;;1007           /* In the case of fast retransmit, the packet should not go to the tail
;;;1008            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1009            * this case. -STJ Jul 27, 2004 */
;;;1010           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1011             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1012             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1013             while (*cur_seg &&
;;;1014               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1015                 cur_seg = &((*cur_seg)->next );
;;;1016             }
;;;1017             seg->next = (*cur_seg);
;;;1018             (*cur_seg) = seg;
;;;1019           } else {
;;;1020             /* add segment to tail of unacked list */
;;;1021             useg->next = seg;
;;;1022             useg = useg->next;
;;;1023           }
;;;1024         }
;;;1025       /* do not queue empty segments on the unacked list */
;;;1026       } else {
;;;1027         tcp_seg_free(seg);
;;;1028       }
;;;1029       seg = pcb->unsent;
;;;1030     }
;;;1031   #if TCP_OVERSIZE
;;;1032     if (pcb->unsent == NULL) {
;;;1033       /* last unsent has been removed, reset unsent_oversize */
;;;1034       pcb->unsent_oversize = 0;
;;;1035     }
;;;1036   #endif /* TCP_OVERSIZE */
;;;1037   
;;;1038     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1039     return ERR_OK;
;;;1040   }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L4.26|
00001a  a064              ADR      r0,|L4.428|
00001c  f7fffffe          BL       __2printf
                  |L4.32|
000020  e7fe              B        |L4.32|
                  |L4.34|
000022  f8b40060          LDRH     r0,[r4,#0x60]         ;918
000026  f8b4104c          LDRH     r1,[r4,#0x4c]         ;918
00002a  4288              CMP      r0,r1                 ;918
00002c  d300              BCC      |L4.48|
00002e  4608              MOV      r0,r1                 ;918
                  |L4.48|
000030  4681              MOV      r9,r0                 ;918
000032  7fa0              LDRB     r0,[r4,#0x1e]         ;928
000034  6ee5              LDR      r5,[r4,#0x6c]         ;928
000036  0780              LSLS     r0,r0,#30             ;928
000038  d50f              BPL      |L4.90|
00003a  b14d              CBZ      r5,|L4.80|
00003c  6928              LDR      r0,[r5,#0x10]         ;930
00003e  6840              LDR      r0,[r0,#4]            ;930
000040  f7fffffe          BL       lwip_ntohl
000044  6ca1              LDR      r1,[r4,#0x48]         ;930
000046  1a40              SUBS     r0,r0,r1              ;930
000048  8929              LDRH     r1,[r5,#8]            ;930
00004a  4401              ADD      r1,r1,r0              ;930
00004c  4549              CMP      r1,r9                 ;930
00004e  d904              BLS      |L4.90|
                  |L4.80|
000050  4620              MOV      r0,r4                 ;931
000052  e8bd47f0          POP      {r4-r10,lr}           ;931
000056  f7ffbffe          B.W      tcp_send_empty_ack
                  |L4.90|
00005a  f8d48070          LDR      r8,[r4,#0x70]         ;936
00005e  f04f0a00          MOV      r10,#0                ;936
000062  ea5f0008          MOVS     r0,r8                 ;936
000066  d101              BNE      |L4.108|
000068  e088              B        |L4.380|
                  |L4.106|
00006a  4680              MOV      r8,r0                 ;937
                  |L4.108|
00006c  f8d80000          LDR      r0,[r8,#0]            ;937
000070  2800              CMP      r0,#0                 ;937
000072  d1fa              BNE      |L4.106|
000074  e082              B        |L4.380|
                  |L4.118|
000076  6928              LDR      r0,[r5,#0x10]         ;964
000078  8980              LDRH     r0,[r0,#0xc]          ;964
00007a  f7fffffe          BL       lwip_ntohs
00007e  0740              LSLS     r0,r0,#29             ;964
000080  d503              BPL      |L4.138|
000082  a054              ADR      r0,|L4.468|
000084  f7fffffe          BL       __2printf
                  |L4.136|
000088  e7fe              B        |L4.136|
                  |L4.138|
00008a  6f20              LDR      r0,[r4,#0x70]         ;973
00008c  b1a8              CBZ      r0,|L4.186|
00008e  7fa1              LDRB     r1,[r4,#0x1e]         ;973
000090  f0110f44          TST      r1,#0x44              ;973
000094  d111              BNE      |L4.186|
000096  6ee0              LDR      r0,[r4,#0x6c]         ;973
000098  b128              CBZ      r0,|L4.166|
00009a  6802              LDR      r2,[r0,#0]            ;973
00009c  b96a              CBNZ     r2,|L4.186|
00009e  8900              LDRH     r0,[r0,#8]            ;973
0000a0  8ee2              LDRH     r2,[r4,#0x36]         ;973
0000a2  4290              CMP      r0,r2                 ;973
0000a4  d209              BCS      |L4.186|
                  |L4.166|
0000a6  f8b40066          LDRH     r0,[r4,#0x66]         ;973
0000aa  b130              CBZ      r0,|L4.186|
0000ac  f8b40068          LDRH     r0,[r4,#0x68]         ;973
0000b0  2810              CMP      r0,#0x10              ;973
0000b2  d202              BCS      |L4.186|
0000b4  f0110fa0          TST      r1,#0xa0              ;974
0000b8  d06c              BEQ      |L4.404|
                  |L4.186|
0000ba  6828              LDR      r0,[r5,#0]            ;986
0000bc  66e0              STR      r0,[r4,#0x6c]         ;988
0000be  7e20              LDRB     r0,[r4,#0x18]         ;988
0000c0  2802              CMP      r0,#2                 ;988
0000c2  d00b              BEQ      |L4.220|
0000c4  2010              MOVS     r0,#0x10              ;989
0000c6  f7fffffe          BL       lwip_htons
0000ca  4601              MOV      r1,r0                 ;989
0000cc  6928              LDR      r0,[r5,#0x10]         ;989
0000ce  8982              LDRH     r2,[r0,#0xc]          ;989
0000d0  4311              ORRS     r1,r1,r2              ;989
0000d2  8181              STRH     r1,[r0,#0xc]          ;989
0000d4  7fa0              LDRB     r0,[r4,#0x1e]         ;990
0000d6  f0200003          BIC      r0,r0,#3              ;990
0000da  77a0              STRB     r0,[r4,#0x1e]         ;990
                  |L4.220|
0000dc  4621              MOV      r1,r4                 ;993
0000de  4628              MOV      r0,r5                 ;993
0000e0  f7fffffe          BL       tcp_output_segment
0000e4  6928              LDR      r0,[r5,#0x10]         ;994
0000e6  6840              LDR      r0,[r0,#4]            ;994
0000e8  f7fffffe          BL       lwip_ntohl
0000ec  4606              MOV      r6,r0                 ;994
0000ee  6928              LDR      r0,[r5,#0x10]         ;994
0000f0  8980              LDRH     r0,[r0,#0xc]          ;994
0000f2  f7fffffe          BL       lwip_ntohs
0000f6  0780              LSLS     r0,r0,#30             ;994
0000f8  d000              BEQ      |L4.252|
0000fa  2001              MOVS     r0,#1                 ;994
                  |L4.252|
0000fc  8929              LDRH     r1,[r5,#8]            ;994
0000fe  4430              ADD      r0,r0,r6              ;994
000100  4408              ADD      r0,r0,r1              ;994
000102  6d21              LDR      r1,[r4,#0x50]         ;995
000104  1a09              SUBS     r1,r1,r0              ;995
000106  d500              BPL      |L4.266|
000108  6520              STR      r0,[r4,#0x50]         ;996
                  |L4.266|
00010a  6928              LDR      r0,[r5,#0x10]         ;999
00010c  8980              LDRH     r0,[r0,#0xc]          ;999
00010e  f7fffffe          BL       lwip_ntohs
000112  0780              LSLS     r0,r0,#30             ;999
000114  d000              BEQ      |L4.280|
000116  2001              MOVS     r0,#1                 ;999
                  |L4.280|
000118  8929              LDRH     r1,[r5,#8]            ;999
00011a  42c8              CMN      r0,r1                 ;999
00011c  d02a              BEQ      |L4.372|
00011e  f8c5a000          STR      r10,[r5,#0]           ;1002
000122  6f20              LDR      r0,[r4,#0x70]         ;1002
000124  b170              CBZ      r0,|L4.324|
000126  6928              LDR      r0,[r5,#0x10]         ;1010
000128  6840              LDR      r0,[r0,#4]            ;1010
00012a  f7fffffe          BL       lwip_ntohl
00012e  4606              MOV      r6,r0                 ;1010
000130  f8d80010          LDR      r0,[r8,#0x10]         ;1010
000134  6840              LDR      r0,[r0,#4]            ;1010
000136  f7fffffe          BL       lwip_ntohl
00013a  1a30              SUBS     r0,r6,r0              ;1010
00013c  d516              BPL      |L4.364|
00013e  f1040670          ADD      r6,r4,#0x70           ;1012
000142  e002              B        |L4.330|
                  |L4.324|
000144  6725              STR      r5,[r4,#0x70]         ;1004
000146  e013              B        |L4.368|
                  |L4.328|
000148  6836              LDR      r6,[r6,#0]            ;1015
                  |L4.330|
00014a  6830              LDR      r0,[r6,#0]            ;1013
00014c  b150              CBZ      r0,|L4.356|
00014e  6900              LDR      r0,[r0,#0x10]         ;1014
000150  6840              LDR      r0,[r0,#4]            ;1014
000152  f7fffffe          BL       lwip_ntohl
000156  4607              MOV      r7,r0                 ;1014
000158  6928              LDR      r0,[r5,#0x10]         ;1014
00015a  6840              LDR      r0,[r0,#4]            ;1014
00015c  f7fffffe          BL       lwip_ntohl
000160  1a38              SUBS     r0,r7,r0              ;1014
000162  d4f1              BMI      |L4.328|
                  |L4.356|
000164  6830              LDR      r0,[r6,#0]            ;1017
000166  6028              STR      r0,[r5,#0]            ;1018
000168  6035              STR      r5,[r6,#0]            ;1019
00016a  e006              B        |L4.378|
                  |L4.364|
00016c  f8c85000          STR      r5,[r8,#0]            ;1021
                  |L4.368|
000170  46a8              MOV      r8,r5                 ;1022
000172  e002              B        |L4.378|
                  |L4.372|
000174  4628              MOV      r0,r5                 ;1027
000176  f7fffffe          BL       tcp_seg_free
                  |L4.378|
00017a  6ee5              LDR      r5,[r4,#0x6c]         ;1029
                  |L4.380|
00017c  b155              CBZ      r5,|L4.404|
00017e  6928              LDR      r0,[r5,#0x10]         ;963
000180  6840              LDR      r0,[r0,#4]            ;963
000182  f7fffffe          BL       lwip_ntohl
000186  6ca1              LDR      r1,[r4,#0x48]         ;963
000188  1a40              SUBS     r0,r0,r1              ;963
00018a  8929              LDRH     r1,[r5,#8]            ;963
00018c  4401              ADD      r1,r1,r0              ;963
00018e  4549              CMP      r1,r9                 ;963
000190  f67faf71          BLS      |L4.118|
                  |L4.404|
000194  6ee0              LDR      r0,[r4,#0x6c]         ;1032
000196  b908              CBNZ     r0,|L4.412|
000198  f8a4a06a          STRH     r10,[r4,#0x6a]        ;1034
                  |L4.412|
00019c  7fa0              LDRB     r0,[r4,#0x1e]         ;1038
00019e  f0200080          BIC      r0,r0,#0x80           ;1038
0001a2  77a0              STRB     r0,[r4,#0x1e]         ;1038
0001a4  e736              B        |L4.20|
;;;1041   
                          ENDP

0001a6  0000              DCW      0x0000
                  |L4.424|
                          DCD      tcp_input_pcb
                  |L4.428|
0001ac  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
0001b0  74206361
0001b4  6c6c2074
0001b8  63705f6f
0001bc  75747075
0001c0  7420666f
0001c4  72206c69
0001c8  7374656e
0001cc  2d706362
0001d0  7300    
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L4.468|
0001d4  52535420          DCB      "RST not expected here!",0
0001d8  6e6f7420
0001dc  65787065
0001e0  63746564
0001e4  20686572
0001e8  652100  
0001eb  00                DCB      0

                          AREA ||i.tcp_output_alloc_header||, CODE, READONLY, ALIGN=2

                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000004  4605              MOV      r5,r0
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
000006  1888              ADDS     r0,r1,r2
000008  460f              MOV      r7,r1                 ;96
00000a  3014              ADDS     r0,r0,#0x14
00000c  b281              UXTH     r1,r0
00000e  4698              MOV      r8,r3                 ;96
000010  2200              MOVS     r2,#0
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       pbuf_alloc
000018  0006              MOVS     r6,r0
;;;99       if (p != NULL) {
00001a  d02c              BEQ      |L5.118|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
00001c  8971              LDRH     r1,[r6,#0xa]
00001e  f1070014          ADD      r0,r7,#0x14
000022  4281              CMP      r1,r0
000024  d203              BCS      |L5.46|
000026  a015              ADR      r0,|L5.124|
000028  f7fffffe          BL       __2printf
                  |L5.44|
00002c  e7fe              B        |L5.44|
                  |L5.46|
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
;;;103        tcphdr->src = htons(pcb->local_port);
00002e  8b68              LDRH     r0,[r5,#0x1a]
000030  6874              LDR      r4,[r6,#4]
000032  f7fffffe          BL       lwip_htons
000036  8020              STRH     r0,[r4,#0]
;;;104        tcphdr->dest = htons(pcb->remote_port);
000038  8ba8              LDRH     r0,[r5,#0x1c]
00003a  f7fffffe          BL       lwip_htons
00003e  8060              STRH     r0,[r4,#2]
;;;105        tcphdr->seqno = seqno_be;
000040  f8c48004          STR      r8,[r4,#4]
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
000044  6aa8              LDR      r0,[r5,#0x28]
000046  f7fffffe          BL       lwip_htonl
00004a  60a0              STR      r0,[r4,#8]
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
00004c  08b8              LSRS     r0,r7,#2
00004e  0300              LSLS     r0,r0,#12
000050  f50040a0          ADD      r0,r0,#0x5000
000054  b280              UXTH     r0,r0
000056  f0400010          ORR      r0,r0,#0x10
00005a  f7fffffe          BL       lwip_htons
00005e  81a0              STRH     r0,[r4,#0xc]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000060  8de8              LDRH     r0,[r5,#0x2e]
000062  f7fffffe          BL       lwip_htons
000066  81e0              STRH     r0,[r4,#0xe]
;;;109        tcphdr->chksum = 0;
000068  2000              MOVS     r0,#0
00006a  8220              STRH     r0,[r4,#0x10]
;;;110        tcphdr->urgp = 0;
00006c  8260              STRH     r0,[r4,#0x12]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00006e  8de9              LDRH     r1,[r5,#0x2e]
000070  6aa8              LDR      r0,[r5,#0x28]
000072  4408              ADD      r0,r0,r1
000074  6328              STR      r0,[r5,#0x30]
                  |L5.118|
;;;114      }
;;;115      return p;
000076  4630              MOV      r0,r6
;;;116    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;117    
                          ENDP

                  |L5.124|
00007c  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
000080  6b207468
000084  61742066
000088  69727374
00008c  20706275
000090  66206361
000094  6e20686f
000098  6c642073
00009c  74727563
0000a0  74207463
0000a4  705f6864
0000a8  7200    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.tcp_output_segment||, CODE, READONLY, ALIGN=2

                  tcp_output_segment PROC
;;;1048   static void
;;;1049   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;1050   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1051     u16_t len;
;;;1052     struct netif *netif;
;;;1053     u32_t *opts;
;;;1054   
;;;1055     /** @bug Exclude retransmitted segments from this count. */
;;;1056     snmp_inc_tcpoutsegs();
;;;1057   
;;;1058     /* The TCP header has already been constructed, but the ackno and
;;;1059      wnd fields remain. */
;;;1060     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
000006  6a88              LDR      r0,[r1,#0x28]
000008  f7fffffe          BL       lwip_htonl
00000c  6929              LDR      r1,[r5,#0x10]
00000e  6088              STR      r0,[r1,#8]
;;;1061   
;;;1062     /* advertise our receive window size in this TCP segment */
;;;1063     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000010  8de0              LDRH     r0,[r4,#0x2e]
000012  f7fffffe          BL       lwip_htons
000016  6929              LDR      r1,[r5,#0x10]
000018  81c8              STRH     r0,[r1,#0xe]
;;;1064   
;;;1065     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00001a  8de1              LDRH     r1,[r4,#0x2e]
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  4408              ADD      r0,r0,r1
;;;1066   
;;;1067     /* Add any requested options.  NB MSS option is only set on SYN
;;;1068        packets, so ignore it here */
;;;1069     opts = (u32_t *)(void *)(seg->tcphdr + 1);
000020  6320              STR      r0,[r4,#0x30]
;;;1070     if (seg->flags & TF_SEG_OPTS_MSS) {
000022  692e              LDR      r6,[r5,#0x10]
000024  7b28              LDRB     r0,[r5,#0xc]
000026  3614              ADDS     r6,r6,#0x14
000028  07c0              LSLS     r0,r0,#31
00002a  d009              BEQ      |L6.64|
;;;1071       u16_t mss;
;;;1072   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1073       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
00002c  1d21              ADDS     r1,r4,#4
00002e  f44f707a          MOV      r0,#0x3e8
000032  f7fffffe          BL       tcp_eff_send_mss
;;;1074   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1075       mss = TCP_MSS;
;;;1076   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1077       *opts = TCP_BUILD_MSS_OPTION(mss);
000036  f0407001          ORR      r0,r0,#0x2040000
00003a  f7fffffe          BL       lwip_htonl
00003e  6030              STR      r0,[r6,#0]
                  |L6.64|
;;;1078       opts += 1;
;;;1079     }
;;;1080   #if LWIP_TCP_TIMESTAMPS
;;;1081     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1082   
;;;1083     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1084       tcp_build_timestamp_option(pcb, opts);
;;;1085       opts += 3;
;;;1086     }
;;;1087   #endif
;;;1088   
;;;1089     /* Set retransmission timer running if it is not currently enabled 
;;;1090        This must be set before checking the route. */
;;;1091     if (pcb->rtime == -1) {
000040  f9b40034          LDRSH    r0,[r4,#0x34]
000044  2600              MOVS     r6,#0
000046  1c40              ADDS     r0,r0,#1
000048  d100              BNE      |L6.76|
;;;1092       pcb->rtime = 0;
00004a  86a6              STRH     r6,[r4,#0x34]
                  |L6.76|
;;;1093     }
;;;1094   
;;;1095     /* If we don't have a local IP address, we get one by
;;;1096        calling ip_route(). */
;;;1097     if (ip_addr_isany(&(pcb->local_ip))) {
00004c  b10c              CBZ      r4,|L6.82|
00004e  6820              LDR      r0,[r4,#0]
000050  b930              CBNZ     r0,|L6.96|
                  |L6.82|
;;;1098       netif = ip_route(&(pcb->remote_ip));
000052  1d20              ADDS     r0,r4,#4
000054  f7fffffe          BL       ip_route
;;;1099       if (netif == NULL) {
000058  2800              CMP      r0,#0
00005a  d034              BEQ      |L6.198|
;;;1100         return;
;;;1101       }
;;;1102       ip_addr_copy(pcb->local_ip, netif->ip_addr);
00005c  6840              LDR      r0,[r0,#4]
00005e  6020              STR      r0,[r4,#0]
                  |L6.96|
;;;1103     }
;;;1104   
;;;1105     if (pcb->rttest == 0) {
000060  6ba0              LDR      r0,[r4,#0x38]
000062  b938              CBNZ     r0,|L6.116|
;;;1106       pcb->rttest = tcp_ticks;
000064  4818              LDR      r0,|L6.200|
000066  6800              LDR      r0,[r0,#0]  ; tcp_ticks
;;;1107       pcb->rtseq = ntohl(seg->tcphdr->seqno);
000068  63a0              STR      r0,[r4,#0x38]
00006a  6928              LDR      r0,[r5,#0x10]
00006c  6840              LDR      r0,[r0,#4]
00006e  f7fffffe          BL       lwip_ntohl
000072  63e0              STR      r0,[r4,#0x3c]
                  |L6.116|
;;;1108   
;;;1109       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1110     }
;;;1111     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1112             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1113             seg->len));
;;;1114   
;;;1115     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
000074  6869              LDR      r1,[r5,#4]
000076  8a28              LDRH     r0,[r5,#0x10]
;;;1116   
;;;1117     seg->p->len -= len;
;;;1118     seg->p->tot_len -= len;
;;;1119   
;;;1120     seg->p->payload = seg->tcphdr;
;;;1121   
;;;1122     seg->tcphdr->chksum = 0;
;;;1123   #if CHECKSUM_GEN_TCP
;;;1124   #if TCP_CHECKSUM_ON_COPY
;;;1125     {
;;;1126       u32_t acc;
;;;1127   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1128       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1129              &(pcb->remote_ip),
;;;1130              IP_PROTO_TCP, seg->p->tot_len);
;;;1131   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1132       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1133         LWIP_ASSERT("data included but not checksummed",
;;;1134           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1135       }
;;;1136   
;;;1137       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1138       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1139                &(pcb->remote_ip),
;;;1140                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1141       /* add payload checksum */
;;;1142       if (seg->chksum_swapped) {
;;;1143         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1144         seg->chksum_swapped = 0;
;;;1145       }
;;;1146       acc += (u16_t)~(seg->chksum);
;;;1147       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1148   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1149       if (chksum_slow != seg->tcphdr->chksum) {
;;;1150         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1151                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1152                     seg->tcphdr->chksum, chksum_slow));
;;;1153         seg->tcphdr->chksum = chksum_slow;
;;;1154       }
;;;1155   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1156     }
;;;1157   #else /* TCP_CHECKSUM_ON_COPY */
;;;1158     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
000078  2306              MOVS     r3,#6
00007a  888a              LDRH     r2,[r1,#4]            ;1115
00007c  1a80              SUBS     r0,r0,r2              ;1115
00007e  894a              LDRH     r2,[r1,#0xa]          ;1117
000080  1a12              SUBS     r2,r2,r0              ;1117
000082  814a              STRH     r2,[r1,#0xa]          ;1117
000084  6869              LDR      r1,[r5,#4]            ;1118
000086  890a              LDRH     r2,[r1,#8]            ;1118
000088  1a10              SUBS     r0,r2,r0              ;1118
00008a  8108              STRH     r0,[r1,#8]            ;1118
00008c  6869              LDR      r1,[r5,#4]            ;1120
00008e  6928              LDR      r0,[r5,#0x10]         ;1120
000090  1d22              ADDS     r2,r4,#4
000092  6048              STR      r0,[r1,#4]            ;1122
000094  6928              LDR      r0,[r5,#0x10]         ;1122
000096  8206              STRH     r6,[r0,#0x10]         ;1122
000098  6868              LDR      r0,[r5,#4]
00009a  8901              LDRH     r1,[r0,#8]
00009c  9100              STR      r1,[sp,#0]
00009e  4621              MOV      r1,r4
0000a0  f7fffffe          BL       inet_chksum_pseudo
0000a4  6929              LDR      r1,[r5,#0x10]
;;;1159            &(pcb->remote_ip),
;;;1160            IP_PROTO_TCP, seg->p->tot_len);
;;;1161   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1162   #endif /* CHECKSUM_GEN_TCP */
;;;1163     TCP_STATS_INC(tcp.xmit);
;;;1164   
;;;1165   #if LWIP_NETIF_HWADDRHINT
;;;1166     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1167         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1168   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1169     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
0000a6  1d22              ADDS     r2,r4,#4
0000a8  8208              STRH     r0,[r1,#0x10]         ;1158
0000aa  4908              LDR      r1,|L6.204|
0000ac  f8310f90          LDRH     r0,[r1,#0x90]!        ;1163  ; lwip_stats
0000b0  1c40              ADDS     r0,r0,#1              ;1163
0000b2  8008              STRH     r0,[r1,#0]            ;1163
0000b4  2106              MOVS     r1,#6
0000b6  7a60              LDRB     r0,[r4,#9]
0000b8  e9cd0100          STRD     r0,r1,[sp,#0]
0000bc  7aa3              LDRB     r3,[r4,#0xa]
0000be  4621              MOV      r1,r4
0000c0  6868              LDR      r0,[r5,#4]
0000c2  f7fffffe          BL       ip_output
                  |L6.198|
;;;1170         IP_PROTO_TCP);
;;;1171   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1172   }
0000c6  bd7c              POP      {r2-r6,pc}
;;;1173   
                          ENDP

                  |L6.200|
                          DCD      tcp_ticks
                  |L6.204|
                          DCD      lwip_stats

                          AREA ||i.tcp_pbuf_prealloc||, CODE, READONLY, ALIGN=2

                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
000004  461d              MOV      r5,r3
000006  e9dd3706          LDRD     r3,r7,[sp,#0x18]
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
00000a  9e08              LDR      r6,[sp,#0x20]
00000c  460c              MOV      r4,r1                 ;222
00000e  4291              CMP      r1,r2
000010  d211              BCS      |L7.54|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
000012  07bf              LSLS     r7,r7,#30
000014  d407              BMI      |L7.38|
;;;247            (!(pcb->flags & TF_NODELAY) &&
000016  7f9f              LDRB     r7,[r3,#0x1e]
000018  067f              LSLS     r7,r7,#25
00001a  d40c              BMI      |L7.54|
;;;248             (!first_seg ||
00001c  b11e              CBZ      r6,|L7.38|
;;;249              pcb->unsent != NULL ||
00001e  6ede              LDR      r6,[r3,#0x6c]
000020  b90e              CBNZ     r6,|L7.38|
;;;250              pcb->unacked != NULL))) {
000022  6f1b              LDR      r3,[r3,#0x70]
000024  b13b              CBZ      r3,|L7.54|
                  |L7.38|
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
000026  f20431eb          ADD      r1,r4,#0x3eb
00002a  f0210103          BIC      r1,r1,#3
00002e  4291              CMP      r1,r2
000030  d800              BHI      |L7.52|
000032  460a              MOV      r2,r1
                  |L7.52|
000034  b291              UXTH     r1,r2
                  |L7.54|
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
000036  2200              MOVS     r2,#0
000038  f7fffffe          BL       pbuf_alloc
;;;256      if (p == NULL) {
00003c  2800              CMP      r0,#0
00003e  d00a              BEQ      |L7.86|
;;;257        return NULL;
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
000040  6801              LDR      r1,[r0,#0]
000042  b119              CBZ      r1,|L7.76|
000044  a005              ADR      r0,|L7.92|
000046  f7fffffe          BL       __2printf
                  |L7.74|
00004a  e7fe              B        |L7.74|
                  |L7.76|
;;;260      *oversize = p->len - length;
00004c  8941              LDRH     r1,[r0,#0xa]
00004e  1b09              SUBS     r1,r1,r4
000050  8029              STRH     r1,[r5,#0]
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
000052  8104              STRH     r4,[r0,#8]
000054  8144              STRH     r4,[r0,#0xa]
                  |L7.86|
;;;263      return p;
;;;264    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;265    #else /* TCP_OVERSIZE */
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
00005c  6e656564          DCB      "need unchained pbuf",0
000060  20756e63
000064  6861696e
000068  65642070
00006c  62756600

                          AREA ||i.tcp_rexmit||, CODE, READONLY, ALIGN=1

                  tcp_rexmit PROC
;;;1274   void
;;;1275   tcp_rexmit(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1276   {
000004  6f06              LDR      r6,[r0,#0x70]
000006  4605              MOV      r5,r0
000008  2e00              CMP      r6,#0
00000a  d020              BEQ      |L8.78|
;;;1277     struct tcp_seg *seg;
;;;1278     struct tcp_seg **cur_seg;
;;;1279   
;;;1280     if (pcb->unacked == NULL) {
;;;1281       return;
;;;1282     }
;;;1283   
;;;1284     /* Move the first unacked segment to the unsent queue */
;;;1285     /* Keep the unsent queue sorted. */
;;;1286     seg = pcb->unacked;
;;;1287     pcb->unacked = seg->next;
00000c  6830              LDR      r0,[r6,#0]
;;;1288   
;;;1289     cur_seg = &(pcb->unsent);
00000e  f105046c          ADD      r4,r5,#0x6c
;;;1290     while (*cur_seg &&
000012  6728              STR      r0,[r5,#0x70]
000014  e000              B        |L8.24|
                  |L8.22|
;;;1291       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1292         cur_seg = &((*cur_seg)->next );
000016  6824              LDR      r4,[r4,#0]
                  |L8.24|
000018  6820              LDR      r0,[r4,#0]            ;1290
00001a  b150              CBZ      r0,|L8.50|
00001c  6900              LDR      r0,[r0,#0x10]         ;1291
00001e  6840              LDR      r0,[r0,#4]            ;1291
000020  f7fffffe          BL       lwip_ntohl
000024  4607              MOV      r7,r0                 ;1291
000026  6930              LDR      r0,[r6,#0x10]         ;1291
000028  6840              LDR      r0,[r0,#4]            ;1291
00002a  f7fffffe          BL       lwip_ntohl
00002e  1a38              SUBS     r0,r7,r0              ;1291
000030  d4f1              BMI      |L8.22|
                  |L8.50|
;;;1293     }
;;;1294     seg->next = *cur_seg;
000032  6820              LDR      r0,[r4,#0]
;;;1295     *cur_seg = seg;
000034  6030              STR      r0,[r6,#0]
;;;1296   #if TCP_OVERSIZE
;;;1297     if (seg->next == NULL) {
000036  6026              STR      r6,[r4,#0]
000038  6831              LDR      r1,[r6,#0]
00003a  2000              MOVS     r0,#0
00003c  b909              CBNZ     r1,|L8.66|
;;;1298       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1299       pcb->unsent_oversize = 0;
00003e  f8a5006a          STRH     r0,[r5,#0x6a]
                  |L8.66|
;;;1300     }
;;;1301   #endif /* TCP_OVERSIZE */
;;;1302   
;;;1303     ++pcb->nrtx;
000042  f8151f46          LDRB     r1,[r5,#0x46]!
000046  1c49              ADDS     r1,r1,#1
000048  f805190e          STRB     r1,[r5],#-0xe
;;;1304   
;;;1305     /* Don't take any rtt measurements after retransmitting. */
;;;1306     pcb->rttest = 0;
00004c  6028              STR      r0,[r5,#0]
                  |L8.78|
;;;1307   
;;;1308     /* Do the actual retransmission. */
;;;1309     snmp_inc_tcpretranssegs();
;;;1310     /* No need to call tcp_output: we are always called from tcp_input()
;;;1311        and thus tcp_output directly returns. */
;;;1312   }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;1313   
                          ENDP


                          AREA ||i.tcp_rexmit_fast||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_fast PROC
;;;1320   void 
;;;1321   tcp_rexmit_fast(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1322   {
000002  4604              MOV      r4,r0
;;;1323     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000004  6f00              LDR      r0,[r0,#0x70]
000006  2800              CMP      r0,#0                 ;1322
000008  d025              BEQ      |L9.86|
00000a  7fa0              LDRB     r0,[r4,#0x1e]
00000c  0740              LSLS     r0,r0,#29
00000e  d422              BMI      |L9.86|
;;;1324       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1325       LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1326                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1327                    "), fast retransmit %"U32_F"\n",
;;;1328                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1329                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1330       tcp_rexmit(pcb);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       tcp_rexmit
;;;1331   
;;;1332       /* Set ssthresh to half of the minimum of the current
;;;1333        * cwnd and the advertised window */
;;;1334       if (pcb->cwnd > pcb->snd_wnd) {
000016  f8b4004c          LDRH     r0,[r4,#0x4c]
00001a  f8b41060          LDRH     r1,[r4,#0x60]
00001e  4288              CMP      r0,r1
000020  d901              BLS      |L9.38|
;;;1335         pcb->ssthresh = pcb->snd_wnd / 2;
000022  0848              LSRS     r0,r1,#1
000024  e000              B        |L9.40|
                  |L9.38|
;;;1336       } else {
;;;1337         pcb->ssthresh = pcb->cwnd / 2;
000026  0840              LSRS     r0,r0,#1
                  |L9.40|
000028  f8a4004e          STRH     r0,[r4,#0x4e]
;;;1338       }
;;;1339       
;;;1340       /* The minimum value for ssthresh should be 2 MSS */
;;;1341       if (pcb->ssthresh < 2*pcb->mss) {
00002c  b281              UXTH     r1,r0
00002e  8ee0              LDRH     r0,[r4,#0x36]
000030  ebb10f40          CMP      r1,r0,LSL #1
000034  d205              BCS      |L9.66|
;;;1342         LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1343                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1344                      " should be min 2 mss %"U16_F"...\n",
;;;1345                      pcb->ssthresh, 2*pcb->mss));
;;;1346         pcb->ssthresh = 2*pcb->mss;
000036  f64f71ff          MOV      r1,#0xffff
00003a  ea010140          AND      r1,r1,r0,LSL #1
00003e  f8a4104e          STRH     r1,[r4,#0x4e]
                  |L9.66|
;;;1347       }
;;;1348       
;;;1349       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
000042  b289              UXTH     r1,r1
000044  eb000040          ADD      r0,r0,r0,LSL #1
000048  4408              ADD      r0,r0,r1
00004a  f8a4004c          STRH     r0,[r4,#0x4c]
;;;1350       pcb->flags |= TF_INFR;
00004e  7fa0              LDRB     r0,[r4,#0x1e]
000050  f0400004          ORR      r0,r0,#4
000054  77a0              STRB     r0,[r4,#0x1e]
                  |L9.86|
;;;1351     } 
;;;1352   }
000056  bd10              POP      {r4,pc}
;;;1353   
                          ENDP


                          AREA ||i.tcp_rexmit_rto||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_rto PROC
;;;1238   void
;;;1239   tcp_rexmit_rto(struct tcp_pcb *pcb)
000000  6f01              LDR      r1,[r0,#0x70]
;;;1240   {
000002  2900              CMP      r1,#0
000004  d012              BEQ      |L10.44|
000006  e000              B        |L10.10|
                  |L10.8|
000008  4611              MOV      r1,r2
                  |L10.10|
;;;1241     struct tcp_seg *seg;
;;;1242   
;;;1243     if (pcb->unacked == NULL) {
;;;1244       return;
;;;1245     }
;;;1246   
;;;1247     /* Move all unacked segments to the head of the unsent queue */
;;;1248     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
00000a  680a              LDR      r2,[r1,#0]
00000c  2a00              CMP      r2,#0
00000e  d1fb              BNE      |L10.8|
;;;1249     /* concatenate unsent queue after unacked queue */
;;;1250     seg->next = pcb->unsent;
000010  6ec2              LDR      r2,[r0,#0x6c]
;;;1251     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1252     pcb->unsent = pcb->unacked;
000012  600a              STR      r2,[r1,#0]
000014  6f01              LDR      r1,[r0,#0x70]
;;;1253     /* unacked queue is now empty */
;;;1254     pcb->unacked = NULL;
000016  66c1              STR      r1,[r0,#0x6c]
000018  2100              MOVS     r1,#0
;;;1255     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1256   
;;;1257     /* increment number of retransmissions */
;;;1258     ++pcb->nrtx;
00001a  6701              STR      r1,[r0,#0x70]
00001c  f8902046          LDRB     r2,[r0,#0x46]
000020  1c52              ADDS     r2,r2,#1
000022  f8802046          STRB     r2,[r0,#0x46]
;;;1259   
;;;1260     /* Don't take any RTT measurements after retransmitting. */
;;;1261     pcb->rttest = 0;
;;;1262   
;;;1263     /* Do the actual retransmission */
;;;1264     tcp_output(pcb);
000026  6381              STR      r1,[r0,#0x38]
000028  f7ffbffe          B.W      tcp_output
                  |L10.44|
;;;1265   }
00002c  4770              BX       lr
;;;1266   
                          ENDP


                          AREA ||i.tcp_rst||, CODE, READONLY, ALIGN=2

                  tcp_rst PROC
;;;1194   void
;;;1195   tcp_rst(u32_t seqno, u32_t ackno,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1196     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1197     u16_t local_port, u16_t remote_port)
;;;1198   {
000004  4690              MOV      r8,r2
000006  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
00000a  460e              MOV      r6,r1
00000c  4683              MOV      r11,r0
00000e  461f              MOV      r7,r3
;;;1199     struct pbuf *p;
;;;1200     struct tcp_hdr *tcphdr;
;;;1201     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
000010  2200              MOVS     r2,#0
000012  2114              MOVS     r1,#0x14
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       pbuf_alloc
00001a  0005              MOVS     r5,r0
;;;1202     if (p == NULL) {
00001c  d03e              BEQ      |L11.156|
;;;1203         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
;;;1204         return;
;;;1205     }
;;;1206     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
00001e  8968              LDRH     r0,[r5,#0xa]
000020  2814              CMP      r0,#0x14
000022  d203              BCS      |L11.44|
000024  a01e              ADR      r0,|L11.160|
000026  f7fffffe          BL       __2printf
                  |L11.42|
00002a  e7fe              B        |L11.42|
                  |L11.44|
;;;1207                 (p->len >= sizeof(struct tcp_hdr)));
;;;1208   
;;;1209     tcphdr = (struct tcp_hdr *)p->payload;
;;;1210     tcphdr->src = htons(local_port);
00002c  4648              MOV      r0,r9
00002e  686c              LDR      r4,[r5,#4]
000030  f7fffffe          BL       lwip_htons
000034  8020              STRH     r0,[r4,#0]
;;;1211     tcphdr->dest = htons(remote_port);
000036  4650              MOV      r0,r10
000038  f7fffffe          BL       lwip_htons
00003c  8060              STRH     r0,[r4,#2]
;;;1212     tcphdr->seqno = htonl(seqno);
00003e  4658              MOV      r0,r11
000040  f7fffffe          BL       lwip_htonl
000044  6060              STR      r0,[r4,#4]
;;;1213     tcphdr->ackno = htonl(ackno);
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       lwip_htonl
00004c  60a0              STR      r0,[r4,#8]
;;;1214     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
00004e  f2450014          MOV      r0,#0x5014
000052  f7fffffe          BL       lwip_htons
000056  81a0              STRH     r0,[r4,#0xc]
;;;1215     tcphdr->wnd = PP_HTONS(TCP_WND);
000058  f24a000f          MOV      r0,#0xa00f
00005c  81e0              STRH     r0,[r4,#0xe]
;;;1216     tcphdr->chksum = 0;
00005e  2600              MOVS     r6,#0
000060  8226              STRH     r6,[r4,#0x10]
;;;1217     tcphdr->urgp = 0;
000062  8266              STRH     r6,[r4,#0x12]
;;;1218   
;;;1219   #if CHECKSUM_GEN_TCP
;;;1220     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
000064  8928              LDRH     r0,[r5,#8]
000066  9000              STR      r0,[sp,#0]
000068  2306              MOVS     r3,#6
00006a  463a              MOV      r2,r7
00006c  4641              MOV      r1,r8
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       inet_chksum_pseudo
;;;1221                 IP_PROTO_TCP, p->tot_len);
;;;1222   #endif
;;;1223     TCP_STATS_INC(tcp.xmit);
000074  4916              LDR      r1,|L11.208|
000076  8220              STRH     r0,[r4,#0x10]         ;1220
;;;1224     snmp_inc_tcpoutrsts();
;;;1225      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1226     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
000078  23ff              MOVS     r3,#0xff
00007a  f8310f90          LDRH     r0,[r1,#0x90]!        ;1223  ; lwip_stats
00007e  463a              MOV      r2,r7
000080  1c40              ADDS     r0,r0,#1              ;1223
000082  8008              STRH     r0,[r1,#0]            ;1223
000084  2006              MOVS     r0,#6
000086  e9cd6000          STRD     r6,r0,[sp,#0]
00008a  4641              MOV      r1,r8
00008c  4628              MOV      r0,r5
00008e  f7fffffe          BL       ip_output
;;;1227     pbuf_free(p);
000092  4628              MOV      r0,r5
000094  e8bd5ffc          POP      {r2-r12,lr}
000098  f7ffbffe          B.W      pbuf_free
                  |L11.156|
;;;1228     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1229   }
00009c  e8bd9ffc          POP      {r2-r12,pc}
;;;1230   
                          ENDP

                  |L11.160|
0000a0  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
0000a4  6b207468
0000a8  61742066
0000ac  69727374
0000b0  20706275
0000b4  66206361
0000b8  6e20686f
0000bc  6c642073
0000c0  74727563
0000c4  74207463
0000c8  705f6864
0000cc  7200    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L11.208|
                          DCD      lwip_stats

                          AREA ||i.tcp_send_empty_ack||, CODE, READONLY, ALIGN=1

                  tcp_send_empty_ack PROC
;;;841    err_t
;;;842    tcp_send_empty_ack(struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;843    {
000002  4604              MOV      r4,r0
;;;844      struct pbuf *p;
;;;845      struct tcp_hdr *tcphdr;
;;;846      u8_t optlen = 0;
000004  2500              MOVS     r5,#0
;;;847    
;;;848    #if LWIP_TCP_TIMESTAMPS
;;;849      if (pcb->flags & TF_TIMESTAMP) {
;;;850        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;851      }
;;;852    #endif
;;;853    
;;;854      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
000006  6d00              LDR      r0,[r0,#0x50]
000008  f7fffffe          BL       lwip_htonl
00000c  4603              MOV      r3,r0
00000e  2200              MOVS     r2,#0
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_output_alloc_header
000018  0005              MOVS     r5,r0
;;;855      if (p == NULL) {
00001a  d01c              BEQ      |L12.86|
;;;856        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
;;;857        return ERR_BUF;
;;;858      }
;;;859      tcphdr = (struct tcp_hdr *)p->payload;
;;;860      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;861                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;862      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;863      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
00001c  7fa0              LDRB     r0,[r4,#0x1e]
00001e  686e              LDR      r6,[r5,#4]
000020  f0200003          BIC      r0,r0,#3
000024  77a0              STRB     r0,[r4,#0x1e]
;;;864    
;;;865      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;866    #if LWIP_TCP_TIMESTAMPS
;;;867      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;868    
;;;869      if (pcb->flags & TF_TIMESTAMP) {
;;;870        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;871      }
;;;872    #endif 
;;;873    
;;;874    #if CHECKSUM_GEN_TCP
;;;875      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
000026  8928              LDRH     r0,[r5,#8]
000028  9000              STR      r0,[sp,#0]
00002a  2306              MOVS     r3,#6
00002c  1d22              ADDS     r2,r4,#4
00002e  4621              MOV      r1,r4
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       inet_chksum_pseudo
000036  8230              STRH     r0,[r6,#0x10]
;;;876            IP_PROTO_TCP, p->tot_len);
;;;877    #endif
;;;878    #if LWIP_NETIF_HWADDRHINT
;;;879      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;880          IP_PROTO_TCP, &(pcb->addr_hint));
;;;881    #else /* LWIP_NETIF_HWADDRHINT*/
;;;882      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
000038  2106              MOVS     r1,#6
00003a  7a60              LDRB     r0,[r4,#9]
00003c  e9cd0100          STRD     r0,r1,[sp,#0]
000040  7aa3              LDRB     r3,[r4,#0xa]
000042  1d22              ADDS     r2,r4,#4
000044  4621              MOV      r1,r4
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       ip_output
;;;883          IP_PROTO_TCP);
;;;884    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;885      pbuf_free(p);
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       pbuf_free
;;;886    
;;;887      return ERR_OK;
000052  2000              MOVS     r0,#0
;;;888    }
000054  bd7c              POP      {r2-r6,pc}
                  |L12.86|
000056  f06f0001          MVN      r0,#1                 ;857
00005a  bd7c              POP      {r2-r6,pc}
;;;889    
                          ENDP


                          AREA ||i.tcp_send_fin||, CODE, READONLY, ALIGN=1

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;126    {
000002  6ec4              LDR      r4,[r0,#0x6c]
000004  4605              MOV      r5,r0
000006  b90c              CBNZ     r4,|L13.12|
000008  e009              B        |L13.30|
                  |L13.10|
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;131             last_unsent = last_unsent->next);
00000a  460c              MOV      r4,r1
                  |L13.12|
00000c  6821              LDR      r1,[r4,#0]            ;130
00000e  2900              CMP      r1,#0                 ;130
000010  d1fb              BNE      |L13.10|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
000012  6920              LDR      r0,[r4,#0x10]
000014  8980              LDRH     r0,[r0,#0xc]
000016  f7fffffe          BL       lwip_ntohs
00001a  0740              LSLS     r0,r0,#29
00001c  d005              BEQ      |L13.42|
                  |L13.30|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
;;;136          pcb->flags |= TF_FIN;
;;;137          return ERR_OK;
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
00001e  4628              MOV      r0,r5
000020  e8bd4070          POP      {r4-r6,lr}
000024  2101              MOVS     r1,#1
000026  f7ffbffe          B.W      tcp_enqueue_flags
                  |L13.42|
00002a  2001              MOVS     r0,#1                 ;135
00002c  f7fffffe          BL       lwip_htons
000030  4601              MOV      r1,r0                 ;135
000032  6920              LDR      r0,[r4,#0x10]         ;135
000034  8982              LDRH     r2,[r0,#0xc]          ;135
000036  4311              ORRS     r1,r1,r2              ;135
000038  8181              STRH     r1,[r0,#0xc]          ;135
00003a  7fa8              LDRB     r0,[r5,#0x1e]         ;136
00003c  f0400020          ORR      r0,r0,#0x20           ;136
000040  77a8              STRB     r0,[r5,#0x1e]         ;136
000042  2000              MOVS     r0,#0                 ;137
;;;142    }
000044  bd70              POP      {r4-r6,pc}
;;;143    
                          ENDP


                          AREA ||i.tcp_write||, CODE, READONLY, ALIGN=2

                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
000004  4604              MOV      r4,r0
;;;356      struct pbuf *concat_p = NULL;
000006  2000              MOVS     r0,#0
000008  b08b              SUB      sp,sp,#0x2c           ;355
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
00000a  4605              MOV      r5,r0
;;;358      u16_t pos = 0; /* position in 'arg' data */
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
;;;361      u8_t optflags = 0;
00000c  9004              STR      r0,[sp,#0x10]
00000e  9005              STR      r0,[sp,#0x14]         ;357
000010  9008              STR      r0,[sp,#0x20]         ;360
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
000012  9009              STR      r0,[sp,#0x24]
000014  f8ad0018          STRH     r0,[sp,#0x18]
000018  4607              MOV      r7,r0                 ;357
00001a  4683              MOV      r11,r0                ;357
00001c  4606              MOV      r6,r0                 ;358
;;;364      u16_t oversize_used = 0;
00001e  4680              MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
000020  8ee0              LDRH     r0,[r4,#0x36]
000022  f8b41062          LDRH     r1,[r4,#0x62]
000026  4691              MOV      r9,r2                 ;355
000028  ebb00f51          CMP      r0,r1,LSR #1
00002c  d300              BCC      |L14.48|
00002e  0848              LSRS     r0,r1,#1
                  |L14.48|
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
000030  9007              STR      r0,[sp,#0x1c]
000032  980c              LDR      r0,[sp,#0x30]
000034  b1b0              CBZ      r0,|L14.100|
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
000036  4611              MOV      r1,r2
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       tcp_write_checks
;;;386      if (err != ERR_OK) {
00003e  2800              CMP      r0,#0
000040  d115              BNE      |L14.110|
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
000042  6ee0              LDR      r0,[r4,#0x6c]
000044  f8b4a068          LDRH     r10,[r4,#0x68]        ;389
000048  2800              CMP      r0,#0
00004a  d070              BEQ      |L14.302|
                  |L14.76|
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
00004c  4605              MOV      r5,r0
00004e  6800              LDR      r0,[r0,#0]
000050  2800              CMP      r0,#0
000052  d1fb              BNE      |L14.76|
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
000054  7b28              LDRB     r0,[r5,#0xc]
000056  07c1              LSLS     r1,r0,#31
000058  d000              BEQ      |L14.92|
00005a  2104              MOVS     r1,#4
                  |L14.92|
00005c  0780              LSLS     r0,r0,#30
00005e  d509              BPL      |L14.116|
000060  200c              MOVS     r0,#0xc
000062  e008              B        |L14.118|
                  |L14.100|
000064  a0c7              ADR      r0,|L14.900|
000066  f7fffffe          BL       __2printf
00006a  f06f000d          MVN      r0,#0xd               ;382
                  |L14.110|
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
;;;448        if (oversize > 0) {
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
;;;454          space -= oversize_used;
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702      }
;;;703      if (pcb->snd_queuelen != 0) {
;;;704        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;705          pcb->unsent != NULL);
;;;706      }
;;;707      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;708      return ERR_MEM;
;;;709    }
00006e  b00f              ADD      sp,sp,#0x3c
000070  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.116|
000074  2000              MOVS     r0,#0                 ;431
                  |L14.118|
000076  892b              LDRH     r3,[r5,#8]            ;432
000078  4408              ADD      r0,r0,r1              ;431
00007a  1819              ADDS     r1,r3,r0              ;432
00007c  9807              LDR      r0,[sp,#0x1c]         ;432
00007e  1a40              SUBS     r0,r0,r1              ;432
000080  b282              UXTH     r2,r0                 ;432
000082  f8b4006a          LDRH     r0,[r4,#0x6a]         ;444
000086  8969              LDRH     r1,[r5,#0xa]          ;444
000088  4288              CMP      r0,r1                 ;444
00008a  d003              BEQ      |L14.148|
00008c  a0ca              ADR      r0,|L14.952|
00008e  f7fffffe          BL       __2printf
                  |L14.146|
000092  e7fe              B        |L14.146|
                  |L14.148|
000094  f8ad0018          STRH     r0,[sp,#0x18]         ;447
000098  b1a8              CBZ      r0,|L14.198|
00009a  4590              CMP      r8,r2                 ;449
00009c  d903              BLS      |L14.166|
00009e  a0d2              ADR      r0,|L14.1000|
0000a0  f7fffffe          BL       __2printf
                  |L14.164|
0000a4  e7fe              B        |L14.164|
                  |L14.166|
0000a6  462f              MOV      r7,r5                 ;450
0000a8  4649              MOV      r1,r9                 ;451
0000aa  4548              CMP      r0,r9                 ;451
0000ac  d200              BCS      |L14.176|
0000ae  4601              MOV      r1,r0                 ;451
                  |L14.176|
0000b0  4688              MOV      r8,r1                 ;451
0000b2  eba00008          SUB      r0,r0,r8              ;453
0000b6  f8ad0018          STRH     r0,[sp,#0x18]         ;453
0000ba  eb060108          ADD      r1,r6,r8              ;452
0000be  eba20008          SUB      r0,r2,r8              ;454
0000c2  b28e              UXTH     r6,r1                 ;452
0000c4  b282              UXTH     r2,r0                 ;454
                  |L14.198|
0000c6  f8bd0018          LDRH     r0,[sp,#0x18]         ;457
0000ca  b128              CBZ      r0,|L14.216|
0000cc  454e              CMP      r6,r9                 ;457
0000ce  d003              BEQ      |L14.216|
0000d0  a0cd              ADR      r0,|L14.1032|
0000d2  f7fffffe          BL       __2printf
                  |L14.214|
0000d6  e7fe              B        |L14.214|
                  |L14.216|
0000d8  454e              CMP      r6,r9                 ;467
0000da  d23e              BCS      |L14.346|
0000dc  2a00              CMP      r2,#0                 ;467
                  |L14.222|
0000de  d03c              BEQ      |L14.346|
0000e0  2b00              CMP      r3,#0                 ;467
0000e2  d0fc              BEQ      |L14.222|
0000e4  eba90006          SUB      r0,r9,r6              ;468
0000e8  4290              CMP      r0,r2                 ;468
0000ea  dd00              BLE      |L14.238|
0000ec  4610              MOV      r0,r2                 ;468
                  |L14.238|
0000ee  b280              UXTH     r0,r0                 ;468
0000f0  9003              STR      r0,[sp,#0xc]          ;474
0000f2  980e              LDR      r0,[sp,#0x38]         ;474
0000f4  462f              MOV      r7,r5                 ;469
0000f6  07c0              LSLS     r0,r0,#31             ;474
0000f8  d01a              BEQ      |L14.304|
0000fa  2101              MOVS     r1,#1                 ;476
0000fc  980e              LDR      r0,[sp,#0x38]         ;476
0000fe  9400              STR      r4,[sp,#0]            ;476
000100  e9cd0101          STRD     r0,r1,[sp,#4]         ;476
000104  ab06              ADD      r3,sp,#0x18           ;476
000106  2003              MOVS     r0,#3                 ;476
000108  9903              LDR      r1,[sp,#0xc]          ;476
00010a  f7fffffe          BL       tcp_pbuf_prealloc
00010e  9005              STR      r0,[sp,#0x14]         ;476
000110  2800              CMP      r0,#0                 ;476
                  |L14.274|
000112  d07d              BEQ      |L14.528|
000114  8968              LDRH     r0,[r5,#0xa]          ;483
000116  f8bd1018          LDRH     r1,[sp,#0x18]         ;483
00011a  4408              ADD      r0,r0,r1              ;483
00011c  8168              STRH     r0,[r5,#0xa]          ;483
00011e  980c              LDR      r0,[sp,#0x30]         ;485
000120  9a03              LDR      r2,[sp,#0xc]          ;485
000122  1981              ADDS     r1,r0,r6              ;485
000124  9805              LDR      r0,[sp,#0x14]         ;485
000126  6840              LDR      r0,[r0,#4]            ;485
000128  f7fffffe          BL       __aeabi_memcpy
00012c  e00c              B        |L14.328|
                  |L14.302|
00012e  e015              B        |L14.348|
                  |L14.304|
000130  2201              MOVS     r2,#1                 ;491
000132  2003              MOVS     r0,#3                 ;491
000134  9903              LDR      r1,[sp,#0xc]          ;491
000136  f7fffffe          BL       pbuf_alloc
00013a  9005              STR      r0,[sp,#0x14]         ;491
00013c  2800              CMP      r0,#0                 ;491
00013e  d0e8              BEQ      |L14.274|
000140  980c              LDR      r0,[sp,#0x30]         ;503
000142  1981              ADDS     r1,r0,r6              ;503
000144  9805              LDR      r0,[sp,#0x14]         ;503
000146  6041              STR      r1,[r0,#4]            ;503
                  |L14.328|
000148  9803              LDR      r0,[sp,#0xc]          ;506
00014a  4430              ADD      r0,r0,r6              ;506
00014c  b286              UXTH     r6,r0                 ;506
00014e  9805              LDR      r0,[sp,#0x14]         ;507
000150  f7fffffe          BL       pbuf_clen
000154  4450              ADD      r0,r0,r10             ;507
000156  fa1ffa80          UXTH     r10,r0                ;507
                  |L14.346|
00015a  e080              B        |L14.606|
                  |L14.348|
00015c  f8b4006a          LDRH     r0,[r4,#0x6a]         ;511
000160  2800              CMP      r0,#0                 ;511
000162  d07c              BEQ      |L14.606|
000164  a0b0              ADR      r0,|L14.1064|
000166  f7fffffe          BL       __2printf
                  |L14.362|
00016a  e7fe              B        |L14.362|
                  |L14.364|
00016c  eba90006          SUB      r0,r9,r6              ;524
000170  b281              UXTH     r1,r0                 ;524
000172  9a04              LDR      r2,[sp,#0x10]         ;525
000174  9807              LDR      r0,[sp,#0x1c]         ;525
000176  1a80              SUBS     r0,r0,r2              ;525
000178  b280              UXTH     r0,r0                 ;525
00017a  4281              CMP      r1,r0                 ;526
00017c  d800              BHI      |L14.384|
00017e  4608              MOV      r0,r1                 ;526
                  |L14.384|
000180  9003              STR      r0,[sp,#0xc]          ;532
000182  980e              LDR      r0,[sp,#0x38]         ;532
000184  07c0              LSLS     r0,r0,#31             ;532
000186  d026              BEQ      |L14.470|
000188  f1bb0f00          CMP      r11,#0                ;535
00018c  d017              BEQ      |L14.446|
00018e  2000              MOVS     r0,#0                 ;535
                  |L14.400|
000190  990e              LDR      r1,[sp,#0x38]         ;535
000192  9400              STR      r4,[sp,#0]            ;535
000194  e9cd1001          STRD     r1,r0,[sp,#4]         ;535
000198  9803              LDR      r0,[sp,#0xc]          ;535
00019a  ab06              ADD      r3,sp,#0x18           ;535
00019c  4410              ADD      r0,r0,r2              ;535
00019e  b281              UXTH     r1,r0                 ;535
0001a0  2000              MOVS     r0,#0                 ;535
0001a2  9a07              LDR      r2,[sp,#0x1c]         ;535
0001a4  f7fffffe          BL       tcp_pbuf_prealloc
0001a8  9001              STR      r0,[sp,#4]            ;535
0001aa  2800              CMP      r0,#0                 ;535
0001ac  d0b1              BEQ      |L14.274|
0001ae  8941              LDRH     r1,[r0,#0xa]          ;539
0001b0  9803              LDR      r0,[sp,#0xc]          ;539
0001b2  4281              CMP      r1,r0                 ;539
0001b4  d205              BCS      |L14.450|
0001b6  a0a8              ADR      r0,|L14.1112|
0001b8  f7fffffe          BL       __2printf
                  |L14.444|
0001bc  e7fe              B        |L14.444|
                  |L14.446|
0001be  2001              MOVS     r0,#1                 ;535
0001c0  e7e6              B        |L14.400|
                  |L14.450|
0001c2  980c              LDR      r0,[sp,#0x30]         ;541
0001c4  1981              ADDS     r1,r0,r6              ;541
0001c6  9801              LDR      r0,[sp,#4]            ;541
0001c8  6842              LDR      r2,[r0,#4]            ;541
0001ca  9804              LDR      r0,[sp,#0x10]         ;541
0001cc  4410              ADD      r0,r0,r2              ;541
0001ce  9a03              LDR      r2,[sp,#0xc]          ;541
0001d0  f7fffffe          BL       __aeabi_memcpy
0001d4  e01a              B        |L14.524|
                  |L14.470|
0001d6  f8bd0018          LDRH     r0,[sp,#0x18]         ;550
0001da  b118              CBZ      r0,|L14.484|
0001dc  a0ae              ADR      r0,|L14.1176|
0001de  f7fffffe          BL       __2printf
                  |L14.482|
0001e2  e7fe              B        |L14.482|
                  |L14.484|
0001e4  2201              MOVS     r2,#1                 ;552
0001e6  2000              MOVS     r0,#0                 ;552
0001e8  9903              LDR      r1,[sp,#0xc]          ;552
0001ea  f7fffffe          BL       pbuf_alloc
0001ee  0007              MOVS     r7,r0                 ;552
0001f0  d08f              BEQ      |L14.274|
0001f2  980c              LDR      r0,[sp,#0x30]         ;561
0001f4  2200              MOVS     r2,#0                 ;564
0001f6  4430              ADD      r0,r0,r6              ;561
0001f8  6078              STR      r0,[r7,#4]            ;564
0001fa  4610              MOV      r0,r2                 ;564
0001fc  9904              LDR      r1,[sp,#0x10]         ;564
0001fe  f7fffffe          BL       pbuf_alloc
000202  9001              STR      r0,[sp,#4]            ;564
000204  b188              CBZ      r0,|L14.554|
000206  4639              MOV      r1,r7                 ;572
000208  f7fffffe          BL       pbuf_cat
                  |L14.524|
00020c  9801              LDR      r0,[sp,#4]            ;575
00020e  e000              B        |L14.530|
                  |L14.528|
000210  e093              B        |L14.826|
                  |L14.530|
000212  f7fffffe          BL       pbuf_clen
000216  4450              ADD      r0,r0,r10             ;575
000218  fa1ffa80          UXTH     r10,r0                ;575
00021c  f1ba0f10          CMP      r10,#0x10             ;580
000220  d905              BLS      |L14.558|
000222  9801              LDR      r0,[sp,#4]            ;582
                  |L14.548|
000224  f7fffffe          BL       pbuf_free
000228  e08c              B        |L14.836|
                  |L14.554|
00022a  4638              MOV      r0,r7                 ;567
00022c  e7fa              B        |L14.548|
                  |L14.558|
00022e  9809              LDR      r0,[sp,#0x24]         ;586
000230  9000              STR      r0,[sp,#0]            ;586
000232  6de0              LDR      r0,[r4,#0x5c]         ;586
000234  2200              MOVS     r2,#0                 ;586
000236  1983              ADDS     r3,r0,r6              ;586
000238  4620              MOV      r0,r4                 ;586
00023a  9901              LDR      r1,[sp,#4]            ;586
00023c  f7fffffe          BL       tcp_create_segment
000240  0007              MOVS     r7,r0                 ;586
000242  d07f              BEQ      |L14.836|
000244  f8bd0018          LDRH     r0,[sp,#0x18]         ;590
000248  8178              STRH     r0,[r7,#0xa]          ;590
00024a  f1bb0f00          CMP      r11,#0                ;599
00024e  d00d              BEQ      |L14.620|
000250  9808              LDR      r0,[sp,#0x20]         ;603
000252  b168              CBZ      r0,|L14.624|
000254  6007              STR      r7,[r0,#0]            ;604
                  |L14.598|
000256  9708              STR      r7,[sp,#0x20]         ;613
000258  9803              LDR      r0,[sp,#0xc]          ;613
00025a  4430              ADD      r0,r0,r6              ;613
00025c  b286              UXTH     r6,r0                 ;613
                  |L14.606|
00025e  454e              CMP      r6,r9                 ;522
000260  d384              BCC      |L14.364|
000262  f1b80f00          CMP      r8,#0                 ;626
000266  d029              BEQ      |L14.700|
000268  686e              LDR      r6,[r5,#4]            ;629
00026a  e017              B        |L14.668|
                  |L14.620|
00026c  46bb              MOV      r11,r7                ;600
00026e  e7f2              B        |L14.598|
                  |L14.624|
000270  a08d              ADR      r0,|L14.1192|
000272  f7fffffe          BL       __2printf
                  |L14.630|
000276  e7fe              B        |L14.630|
                  |L14.632|
000278  8931              LDRH     r1,[r6,#8]            ;630
00027a  eb010008          ADD      r0,r1,r8              ;630
00027e  8130              STRH     r0,[r6,#8]            ;630
000280  6830              LDR      r0,[r6,#0]            ;631
000282  b950              CBNZ     r0,|L14.666|
000284  8971              LDRH     r1,[r6,#0xa]          ;632
000286  6870              LDR      r0,[r6,#4]            ;632
000288  4642              MOV      r2,r8                 ;632
00028a  4408              ADD      r0,r0,r1              ;632
00028c  990c              LDR      r1,[sp,#0x30]         ;632
00028e  f7fffffe          BL       __aeabi_memcpy
000292  8971              LDRH     r1,[r6,#0xa]          ;633
000294  eb010008          ADD      r0,r1,r8              ;633
000298  8170              STRH     r0,[r6,#0xa]          ;633
                  |L14.666|
00029a  6836              LDR      r6,[r6,#0]            ;629
                  |L14.668|
00029c  2e00              CMP      r6,#0                 ;629
00029e  d1eb              BNE      |L14.632|
0002a0  8929              LDRH     r1,[r5,#8]            ;636
0002a2  eb010008          ADD      r0,r1,r8              ;636
0002a6  8128              STRH     r0,[r5,#8]            ;636
0002a8  8968              LDRH     r0,[r5,#0xa]          ;638
0002aa  4540              CMP      r0,r8                 ;638
0002ac  d203              BCS      |L14.694|
0002ae  a083              ADR      r0,|L14.1212|
0002b0  f7fffffe          BL       __2printf
                  |L14.692|
0002b4  e7fe              B        |L14.692|
                  |L14.694|
0002b6  eba00008          SUB      r0,r0,r8              ;640
0002ba  8168              STRH     r0,[r5,#0xa]          ;640
                  |L14.700|
0002bc  f8bd0018          LDRH     r0,[sp,#0x18]         ;643
0002c0  f8a4006a          STRH     r0,[r4,#0x6a]         ;643
0002c4  9805              LDR      r0,[sp,#0x14]         ;649
0002c6  b170              CBZ      r0,|L14.742|
0002c8  b14d              CBZ      r5,|L14.734|
0002ca  6868              LDR      r0,[r5,#4]            ;652
0002cc  9905              LDR      r1,[sp,#0x14]         ;652
0002ce  f7fffffe          BL       pbuf_cat
0002d2  9805              LDR      r0,[sp,#0x14]         ;653
0002d4  8929              LDRH     r1,[r5,#8]            ;653
0002d6  8900              LDRH     r0,[r0,#8]            ;653
0002d8  4408              ADD      r0,r0,r1              ;653
0002da  8128              STRH     r0,[r5,#8]            ;653
0002dc  e004              B        |L14.744|
                  |L14.734|
0002de  a082              ADR      r0,|L14.1256|
0002e0  f7fffffe          BL       __2printf
                  |L14.740|
0002e4  e7fe              B        |L14.740|
                  |L14.742|
0002e6  b19d              CBZ      r5,|L14.784|
                  |L14.744|
0002e8  f8c5b000          STR      r11,[r5,#0]           ;670
                  |L14.748|
0002ec  6de1              LDR      r1,[r4,#0x5c]         ;676
0002ee  eb010009          ADD      r0,r1,r9              ;676
0002f2  65e0              STR      r0,[r4,#0x5c]         ;677
0002f4  f8b41066          LDRH     r1,[r4,#0x66]         ;677
0002f8  eba10009          SUB      r0,r1,r9              ;677
0002fc  f8a40066          STRH     r0,[r4,#0x66]         ;677
000300  ea5f000a          MOVS     r0,r10                ;678
000304  f8a40068          STRH     r0,[r4,#0x68]         ;678
000308  d007              BEQ      |L14.794|
00030a  6f20              LDR      r0,[r4,#0x70]         ;683
00030c  b118              CBZ      r0,|L14.790|
00030e  e004              B        |L14.794|
                  |L14.784|
000310  f8c4b06c          STR      r11,[r4,#0x6c]        ;668
000314  e7ea              B        |L14.748|
                  |L14.790|
000316  6ee0              LDR      r0,[r4,#0x6c]         ;683
000318  b180              CBZ      r0,|L14.828|
                  |L14.794|
00031a  b167              CBZ      r7,|L14.822|
00031c  6938              LDR      r0,[r7,#0x10]         ;688
00031e  b150              CBZ      r0,|L14.822|
000320  980e              LDR      r0,[sp,#0x38]         ;688
000322  0780              LSLS     r0,r0,#30             ;688
000324  d407              BMI      |L14.822|
000326  2008              MOVS     r0,#8                 ;689
000328  f7fffffe          BL       lwip_htons
00032c  4601              MOV      r1,r0                 ;689
00032e  6938              LDR      r0,[r7,#0x10]         ;689
000330  8982              LDRH     r2,[r0,#0xc]          ;689
000332  4311              ORRS     r1,r1,r2              ;689
000334  8181              STRH     r1,[r0,#0xc]          ;689
                  |L14.822|
000336  2000              MOVS     r0,#0                 ;692
000338  e699              B        |L14.110|
                  |L14.826|
00033a  e003              B        |L14.836|
                  |L14.828|
00033c  a078              ADR      r0,|L14.1312|
00033e  f7fffffe          BL       __2printf
                  |L14.834|
000342  e7fe              B        |L14.834|
                  |L14.836|
000344  7fa0              LDRB     r0,[r4,#0x1e]         ;694
000346  f0400080          ORR      r0,r0,#0x80           ;694
00034a  77a0              STRB     r0,[r4,#0x1e]         ;694
00034c  487c              LDR      r0,|L14.1344|
00034e  f8301f9c          LDRH     r1,[r0,#0x9c]!        ;695  ; lwip_stats
000352  1c49              ADDS     r1,r1,#1              ;695
000354  8001              STRH     r1,[r0,#0]            ;695
000356  9805              LDR      r0,[sp,#0x14]         ;697
000358  b108              CBZ      r0,|L14.862|
00035a  f7fffffe          BL       pbuf_free
                  |L14.862|
00035e  f1bb0000          SUBS     r0,r11,#0             ;700
000362  d001              BEQ      |L14.872|
000364  f7fffffe          BL       tcp_segs_free
                  |L14.872|
000368  f8b40068          LDRH     r0,[r4,#0x68]         ;703
00036c  b118              CBZ      r0,|L14.886|
00036e  6f20              LDR      r0,[r4,#0x70]         ;704
000370  b908              CBNZ     r0,|L14.886|
000372  6ee0              LDR      r0,[r4,#0x6c]         ;704
000374  b110              CBZ      r0,|L14.892|
                  |L14.886|
000376  f04f30ff          MOV      r0,#0xffffffff        ;708
00037a  e678              B        |L14.110|
                  |L14.892|
00037c  a068              ADR      r0,|L14.1312|
00037e  f7fffffe          BL       __2printf
                  |L14.898|
000382  e7fe              B        |L14.898|
;;;710    
                          ENDP

                  |L14.900|
000384  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
000388  77726974
00038c  653a2061
000390  7267203d
000394  3d204e55
000398  4c4c2028
00039c  70726f67
0003a0  72616d6d
0003a4  65722076
0003a8  696f6c61
0003ac  74657320
0003b0  41504929
0003b4  00      
0003b5  00                DCB      0
0003b6  00                DCB      0
0003b7  00                DCB      0
                  |L14.952|
0003b8  756e7365          DCB      "unsent_oversize mismatch (pcb vs. last_unsent)",0
0003bc  6e745f6f
0003c0  76657273
0003c4  697a6520
0003c8  6d69736d
0003cc  61746368
0003d0  20287063
0003d4  62207673
0003d8  2e206c61
0003dc  73745f75
0003e0  6e73656e
0003e4  742900  
0003e7  00                DCB      0
                  |L14.1000|
0003e8  696e636f          DCB      "inconsistent oversize vs. space",0
0003ec  6e736973
0003f0  74656e74
0003f4  206f7665
0003f8  7273697a
0003fc  65207673
000400  2e207370
000404  61636500
                  |L14.1032|
000408  696e636f          DCB      "inconsistend oversize vs. len",0
00040c  6e736973
000410  74656e64
000414  206f7665
000418  7273697a
00041c  65207673
000420  2e206c65
000424  6e00    
000426  00                DCB      0
000427  00                DCB      0
                  |L14.1064|
000428  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
00042c  6e745f6f
000430  76657273
000434  697a6520
000438  6d69736d
00043c  61746368
000440  20287063
000444  622d3e75
000448  6e73656e
00044c  74206973
000450  204e554c
000454  4c2900  
000457  00                DCB      0
                  |L14.1112|
000458  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
00045c  77726974
000460  653a2063
000464  6865636b
000468  20746861
00046c  74206669
000470  72737420
000474  70627566
000478  2063616e
00047c  20686f6c
000480  64207468
000484  6520636f
000488  6d706c65
00048c  746520  
00048f  7365676c          DCB      "seglen",0
000493  656e00  
000496  00                DCB      0
000497  00                DCB      0
                  |L14.1176|
000498  6f766572          DCB      "oversize == 0",0
00049c  73697a65
0004a0  203d3d20
0004a4  3000    
0004a6  00                DCB      0
0004a7  00                DCB      0
                  |L14.1192|
0004a8  70726576          DCB      "prev_seg != NULL",0
0004ac  5f736567
0004b0  20213d20
0004b4  4e554c4c
0004b8  00      
0004b9  00                DCB      0
0004ba  00                DCB      0
0004bb  00                DCB      0
                  |L14.1212|
0004bc  6c617374          DCB      "last_unsent->oversize_left >= oversize_used",0
0004c0  5f756e73
0004c4  656e742d
0004c8  3e6f7665
0004cc  7273697a
0004d0  655f6c65
0004d4  6674203e
0004d8  3d206f76
0004dc  65727369
0004e0  7a655f75
0004e4  73656400
                  |L14.1256|
0004e8  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
0004ec  77726974
0004f0  653a2063
0004f4  616e6e6f
0004f8  7420636f
0004fc  6e636174
000500  656e6174
000504  65207768
000508  656e2070
00050c  63622d3e
000510  756e7365
000514  6e742069
000518  7320656d
00051c  707479  
00051f  00                DCB      0
                  |L14.1312|
000520  7463705f          DCB      "tcp_write: valid queue length",0
000524  77726974
000528  653a2076
00052c  616c6964
000530  20717565
000534  7565206c
000538  656e6774
00053c  6800    
00053e  00                DCB      0
00053f  00                DCB      0
                  |L14.1344|
                          DCD      lwip_stats

                          AREA ||i.tcp_write_checks||, CODE, READONLY, ALIGN=2

                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000000  b510              PUSH     {r4,lr}
;;;295    {
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
000002  7e02              LDRB     r2,[r0,#0x18]
000004  2a04              CMP      r2,#4
000006  d008              BEQ      |L15.26|
;;;298          (pcb->state != CLOSE_WAIT) &&
000008  2a07              CMP      r2,#7
00000a  d006              BEQ      |L15.26|
;;;299          (pcb->state != SYN_SENT) &&
00000c  2a02              CMP      r2,#2
00000e  d004              BEQ      |L15.26|
;;;300          (pcb->state != SYN_RCVD)) {
000010  2a03              CMP      r2,#3
000012  d002              BEQ      |L15.26|
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
;;;302        return ERR_CONN;
000014  f06f000c          MVN      r0,#0xc
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
000018  bd10              POP      {r4,pc}
                  |L15.26|
00001a  2900              CMP      r1,#0                 ;303
00001c  d026              BEQ      |L15.108|
00001e  f8b02066          LDRH     r2,[r0,#0x66]         ;308
000022  f04f33ff          MOV      r3,#0xffffffff        ;312
000026  428a              CMP      r2,r1                 ;308
000028  d205              BCS      |L15.54|
                  |L15.42|
00002a  7f81              LDRB     r1,[r0,#0x1e]         ;311
00002c  f0410180          ORR      r1,r1,#0x80           ;311
000030  7781              STRB     r1,[r0,#0x1e]         ;311
000032  4618              MOV      r0,r3                 ;312
000034  bd10              POP      {r4,pc}
                  |L15.54|
000036  f8b01068          LDRH     r1,[r0,#0x68]         ;320
00003a  2910              CMP      r1,#0x10              ;320
00003c  d305              BCC      |L15.74|
00003e  490c              LDR      r1,|L15.112|
000040  f8312f9c          LDRH     r2,[r1,#0x9c]!        ;323  ; lwip_stats
000044  1c52              ADDS     r2,r2,#1              ;323
000046  800a              STRH     r2,[r1,#0]            ;323
000048  e7ef              B        |L15.42|
                  |L15.74|
00004a  2900              CMP      r1,#0                 ;327
00004c  6f01              LDR      r1,[r0,#0x70]         ;327
00004e  d006              BEQ      |L15.94|
000050  b961              CBNZ     r1,|L15.108|
000052  6ec0              LDR      r0,[r0,#0x6c]         ;328
000054  b950              CBNZ     r0,|L15.108|
000056  a007              ADR      r0,|L15.116|
000058  f7fffffe          BL       __2printf
                  |L15.92|
00005c  e7fe              B        |L15.92|
                  |L15.94|
00005e  b909              CBNZ     r1,|L15.100|
000060  6ec0              LDR      r0,[r0,#0x6c]         ;331
000062  b118              CBZ      r0,|L15.108|
                  |L15.100|
000064  a012              ADR      r0,|L15.176|
000066  f7fffffe          BL       __2printf
                  |L15.106|
00006a  e7fe              B        |L15.106|
                  |L15.108|
00006c  2000              MOVS     r0,#0                 ;334
00006e  bd10              POP      {r4,pc}
;;;336    
                          ENDP

                  |L15.112|
                          DCD      lwip_stats
                  |L15.116|
000074  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
000078  77726974
00007c  653a2070
000080  62756673
000084  206f6e20
000088  71756575
00008c  65203d3e
000090  20617420
000094  6c656173
000098  74206f6e
00009c  65207175
0000a0  65756520
0000a4  6e6f6e2d
0000a8  656d70  
0000ab  747900            DCB      "ty",0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L15.176|
0000b0  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
0000b4  77726974
0000b8  653a206e
0000bc  6f207062
0000c0  75667320
0000c4  6f6e2071
0000c8  75657565
0000cc  203d3e20
0000d0  626f7468
0000d4  20717565
0000d8  75657320
0000dc  656d7074
0000e0  7900    
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.tcp_zero_window_probe||, CODE, READONLY, ALIGN=2

                  tcp_zero_window_probe PROC
;;;1413   void
;;;1414   tcp_zero_window_probe(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1415   {
000004  6f04              LDR      r4,[r0,#0x70]
000006  4605              MOV      r5,r0
000008  b914              CBNZ     r4,|L16.16|
;;;1416     struct pbuf *p;
;;;1417     struct tcp_hdr *tcphdr;
;;;1418     struct tcp_seg *seg;
;;;1419     u16_t len;
;;;1420     u8_t is_fin;
;;;1421   
;;;1422     LWIP_DEBUGF(TCP_DEBUG, 
;;;1423                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1424                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1425                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1426                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1427   
;;;1428     LWIP_DEBUGF(TCP_DEBUG, 
;;;1429                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1430                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1431                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1432   
;;;1433     seg = pcb->unacked;
;;;1434   
;;;1435     if(seg == NULL) {
;;;1436       seg = pcb->unsent;
00000a  6eec              LDR      r4,[r5,#0x6c]
00000c  2c00              CMP      r4,#0
00000e  d04c              BEQ      |L16.170|
                  |L16.16|
;;;1437     }
;;;1438     if(seg == NULL) {
;;;1439       return;
;;;1440     }
;;;1441   
;;;1442     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
000010  6920              LDR      r0,[r4,#0x10]
000012  8980              LDRH     r0,[r0,#0xc]
000014  f7fffffe          BL       lwip_ntohs
000018  07c0              LSLS     r0,r0,#31
00001a  d001              BEQ      |L16.32|
00001c  8920              LDRH     r0,[r4,#8]
00001e  b1c8              CBZ      r0,|L16.84|
                  |L16.32|
000020  2000              MOVS     r0,#0
                  |L16.34|
000022  ea5f0800          MOVS     r8,r0
;;;1443     /* we want to send one seqno: either FIN or data (no options) */
;;;1444     len = is_fin ? 0 : 1;
000026  d017              BEQ      |L16.88|
000028  2200              MOVS     r2,#0
                  |L16.42|
;;;1445   
;;;1446     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
00002a  6920              LDR      r0,[r4,#0x10]
00002c  2100              MOVS     r1,#0
00002e  6843              LDR      r3,[r0,#4]
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       tcp_output_alloc_header
000036  0007              MOVS     r7,r0
;;;1447     if(p == NULL) {
000038  d037              BEQ      |L16.170|
;;;1448       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1449       return;
;;;1450     }
;;;1451     tcphdr = (struct tcp_hdr *)p->payload;
;;;1452   
;;;1453     if (is_fin) {
00003a  687e              LDR      r6,[r7,#4]
00003c  f1b80f00          CMP      r8,#0
000040  d00c              BEQ      |L16.92|
;;;1454       /* FIN segment, no data */
;;;1455       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
000042  2011              MOVS     r0,#0x11
000044  f7fffffe          BL       lwip_htons
000048  89b1              LDRH     r1,[r6,#0xc]
00004a  f421517c          BIC      r1,r1,#0x3f00
00004e  4308              ORRS     r0,r0,r1
000050  81b0              STRH     r0,[r6,#0xc]
000052  e00d              B        |L16.112|
                  |L16.84|
000054  2001              MOVS     r0,#1                 ;1442
000056  e7e4              B        |L16.34|
                  |L16.88|
000058  2201              MOVS     r2,#1                 ;1444
00005a  e7e6              B        |L16.42|
                  |L16.92|
;;;1456     } else {
;;;1457       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1458       char *d = ((char *)p->payload + TCP_HLEN);
;;;1459       /* Depending on whether the segment has already been sent (unacked) or not
;;;1460          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1461          Ensure we copy the first TCP data byte: */
;;;1462       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
00005c  6860              LDR      r0,[r4,#4]
00005e  8923              LDRH     r3,[r4,#8]
000060  f1060114          ADD      r1,r6,#0x14           ;1458
000064  8902              LDRH     r2,[r0,#8]
000066  1ad2              SUBS     r2,r2,r3
000068  b293              UXTH     r3,r2
00006a  2201              MOVS     r2,#1
00006c  f7fffffe          BL       pbuf_copy_partial
                  |L16.112|
;;;1463     }
;;;1464   
;;;1465   #if CHECKSUM_GEN_TCP
;;;1466     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
000070  8938              LDRH     r0,[r7,#8]
000072  9000              STR      r0,[sp,#0]
000074  2306              MOVS     r3,#6
000076  1d2a              ADDS     r2,r5,#4
000078  4629              MOV      r1,r5
00007a  4638              MOV      r0,r7
00007c  f7fffffe          BL       inet_chksum_pseudo
;;;1467                                         IP_PROTO_TCP, p->tot_len);
;;;1468   #endif
;;;1469     TCP_STATS_INC(tcp.xmit);
000080  490b              LDR      r1,|L16.176|
000082  8230              STRH     r0,[r6,#0x10]         ;1466
;;;1470   
;;;1471     /* Send output to IP */
;;;1472   #if LWIP_NETIF_HWADDRHINT
;;;1473     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1474       &(pcb->addr_hint));
;;;1475   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1476     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
000084  1d2a              ADDS     r2,r5,#4
000086  f8310f90          LDRH     r0,[r1,#0x90]!        ;1469  ; lwip_stats
00008a  1c40              ADDS     r0,r0,#1              ;1469
00008c  8008              STRH     r0,[r1,#0]            ;1469
00008e  2106              MOVS     r1,#6
000090  2000              MOVS     r0,#0
000092  e9cd0100          STRD     r0,r1,[sp,#0]
000096  7aab              LDRB     r3,[r5,#0xa]
000098  4629              MOV      r1,r5
00009a  4638              MOV      r0,r7
00009c  f7fffffe          BL       ip_output
;;;1477   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1478   
;;;1479     pbuf_free(p);
0000a0  4638              MOV      r0,r7
0000a2  e8bd41fc          POP      {r2-r8,lr}
0000a6  f7ffbffe          B.W      pbuf_free
                  |L16.170|
;;;1480   
;;;1481     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1482                             " ackno %"U32_F".\n",
;;;1483                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1484   }
0000aa  e8bd81fc          POP      {r2-r8,pc}
;;;1485   #endif /* LWIP_TCP */
                          ENDP

0000ae  0000              DCW      0x0000
                  |L16.176|
                          DCD      lwip_stats

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    
