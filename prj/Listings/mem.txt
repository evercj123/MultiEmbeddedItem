; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mem.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\mem.crf ..\lwip\src\core\mem.c]
                          THUMB

                          AREA ||i.mem_calloc||, CODE, READONLY, ALIGN=1

                  mem_calloc PROC
;;;645     */
;;;646    void *mem_calloc(mem_size_t count, mem_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;647    {
;;;648      void *p;
;;;649    
;;;650      /* allocate 'count' objects of size 'size' */
;;;651      p = mem_malloc(count * size);
000002  fb00f501          MUL      r5,r0,r1
000006  b2a8              UXTH     r0,r5
000008  f7fffffe          BL       mem_malloc
00000c  0004              MOVS     r4,r0
;;;652      if (p) {
00000e  d002              BEQ      |L1.22|
000010  4629              MOV      r1,r5
;;;653        /* zero the memory */
;;;654        memset(p, 0, count * size);
000012  f7fffffe          BL       __aeabi_memclr
                  |L1.22|
;;;655      }
;;;656      return p;
000016  4620              MOV      r0,r4
;;;657    }
000018  bd70              POP      {r4-r6,pc}
;;;658    
                          ENDP


                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                  mem_free PROC
;;;310    void
;;;311    mem_free(void *rmem)
000000  b510              PUSH     {r4,lr}
;;;312    {
000002  2800              CMP      r0,#0
000004  d02a              BEQ      |L2.92|
;;;313      struct mem *mem;
;;;314      LWIP_MEM_FREE_DECL_PROTECT();
;;;315    
;;;316      if (rmem == NULL) {
;;;317        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
;;;318        return;
;;;319      }
;;;320      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
000006  0781              LSLS     r1,r0,#30
000008  d003              BEQ      |L2.18|
00000a  a015              ADR      r0,|L2.96|
00000c  f7fffffe          BL       __2printf
                  |L2.16|
000010  e7fe              B        |L2.16|
                  |L2.18|
;;;321    
;;;322      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
000012  4a1c              LDR      r2,|L2.132|
000014  6811              LDR      r1,[r2,#0]  ; ram
000016  4288              CMP      r0,r1
000018  d302              BCC      |L2.32|
00001a  6853              LDR      r3,[r2,#4]  ; ram_end
00001c  4298              CMP      r0,r3
00001e  d303              BCC      |L2.40|
                  |L2.32|
000020  a019              ADR      r0,|L2.136|
000022  f7fffffe          BL       __2printf
                  |L2.38|
000026  e7fe              B        |L2.38|
                  |L2.40|
;;;323        (u8_t *)rmem < (u8_t *)ram_end);
;;;324    
;;;325      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;326        SYS_ARCH_DECL_PROTECT(lev);
;;;327        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;328        /* protect mem stats from concurrent access */
;;;329        SYS_ARCH_PROTECT(lev);
;;;330        MEM_STATS_INC(illegal);
;;;331        SYS_ARCH_UNPROTECT(lev);
;;;332        return;
;;;333      }
;;;334      /* protect the heap from concurrent access */
;;;335      LWIP_MEM_FREE_PROTECT();
;;;336      /* Get the corresponding struct mem ... */
;;;337      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;338      /* ... which has to be in a used state ... */
;;;339      LWIP_ASSERT("mem_free: mem->used", mem->used);
000028  f8103c04          LDRB     r3,[r0,#-4]
00002c  3808              SUBS     r0,r0,#8
00002e  b18b              CBZ      r3,|L2.84|
;;;340      /* ... and is now unused. */
;;;341      mem->used = 0;
000030  2300              MOVS     r3,#0
000032  7103              STRB     r3,[r0,#4]
;;;342    
;;;343      if (mem < lfree) {
000034  6893              LDR      r3,[r2,#8]  ; lfree
000036  4298              CMP      r0,r3
000038  d200              BCS      |L2.60|
;;;344        /* the newly freed struct is now the lowest */
;;;345        lfree = mem;
00003a  6090              STR      r0,[r2,#8]  ; lfree
                  |L2.60|
;;;346      }
;;;347    
;;;348      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
00003c  8802              LDRH     r2,[r0,#0]
00003e  1a41              SUBS     r1,r0,r1
000040  1a52              SUBS     r2,r2,r1
000042  4917              LDR      r1,|L2.160|
000044  f8313fae          LDRH     r3,[r1,#0xae]!  ; lwip_stats
000048  1a9a              SUBS     r2,r3,r2
00004a  800a              STRH     r2,[r1,#0]
;;;349    
;;;350      /* finally, see if prev or next are free also */
;;;351      plug_holes(mem);
00004c  e8bd4010          POP      {r4,lr}
000050  f7ffbffe          B.W      plug_holes
                  |L2.84|
000054  a013              ADR      r0,|L2.164|
000056  f7fffffe          BL       __2printf
                  |L2.90|
00005a  e7fe              B        |L2.90|
                  |L2.92|
;;;352    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;353      mem_free_count = 1;
;;;354    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;355      LWIP_MEM_FREE_UNPROTECT();
;;;356    }
00005c  bd10              POP      {r4,pc}
;;;357    
                          ENDP

00005e  0000              DCW      0x0000
                  |L2.96|
000060  6d656d5f          DCB      "mem_free: sanity check alignment",0
000064  66726565
000068  3a207361
00006c  6e697479
000070  20636865
000074  636b2061
000078  6c69676e
00007c  6d656e74
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L2.132|
                          DCD      ||.data||
                  |L2.136|
000088  6d656d5f          DCB      "mem_free: legal memory",0
00008c  66726565
000090  3a206c65
000094  67616c20
000098  6d656d6f
00009c  727900  
00009f  00                DCB      0
                  |L2.160|
                          DCD      lwip_stats
                  |L2.164|
0000a4  6d656d5f          DCB      "mem_free: mem->used",0
0000a8  66726565
0000ac  3a206d65
0000b0  6d2d3e75
0000b4  73656400

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                  mem_init PROC
;;;273    void
;;;274    mem_init(void)
000000  480b              LDR      r0,|L3.48|
;;;275    {
000002  b510              PUSH     {r4,lr}
;;;276      struct mem *mem;
;;;277    
;;;278      LWIP_ASSERT("Sanity check alignment",
;;;279        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;280    
;;;281      /* align the heap */
;;;282      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
000004  4b0b              LDR      r3,|L3.52|
000006  f0200103          BIC      r1,r0,#3
;;;283      /* initialize the start of the heap */
;;;284      mem = (struct mem *)(void *)ram;
;;;285      mem->next = MEM_SIZE_ALIGNED;
00000a  f44f4220          MOV      r2,#0xa000
00000e  6019              STR      r1,[r3,#0]  ; ram
000010  800a              STRH     r2,[r1,#0]
;;;286      mem->prev = 0;
000012  2400              MOVS     r4,#0
000014  804c              STRH     r4,[r1,#2]
;;;287      mem->used = 0;
000016  710c              STRB     r4,[r1,#4]
;;;288      /* initialize the end of the heap */
;;;289      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
000018  f5014020          ADD      r0,r1,#0xa000
;;;290      ram_end->used = 1;
00001c  2401              MOVS     r4,#1
00001e  6058              STR      r0,[r3,#4]  ; ram_end
000020  7104              STRB     r4,[r0,#4]
;;;291      ram_end->next = MEM_SIZE_ALIGNED;
000022  8002              STRH     r2,[r0,#0]
;;;292      ram_end->prev = MEM_SIZE_ALIGNED;
000024  8042              STRH     r2,[r0,#2]
;;;293    
;;;294      /* initialize the lowest-free pointer to the start of the heap */
;;;295      lfree = (struct mem *)(void *)ram;
;;;296    
;;;297      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
000026  4804              LDR      r0,|L3.56|
000028  6099              STR      r1,[r3,#8]  ; lfree
00002a  f8a020ac          STRH     r2,[r0,#0xac]
;;;298    
;;;299      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
;;;300        LWIP_ASSERT("failed to create mem_mutex", 0);
;;;301      }
;;;302    }
00002e  bd10              POP      {r4,pc}
;;;303    
                          ENDP

                  |L3.48|
                          DCD      ||.bss||+0x3
                  |L3.52|
                          DCD      ||.data||
                  |L3.56|
                          DCD      lwip_stats

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                  mem_malloc PROC
;;;493    void *
;;;494    mem_malloc(mem_size_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;495    {
000004  2800              CMP      r0,#0
000006  d00d              BEQ      |L4.36|
;;;496      mem_size_t ptr, ptr2;
;;;497      struct mem *mem, *mem2;
;;;498    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;499      u8_t local_mem_free_count = 0;
;;;500    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;501      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;502    
;;;503      if (size == 0) {
;;;504        return NULL;
;;;505      }
;;;506    
;;;507      /* Expand the size of the allocated memory region so that we can
;;;508         adjust for alignment. */
;;;509      size = LWIP_MEM_ALIGN_SIZE(size);
000008  f64f71fc          MOV      r1,#0xfffc
00000c  1cc0              ADDS     r0,r0,#3
00000e  ea000201          AND      r2,r0,r1
;;;510    
;;;511      if(size < MIN_SIZE_ALIGNED) {
;;;512        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;513        size = MIN_SIZE_ALIGNED;
;;;514      }
;;;515    
;;;516      if (size > MEM_SIZE_ALIGNED) {
000012  f44f4a20          MOV      r10,#0xa000
000016  2a0c              CMP      r2,#0xc               ;511
000018  d201              BCS      |L4.30|
00001a  220c              MOVS     r2,#0xc               ;513
00001c  e004              B        |L4.40|
                  |L4.30|
00001e  4552              CMP      r2,r10
000020  d902              BLS      |L4.40|
                  |L4.34|
;;;517        return NULL;
000022  2000              MOVS     r0,#0
                  |L4.36|
;;;518      }
;;;519    
;;;520      /* protect the heap from concurrent access */
;;;521      sys_mutex_lock(&mem_mutex);
;;;522      LWIP_MEM_ALLOC_PROTECT();
;;;523    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;524      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;525      do {
;;;526        local_mem_free_count = 0;
;;;527    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;528    
;;;529        /* Scan through the heap searching for a free block that is big enough,
;;;530         * beginning with the lowest free block.
;;;531         */
;;;532        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;533             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;534          mem = (struct mem *)(void *)&ram[ptr];
;;;535    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;536          mem_free_count = 0;
;;;537          LWIP_MEM_ALLOC_UNPROTECT();
;;;538          /* allow mem_free or mem_trim to run */
;;;539          LWIP_MEM_ALLOC_PROTECT();
;;;540          if (mem_free_count != 0) {
;;;541            /* If mem_free or mem_trim have run, we have to restart since they
;;;542               could have altered our current struct mem. */
;;;543            local_mem_free_count = 1;
;;;544            break;
;;;545          }
;;;546    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;547    
;;;548          if ((!mem->used) &&
;;;549              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;550            /* mem is not used and at least perfect fit is possible:
;;;551             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;552    
;;;553            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;554              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;555               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;556               * -> split large block, create empty remainder,
;;;557               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;558               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;559               * struct mem would fit in but no data between mem2 and mem2->next
;;;560               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;561               *       region that couldn't hold data, but when mem->next gets freed,
;;;562               *       the 2 regions would be combined, resulting in more free memory
;;;563               */
;;;564              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;565              /* create mem2 struct */
;;;566              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;567              mem2->used = 0;
;;;568              mem2->next = mem->next;
;;;569              mem2->prev = ptr;
;;;570              /* and insert it between mem and mem->next */
;;;571              mem->next = ptr2;
;;;572              mem->used = 1;
;;;573    
;;;574              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;575                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;576              }
;;;577              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;578            } else {
;;;579              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;580               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;581               * take care of this).
;;;582               * -> near fit or excact fit: do not split, no mem2 creation
;;;583               * also can't move mem->next directly behind mem, since mem->next
;;;584               * will always be used at this point!
;;;585               */
;;;586              mem->used = 1;
;;;587              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;588            }
;;;589    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;590    mem_malloc_adjust_lfree:
;;;591    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;592            if (mem == lfree) {
;;;593              struct mem *cur = lfree;
;;;594              /* Find next free block after mem and update lowest free pointer */
;;;595              while (cur->used && cur != ram_end) {
;;;596    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;597                mem_free_count = 0;
;;;598                LWIP_MEM_ALLOC_UNPROTECT();
;;;599                /* prevent high interrupt latency... */
;;;600                LWIP_MEM_ALLOC_PROTECT();
;;;601                if (mem_free_count != 0) {
;;;602                  /* If mem_free or mem_trim have run, we have to restart since they
;;;603                     could have altered our current struct mem or lfree. */
;;;604                  goto mem_malloc_adjust_lfree;
;;;605                }
;;;606    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;607                cur = (struct mem *)(void *)&ram[cur->next];
;;;608              }
;;;609              lfree = cur;
;;;610              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;611            }
;;;612            LWIP_MEM_ALLOC_UNPROTECT();
;;;613            sys_mutex_unlock(&mem_mutex);
;;;614            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;615             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;617             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;618            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;619              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;620    
;;;621            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;622          }
;;;623        }
;;;624    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;625        /* if we got interrupted by a mem_free, try again */
;;;626      } while(local_mem_free_count != 0);
;;;627    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;628      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;629      MEM_STATS_INC(err);
;;;630      LWIP_MEM_ALLOC_UNPROTECT();
;;;631      sys_mutex_unlock(&mem_mutex);
;;;632      return NULL;
;;;633    }
000024  e8bd87f0          POP      {r4-r10,pc}
                  |L4.40|
000028  f8df80f0          LDR      r8,|L4.284|
00002c  4f3c              LDR      r7,|L4.288|
00002e  f5c24420          RSB      r4,r2,#0xa000         ;532
000032  f8d86008          LDR      r6,[r8,#8]            ;532  ; lfree
000036  f8d83000          LDR      r3,[r8,#0]            ;532  ; ram
00003a  1af0              SUBS     r0,r6,r3              ;532
00003c  b281              UXTH     r1,r0                 ;532
00003e  e065              B        |L4.268|
                  |L4.64|
000040  1858              ADDS     r0,r3,r1              ;534
000042  7905              LDRB     r5,[r0,#4]            ;548
000044  2d00              CMP      r5,#0                 ;548
000046  d160              BNE      |L4.266|
000048  8805              LDRH     r5,[r0,#0]            ;549
00004a  1a6d              SUBS     r5,r5,r1              ;549
00004c  3d08              SUBS     r5,r5,#8              ;549
00004e  4295              CMP      r5,r2                 ;549
000050  d35b              BCC      |L4.266|
000052  8804              LDRH     r4,[r0,#0]            ;553
000054  f1020514          ADD      r5,r2,#0x14           ;553
000058  1a64              SUBS     r4,r4,r1              ;553
00005a  3c08              SUBS     r4,r4,#8              ;572
00005c  f04f0901          MOV      r9,#1                 ;572
000060  42ac              CMP      r4,r5                 ;553
000062  d327              BCC      |L4.180|
000064  188c              ADDS     r4,r1,r2              ;564
000066  3408              ADDS     r4,r4,#8              ;564
000068  b2a5              UXTH     r5,r4                 ;564
00006a  195c              ADDS     r4,r3,r5              ;566
00006c  f04f0c00          MOV      r12,#0                ;567
000070  f884c004          STRB     r12,[r4,#4]           ;567
000074  f8b0c000          LDRH     r12,[r0,#0]           ;568
000078  f8a4c000          STRH     r12,[r4,#0]           ;568
00007c  8061              STRH     r1,[r4,#2]            ;569
00007e  8005              STRH     r5,[r0,#0]            ;571
000080  f8809004          STRB     r9,[r0,#4]            ;572
000084  8821              LDRH     r1,[r4,#0]            ;574
000086  4551              CMP      r1,r10                ;574
000088  d001              BEQ      |L4.142|
00008a  1c9c              ADDS     r4,r3,#2              ;575
00008c  530d              STRH     r5,[r1,r4]            ;575
                  |L4.142|
00008e  f8b740ae          LDRH     r4,[r7,#0xae]         ;577  ; lwip_stats
000092  f1020108          ADD      r1,r2,#8              ;577
000096  4421              ADD      r1,r1,r4              ;577
                  |L4.152|
000098  b289              UXTH     r1,r1                 ;587
00009a  f8a710ae          STRH     r1,[r7,#0xae]         ;587
00009e  f8b740b0          LDRH     r4,[r7,#0xb0]         ;587  ; lwip_stats
0000a2  428c              CMP      r4,r1                 ;587
0000a4  d201              BCS      |L4.170|
0000a6  f8a710b0          STRH     r1,[r7,#0xb0]         ;587
                  |L4.170|
0000aa  42b0              CMP      r0,r6                 ;592
0000ac  d11b              BNE      |L4.230|
0000ae  f8d81004          LDR      r1,[r8,#4]            ;595
0000b2  e00a              B        |L4.202|
                  |L4.180|
0000b4  f8809004          STRB     r9,[r0,#4]            ;586
0000b8  8801              LDRH     r1,[r0,#0]            ;587
0000ba  1ac4              SUBS     r4,r0,r3              ;587
0000bc  1b09              SUBS     r1,r1,r4              ;587
0000be  f8b740ae          LDRH     r4,[r7,#0xae]         ;587  ; lwip_stats
0000c2  4421              ADD      r1,r1,r4              ;587
0000c4  e7e8              B        |L4.152|
                  |L4.198|
0000c6  8834              LDRH     r4,[r6,#0]            ;607
0000c8  18e6              ADDS     r6,r4,r3              ;607
                  |L4.202|
0000ca  7934              LDRB     r4,[r6,#4]            ;595
0000cc  b10c              CBZ      r4,|L4.210|
0000ce  428e              CMP      r6,r1                 ;595
0000d0  d1f9              BNE      |L4.198|
                  |L4.210|
0000d2  f8c86008          STR      r6,[r8,#8]            ;610  ; lfree
0000d6  428e              CMP      r6,r1                 ;610
0000d8  d005              BEQ      |L4.230|
0000da  7931              LDRB     r1,[r6,#4]            ;610
0000dc  b119              CBZ      r1,|L4.230|
0000de  a011              ADR      r0,|L4.292|
0000e0  f7fffffe          BL       __2printf
                  |L4.228|
0000e4  e7fe              B        |L4.228|
                  |L4.230|
0000e6  1881              ADDS     r1,r0,r2              ;614
0000e8  f8d82004          LDR      r2,[r8,#4]            ;614  ; ram_end
0000ec  3108              ADDS     r1,r1,#8              ;614
0000ee  4291              CMP      r1,r2                 ;614
0000f0  d903              BLS      |L4.250|
0000f2  a013              ADR      r0,|L4.320|
0000f4  f7fffffe          BL       __2printf
                  |L4.248|
0000f8  e7fe              B        |L4.248|
                  |L4.250|
0000fa  0781              LSLS     r1,r0,#30             ;616
0000fc  d003              BEQ      |L4.262|
0000fe  a01c              ADR      r0,|L4.368|
000100  f7fffffe          BL       __2printf
                  |L4.260|
000104  e7fe              B        |L4.260|
                  |L4.262|
000106  3008              ADDS     r0,r0,#8              ;616
000108  e78c              B        |L4.36|
                  |L4.266|
00010a  5a59              LDRH     r1,[r3,r1]            ;533
                  |L4.268|
00010c  428c              CMP      r4,r1                 ;532
00010e  dc97              BGT      |L4.64|
000110  f8370fb2          LDRH     r0,[r7,#0xb2]!        ;629  ; lwip_stats
000114  1c40              ADDS     r0,r0,#1              ;629
000116  8038              STRH     r0,[r7,#0]            ;629
000118  e783              B        |L4.34|
;;;634    
                          ENDP

00011a  0000              DCW      0x0000
                  |L4.284|
                          DCD      ||.data||
                  |L4.288|
                          DCD      lwip_stats
                  |L4.292|
000124  6d656d5f          DCB      "mem_malloc: !lfree->used",0
000128  6d616c6c
00012c  6f633a20
000130  216c6672
000134  65652d3e
000138  75736564
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L4.320|
000140  6d656d5f          DCB      "mem_malloc: allocated memory not above ram_end.",0
000144  6d616c6c
000148  6f633a20
00014c  616c6c6f
000150  63617465
000154  64206d65
000158  6d6f7279
00015c  206e6f74
000160  2061626f
000164  76652072
000168  616d5f65
00016c  6e642e00
                  |L4.368|
000170  6d656d5f          DCB      "mem_malloc: allocated memory properly aligned.",0
000174  6d616c6c
000178  6f633a20
00017c  616c6c6f
000180  63617465
000184  64206d65
000188  6d6f7279
00018c  2070726f
000190  7065726c
000194  7920616c
000198  69676e65
00019c  642e00  
00019f  00                DCB      0

                          AREA ||i.mem_trim||, CODE, READONLY, ALIGN=2

                  mem_trim PROC
;;;368    void *
;;;369    mem_trim(void *rmem, mem_size_t newsize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;370    {
;;;371      mem_size_t size;
;;;372      mem_size_t ptr, ptr2;
;;;373      struct mem *mem, *mem2;
;;;374      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;375      LWIP_MEM_FREE_DECL_PROTECT();
;;;376    
;;;377      /* Expand the size of the allocated memory region so that we can
;;;378         adjust for alignment. */
;;;379      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
000004  f64f72fc          MOV      r2,#0xfffc
000008  1cc9              ADDS     r1,r1,#3
00000a  4011              ANDS     r1,r1,r2
;;;380    
;;;381      if(newsize < MIN_SIZE_ALIGNED) {
;;;382        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;383        newsize = MIN_SIZE_ALIGNED;
;;;384      }
;;;385    
;;;386      if (newsize > MEM_SIZE_ALIGNED) {
00000c  f44f4920          MOV      r9,#0xa000
000010  290c              CMP      r1,#0xc               ;381
000012  d201              BCS      |L5.24|
000014  210c              MOVS     r1,#0xc               ;383
000016  e004              B        |L5.34|
                  |L5.24|
000018  4549              CMP      r1,r9
00001a  d902              BLS      |L5.34|
;;;387        return NULL;
00001c  2000              MOVS     r0,#0
                  |L5.30|
;;;388      }
;;;389    
;;;390      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;391       (u8_t *)rmem < (u8_t *)ram_end);
;;;392    
;;;393      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;394        SYS_ARCH_DECL_PROTECT(lev);
;;;395        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;396        /* protect mem stats from concurrent access */
;;;397        SYS_ARCH_PROTECT(lev);
;;;398        MEM_STATS_INC(illegal);
;;;399        SYS_ARCH_UNPROTECT(lev);
;;;400        return rmem;
;;;401      }
;;;402      /* Get the corresponding struct mem ... */
;;;403      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;404      /* ... and its offset pointer */
;;;405      ptr = (mem_size_t)((u8_t *)mem - ram);
;;;406    
;;;407      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;408      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
;;;409      if (newsize > size) {
;;;410        /* not supported */
;;;411        return NULL;
;;;412      }
;;;413      if (newsize == size) {
;;;414        /* No change in size, simply return */
;;;415        return rmem;
;;;416      }
;;;417    
;;;418      /* protect the heap from concurrent access */
;;;419      LWIP_MEM_FREE_PROTECT();
;;;420    
;;;421      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;422      if(mem2->used == 0) {
;;;423        /* The next struct is unused, we can simply move it at little */
;;;424        mem_size_t next;
;;;425        /* remember the old next pointer */
;;;426        next = mem2->next;
;;;427        /* create new struct mem which is moved directly after the shrinked mem */
;;;428        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;429        if (lfree == mem2) {
;;;430          lfree = (struct mem *)(void *)&ram[ptr2];
;;;431        }
;;;432        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;433        mem2->used = 0;
;;;434        /* restore the next pointer */
;;;435        mem2->next = next;
;;;436        /* link it back to mem */
;;;437        mem2->prev = ptr;
;;;438        /* link mem to it */
;;;439        mem->next = ptr2;
;;;440        /* last thing to restore linked list: as we have moved mem2,
;;;441         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;442         * the end of the heap */
;;;443        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;444          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;445        }
;;;446        MEM_STATS_DEC_USED(used, (size - newsize));
;;;447        /* no need to plug holes, we've already done that */
;;;448      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;449        /* Next struct is used but there's room for another struct mem with
;;;450         * at least MIN_SIZE_ALIGNED of data.
;;;451         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;452         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;453         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;454         *       region that couldn't hold data, but when mem->next gets freed,
;;;455         *       the 2 regions would be combined, resulting in more free memory */
;;;456        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;457        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;458        if (mem2 < lfree) {
;;;459          lfree = mem2;
;;;460        }
;;;461        mem2->used = 0;
;;;462        mem2->next = mem->next;
;;;463        mem2->prev = ptr;
;;;464        mem->next = ptr2;
;;;465        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;466          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;467        }
;;;468        MEM_STATS_DEC_USED(used, (size - newsize));
;;;469        /* the original mem->next is used, so no need to plug holes! */
;;;470      }
;;;471      /* else {
;;;472        next struct mem is used but size between mem and mem2 is not big enough
;;;473        to create another struct mem
;;;474        -> don't do anyhting. 
;;;475        -> the remaining space stays unused since it is too small
;;;476      } */
;;;477    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;478      mem_free_count = 1;
;;;479    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;480      LWIP_MEM_FREE_UNPROTECT();
;;;481      return rmem;
;;;482    }
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.34|
000022  f8df80c4          LDR      r8,|L5.232|
000026  f8d82000          LDR      r2,[r8,#0]            ;390  ; ram
00002a  4290              CMP      r0,r2                 ;390
00002c  d303              BCC      |L5.54|
00002e  f8d83004          LDR      r3,[r8,#4]            ;390  ; ram_end
000032  4298              CMP      r0,r3                 ;390
000034  d303              BCC      |L5.62|
                  |L5.54|
000036  a02d              ADR      r0,|L5.236|
000038  f7fffffe          BL       __2printf
                  |L5.60|
00003c  e7fe              B        |L5.60|
                  |L5.62|
00003e  f1a00308          SUB      r3,r0,#8              ;403
000042  1a9c              SUBS     r4,r3,r2              ;405
000044  881e              LDRH     r6,[r3,#0]            ;407
000046  b2a4              UXTH     r4,r4                 ;405
000048  1b35              SUBS     r5,r6,r4              ;407
00004a  3d08              SUBS     r5,r5,#8              ;407
00004c  b2ad              UXTH     r5,r5                 ;407
00004e  42a9              CMP      r1,r5                 ;408
000050  d903              BLS      |L5.90|
000052  a02c              ADR      r0,|L5.260|
000054  f7fffffe          BL       __2printf
                  |L5.88|
000058  e7fe              B        |L5.88|
                  |L5.90|
00005a  d0e0              BEQ      |L5.30|
00005c  4f22              LDR      r7,|L5.232|
00005e  eb060c02          ADD      r12,r6,r2             ;421
000062  f8dfe0c0          LDR      lr,|L5.292|
000066  683f              LDR      r7,[r7,#0]            ;390
000068  f89c6004          LDRB     r6,[r12,#4]           ;422
00006c  f1070702          ADD      r7,r7,#2              ;390
000070  b1de              CBZ      r6,|L5.170|
000072  f1010614          ADD      r6,r1,#0x14           ;448
000076  42ae              CMP      r6,r5                 ;448
000078  d8d1              BHI      |L5.30|
00007a  1866              ADDS     r6,r4,r1              ;456
00007c  3608              ADDS     r6,r6,#8              ;456
00007e  b2b6              UXTH     r6,r6                 ;456
000080  f8d8c008          LDR      r12,[r8,#8]           ;458  ; lfree
000084  4432              ADD      r2,r2,r6              ;457
000086  4562              CMP      r2,r12                ;458
000088  d201              BCS      |L5.142|
00008a  f8c82008          STR      r2,[r8,#8]            ;459  ; lfree
                  |L5.142|
00008e  f04f0c00          MOV      r12,#0                ;461
000092  f882c004          STRB     r12,[r2,#4]           ;461
000096  f8b3c000          LDRH     r12,[r3,#0]           ;462
00009a  f8a2c000          STRH     r12,[r2,#0]           ;462
                  |L5.158|
00009e  8054              STRH     r4,[r2,#2]            ;463
0000a0  801e              STRH     r6,[r3,#0]            ;464
0000a2  8812              LDRH     r2,[r2,#0]            ;465
0000a4  454a              CMP      r2,r9                 ;465
0000a6  d11d              BNE      |L5.228|
0000a8  e015              B        |L5.214|
                  |L5.170|
0000aa  1866              ADDS     r6,r4,r1              ;428
0000ac  46c3              MOV      r11,r8                ;429
0000ae  3608              ADDS     r6,r6,#8              ;428
0000b0  f8d88008          LDR      r8,[r8,#8]            ;429  ; lfree
0000b4  f8bca000          LDRH     r10,[r12,#0]          ;426
0000b8  b2b6              UXTH     r6,r6                 ;428
0000ba  45e0              CMP      r8,r12                ;429
0000bc  d103              BNE      |L5.198|
0000be  eb020806          ADD      r8,r2,r6              ;430
0000c2  f8cb8008          STR      r8,[r11,#8]           ;430  ; lfree
                  |L5.198|
0000c6  4432              ADD      r2,r2,r6              ;432
0000c8  f04f0c00          MOV      r12,#0                ;433
0000cc  f882c004          STRB     r12,[r2,#4]           ;433
0000d0  f8a2a000          STRH     r10,[r2,#0]           ;435
0000d4  e7e3              B        |L5.158|
                  |L5.214|
0000d6  f8be30ae          LDRH     r3,[lr,#0xae]         ;446  ; lwip_stats
0000da  1a69              SUBS     r1,r5,r1              ;446
0000dc  1a59              SUBS     r1,r3,r1              ;446
0000de  f8ae10ae          STRH     r1,[lr,#0xae]         ;446
0000e2  e79c              B        |L5.30|
                  |L5.228|
0000e4  53d6              STRH     r6,[r2,r7]            ;466
0000e6  e7f6              B        |L5.214|
;;;483    
                          ENDP

                  |L5.232|
                          DCD      ||.data||
                  |L5.236|
0000ec  6d656d5f          DCB      "mem_trim: legal memory",0
0000f0  7472696d
0000f4  3a206c65
0000f8  67616c20
0000fc  6d656d6f
000100  727900  
000103  00                DCB      0
                  |L5.260|
000104  6d656d5f          DCB      "mem_trim can only shrink memory",0
000108  7472696d
00010c  2063616e
000110  206f6e6c
000114  79207368
000118  72696e6b
00011c  206d656d
000120  6f727900
                  |L5.292|
                          DCD      lwip_stats

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;235    static void
;;;236    plug_holes(struct mem *mem)
000000  b570              PUSH     {r4-r6,lr}
;;;237    {
;;;238      struct mem *nmem;
;;;239      struct mem *pmem;
;;;240    
;;;241      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000002  4d20              LDR      r5,|L6.132|
000004  682a              LDR      r2,[r5,#0]  ; ram
000006  4290              CMP      r0,r2
000008  d203              BCS      |L6.18|
00000a  a01f              ADR      r0,|L6.136|
00000c  f7fffffe          BL       __2printf
                  |L6.16|
000010  e7fe              B        |L6.16|
                  |L6.18|
;;;242      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
000012  686c              LDR      r4,[r5,#4]  ; ram_end
000014  42a0              CMP      r0,r4
000016  d303              BCC      |L6.32|
000018  a021              ADR      r0,|L6.160|
00001a  f7fffffe          BL       __2printf
                  |L6.30|
00001e  e7fe              B        |L6.30|
                  |L6.32|
;;;243      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
000020  7901              LDRB     r1,[r0,#4]
000022  b119              CBZ      r1,|L6.44|
000024  a025              ADR      r0,|L6.188|
000026  f7fffffe          BL       __2printf
                  |L6.42|
00002a  e7fe              B        |L6.42|
                  |L6.44|
;;;244    
;;;245      /* plug hole forward */
;;;246      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
00002c  8801              LDRH     r1,[r0,#0]
00002e  f5b14f20          CMP      r1,#0xa000
000032  d903              BLS      |L6.60|
000034  a028              ADR      r0,|L6.216|
000036  f7fffffe          BL       __2printf
                  |L6.58|
00003a  e7fe              B        |L6.58|
                  |L6.60|
00003c  4b11              LDR      r3,|L6.132|
;;;247    
;;;248      nmem = (struct mem *)(void *)&ram[mem->next];
00003e  4411              ADD      r1,r1,r2
000040  681b              LDR      r3,[r3,#0]            ;241
000042  1c9b              ADDS     r3,r3,#2              ;241
;;;249      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
000044  4288              CMP      r0,r1
000046  d00c              BEQ      |L6.98|
000048  790e              LDRB     r6,[r1,#4]
00004a  b956              CBNZ     r6,|L6.98|
00004c  42a1              CMP      r1,r4
00004e  d008              BEQ      |L6.98|
;;;250        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;251        if (lfree == nmem) {
000050  68ac              LDR      r4,[r5,#8]  ; lfree
000052  428c              CMP      r4,r1
000054  d100              BNE      |L6.88|
;;;252          lfree = mem;
000056  60a8              STR      r0,[r5,#8]  ; lfree
                  |L6.88|
;;;253        }
;;;254        mem->next = nmem->next;
000058  880c              LDRH     r4,[r1,#0]
00005a  8004              STRH     r4,[r0,#0]
;;;255        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
00005c  8809              LDRH     r1,[r1,#0]
00005e  1a84              SUBS     r4,r0,r2
000060  52cc              STRH     r4,[r1,r3]
                  |L6.98|
;;;256      }
;;;257    
;;;258      /* plug hole backward */
;;;259      pmem = (struct mem *)(void *)&ram[mem->prev];
000062  8841              LDRH     r1,[r0,#2]
000064  4411              ADD      r1,r1,r2
;;;260      if (pmem != mem && pmem->used == 0) {
000066  4281              CMP      r1,r0
000068  d00b              BEQ      |L6.130|
00006a  790c              LDRB     r4,[r1,#4]
00006c  2c00              CMP      r4,#0
00006e  d108              BNE      |L6.130|
;;;261        /* if mem->prev is unused, combine mem and mem->prev */
;;;262        if (lfree == mem) {
000070  68ac              LDR      r4,[r5,#8]  ; lfree
000072  4284              CMP      r4,r0
000074  d100              BNE      |L6.120|
;;;263          lfree = pmem;
000076  60a9              STR      r1,[r5,#8]  ; lfree
                  |L6.120|
;;;264        }
;;;265        pmem->next = mem->next;
000078  8804              LDRH     r4,[r0,#0]
00007a  800c              STRH     r4,[r1,#0]
;;;266        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
00007c  8800              LDRH     r0,[r0,#0]
00007e  1a89              SUBS     r1,r1,r2
000080  52c1              STRH     r1,[r0,r3]
                  |L6.130|
;;;267      }
;;;268    }
000082  bd70              POP      {r4-r6,pc}
;;;269    
                          ENDP

                  |L6.132|
                          DCD      ||.data||
                  |L6.136|
000088  706c7567          DCB      "plug_holes: mem >= ram",0
00008c  5f686f6c
000090  65733a20
000094  6d656d20
000098  3e3d2072
00009c  616d00  
00009f  00                DCB      0
                  |L6.160|
0000a0  706c7567          DCB      "plug_holes: mem < ram_end",0
0000a4  5f686f6c
0000a8  65733a20
0000ac  6d656d20
0000b0  3c207261
0000b4  6d5f656e
0000b8  6400    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L6.188|
0000bc  706c7567          DCB      "plug_holes: mem->used == 0",0
0000c0  5f686f6c
0000c4  65733a20
0000c8  6d656d2d
0000cc  3e757365
0000d0  64203d3d
0000d4  203000  
0000d7  00                DCB      0
                  |L6.216|
0000d8  706c7567          DCB      "plug_holes: mem->next <= MEM_SIZE_ALIGNED",0
0000dc  5f686f6c
0000e0  65733a20
0000e4  6d656d2d
0000e8  3e6e6578
0000ec  74203c3d
0000f0  204d454d
0000f4  5f53495a
0000f8  455f414c
0000fc  49474e45
000100  4400    
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ram_heap
                          %        40980

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
