; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stats.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stats.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stats.crf ..\lwip\src\core\stats.c]
                          THUMB

                          AREA ||i.stats_init||, CODE, READONLY, ALIGN=2

                  stats_init PROC
;;;50     
;;;51     void stats_init(void)
000000  b510              PUSH     {r4,lr}
;;;52     {
000002  b08a              SUB      sp,sp,#0x28
;;;53     #ifdef LWIP_DEBUG
;;;54     #if MEMP_STATS
;;;55       const char * memp_names[] = {
000004  2228              MOVS     r2,#0x28
000006  490a              LDR      r1,|L1.48|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;56     #define LWIP_MEMPOOL(name,num,size,desc) desc,
;;;57     #include "lwip/memp_std.h"
;;;1      /*
;;;2       * SETUP: Make sure we define everything we will need.
;;;3       *
;;;4       * We have create three types of pools:
;;;5       *   1) MEMPOOL - standard pools
;;;6       *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
;;;7       *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
;;;8       *
;;;9       * If the include'r doesn't require any special treatment of each of the types
;;;10      * above, then will declare #2 & #3 to be just standard mempools.
;;;11      */
;;;12     #ifndef LWIP_MALLOC_MEMPOOL
;;;13     /* This treats "malloc pools" just like any other pool.
;;;14        The pools are a little bigger to provide 'size' as the amount of user data. */
;;;15     #define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
;;;16     #define LWIP_MALLOC_MEMPOOL_START
;;;17     #define LWIP_MALLOC_MEMPOOL_END
;;;18     #endif /* LWIP_MALLOC_MEMPOOL */ 
;;;19     
;;;20     #ifndef LWIP_PBUF_MEMPOOL
;;;21     /* This treats "pbuf pools" just like any other pool.
;;;22      * Allocates buffers for a pbuf struct AND a payload size */
;;;23     #define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
;;;24     #endif /* LWIP_PBUF_MEMPOOL */
;;;25     
;;;26     
;;;27     /*
;;;28      * A list of internal pools used by LWIP.
;;;29      *
;;;30      * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
;;;31      *     creates a pool name MEMP_pool_name. description is used in stats.c
;;;32      */
;;;33     #if LWIP_RAW
;;;34     LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        "RAW_PCB")
;;;35     #endif /* LWIP_RAW */
;;;36     
;;;37     #if LWIP_UDP
;;;38     LWIP_MEMPOOL(UDP_PCB,        MEMP_NUM_UDP_PCB,         sizeof(struct udp_pcb),        "UDP_PCB")
;;;39     #endif /* LWIP_UDP */
;;;40     
;;;41     #if LWIP_TCP
;;;42     LWIP_MEMPOOL(TCP_PCB,        MEMP_NUM_TCP_PCB,         sizeof(struct tcp_pcb),        "TCP_PCB")
;;;43     LWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,  sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
;;;44     LWIP_MEMPOOL(TCP_SEG,        MEMP_NUM_TCP_SEG,         sizeof(struct tcp_seg),        "TCP_SEG")
;;;45     #endif /* LWIP_TCP */
;;;46     
;;;47     #if IP_REASSEMBLY
;;;48     LWIP_MEMPOOL(REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip_reassdata),   "REASSDATA")
;;;49     #endif /* IP_REASSEMBLY */
;;;50     #if IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
;;;51     LWIP_MEMPOOL(FRAG_PBUF,      MEMP_NUM_FRAG_PBUF,       sizeof(struct pbuf_custom_ref),"FRAG_PBUF")
;;;52     #endif /* IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF */
;;;53     
;;;54     #if LWIP_NETCONN
;;;55     LWIP_MEMPOOL(NETBUF,         MEMP_NUM_NETBUF,          sizeof(struct netbuf),         "NETBUF")
;;;56     LWIP_MEMPOOL(NETCONN,        MEMP_NUM_NETCONN,         sizeof(struct netconn),        "NETCONN")
;;;57     #endif /* LWIP_NETCONN */
;;;58     
;;;59     #if NO_SYS==0
;;;60     LWIP_MEMPOOL(TCPIP_MSG_API,  MEMP_NUM_TCPIP_MSG_API,   sizeof(struct tcpip_msg),      "TCPIP_MSG_API")
;;;61     #if !LWIP_TCPIP_CORE_LOCKING_INPUT
;;;62     LWIP_MEMPOOL(TCPIP_MSG_INPKT,MEMP_NUM_TCPIP_MSG_INPKT, sizeof(struct tcpip_msg),      "TCPIP_MSG_INPKT")
;;;63     #endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;64     #endif /* NO_SYS==0 */
;;;65     
;;;66     #if LWIP_ARP && ARP_QUEUEING
;;;67     LWIP_MEMPOOL(ARP_QUEUE,      MEMP_NUM_ARP_QUEUE,       sizeof(struct etharp_q_entry), "ARP_QUEUE")
;;;68     #endif /* LWIP_ARP && ARP_QUEUEING */
;;;69     
;;;70     #if LWIP_IGMP
;;;71     LWIP_MEMPOOL(IGMP_GROUP,     MEMP_NUM_IGMP_GROUP,      sizeof(struct igmp_group),     "IGMP_GROUP")
;;;72     #endif /* LWIP_IGMP */
;;;73     
;;;74     #if (!NO_SYS || (NO_SYS && !NO_SYS_NO_TIMERS)) /* LWIP_TIMERS */
;;;75     LWIP_MEMPOOL(SYS_TIMEOUT,    MEMP_NUM_SYS_TIMEOUT,     sizeof(struct sys_timeo),      "SYS_TIMEOUT")
;;;76     #endif /* LWIP_TIMERS */
;;;77     
;;;78     #if LWIP_SNMP
;;;79     LWIP_MEMPOOL(SNMP_ROOTNODE,  MEMP_NUM_SNMP_ROOTNODE,   sizeof(struct mib_list_rootnode), "SNMP_ROOTNODE")
;;;80     LWIP_MEMPOOL(SNMP_NODE,      MEMP_NUM_SNMP_NODE,       sizeof(struct mib_list_node),     "SNMP_NODE")
;;;81     LWIP_MEMPOOL(SNMP_VARBIND,   MEMP_NUM_SNMP_VARBIND,    sizeof(struct snmp_varbind),      "SNMP_VARBIND")
;;;82     LWIP_MEMPOOL(SNMP_VALUE,     MEMP_NUM_SNMP_VALUE,      SNMP_MAX_VALUE_SIZE,              "SNMP_VALUE")
;;;83     #endif /* LWIP_SNMP */
;;;84     #if LWIP_DNS && LWIP_SOCKET
;;;85     LWIP_MEMPOOL(NETDB,          MEMP_NUM_NETDB,           NETDB_ELEM_SIZE,               "NETDB")
;;;86     #endif /* LWIP_DNS && LWIP_SOCKET */
;;;87     #if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
;;;88     LWIP_MEMPOOL(LOCALHOSTLIST,  MEMP_NUM_LOCALHOSTLIST,   LOCALHOSTLIST_ELEM_SIZE,       "LOCALHOSTLIST")
;;;89     #endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
;;;90     #if PPP_SUPPORT && PPPOE_SUPPORT
;;;91     LWIP_MEMPOOL(PPPOE_IF,      MEMP_NUM_PPPOE_INTERFACES, sizeof(struct pppoe_softc),    "PPPOE_IF")
;;;92     #endif /* PPP_SUPPORT && PPPOE_SUPPORT */
;;;93     
;;;94     /*
;;;95      * A list of pools of pbuf's used by LWIP.
;;;96      *
;;;97      * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
;;;98      *     creates a pool name MEMP_pool_name. description is used in stats.c
;;;99      *     This allocates enough space for the pbuf struct and a payload.
;;;100     *     (Example: pbuf_payload_size=0 allocates only size for the struct)
;;;101     */
;;;102    LWIP_PBUF_MEMPOOL(PBUF,      MEMP_NUM_PBUF,            0,                             "PBUF_REF/ROM")
;;;103    LWIP_PBUF_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE,           PBUF_POOL_BUFSIZE,             "PBUF_POOL")
;;;104    
;;;105    
;;;106    /*
;;;107     * Allow for user-defined pools; this must be explicitly set in lwipopts.h
;;;108     * since the default is to NOT look for lwippools.h
;;;109     */
;;;110    #if MEMP_USE_CUSTOM_POOLS
;;;111    #include "lwippools.h"
;;;112    #endif /* MEMP_USE_CUSTOM_POOLS */
;;;113    
;;;114    /*
;;;115     * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
;;;116     * (#undef is ignored for something that is not defined)
;;;117     */
;;;118    #undef LWIP_MEMPOOL
;;;119    #undef LWIP_MALLOC_MEMPOOL
;;;120    #undef LWIP_MALLOC_MEMPOOL_START
;;;121    #undef LWIP_MALLOC_MEMPOOL_END
;;;122    #undef LWIP_PBUF_MEMPOOL
;;;58       };
;;;59       int i;
;;;60       for (i = 0; i < MEMP_MAX; i++) {
;;;61         lwip_stats.memp[i].name = memp_names[i];
00000e  4909              LDR      r1,|L1.52|
000010  2000              MOVS     r0,#0                 ;60
000012  466a              MOV      r2,sp                 ;55
                  |L1.20|
000014  eb011400          ADD      r4,r1,r0,LSL #4
000018  f8523020          LDR      r3,[r2,r0,LSL #2]
00001c  1c40              ADDS     r0,r0,#1
00001e  f8c430b8          STR      r3,[r4,#0xb8]         ;60
000022  280a              CMP      r0,#0xa               ;60
000024  dbf6              BLT      |L1.20|
;;;62       }
;;;63     #endif /* MEMP_STATS */
;;;64     #if MEM_STATS
;;;65       lwip_stats.mem.name = "MEM";
000026  a004              ADR      r0,|L1.56|
000028  f8c100a8          STR      r0,[r1,#0xa8]  ; lwip_stats
;;;66     #endif /* MEM_STATS */
;;;67     #endif /* LWIP_DEBUG */
;;;68     }
00002c  b00a              ADD      sp,sp,#0x28
00002e  bd10              POP      {r4,pc}
;;;69     
                          ENDP

                  |L1.48|
                          DCD      ||.constdata||
                  |L1.52|
                          DCD      ||.bss||
                  |L1.56|
000038  4d454d00          DCB      "MEM",0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  lwip_stats
                          %        344

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x18
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x30
                          DCD      ||.conststring||+0x3c
                          DCD      ||.conststring||+0x48
                          DCD      ||.conststring||+0x54
                          DCD      ||.conststring||+0x64

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5241575f          DCB      "RAW_PCB",0
000004  50434200
000008  5544505f          DCB      "UDP_PCB",0
00000c  50434200
000010  5443505f          DCB      "TCP_PCB",0
000014  50434200
000018  5443505f          DCB      "TCP_PCB_LISTEN",0
00001c  5043425f
000020  4c495354
000024  454e00  
000027  00                DCB      0
000028  5443505f          DCB      "TCP_SEG",0
00002c  53454700
000030  52454153          DCB      "REASSDATA",0
000034  53444154
000038  4100    
00003a  00                DCB      0
00003b  00                DCB      0
00003c  46524147          DCB      "FRAG_PBUF",0
000040  5f504255
000044  4600    
000046  00                DCB      0
000047  00                DCB      0
000048  5359535f          DCB      "SYS_TIMEOUT",0
00004c  54494d45
000050  4f555400
000054  50425546          DCB      "PBUF_REF/ROM",0
000058  5f524546
00005c  2f524f4d
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
000064  50425546          DCB      "PBUF_POOL",0
000068  5f504f4f
00006c  4c00    
