; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\icmp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\icmp.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\icmp.crf ..\lwip\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=1

                  icmp_dest_unreach PROC
;;;260    void
;;;261    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  460a              MOV      r2,r1
;;;262    {
;;;263      icmp_send_response(p, ICMP_DUR, t);
000002  2103              MOVS     r1,#3
000004  f7ffbffe          B.W      icmp_send_response
;;;264    }
;;;265    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=2

                  icmp_input PROC
;;;76     void
;;;77     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;78     {
;;;79       u8_t type;
;;;80     #ifdef LWIP_DEBUG
;;;81       u8_t code;
;;;82     #endif /* LWIP_DEBUG */
;;;83       struct icmp_echo_hdr *iecho;
;;;84       struct ip_hdr *iphdr;
;;;85       s16_t hlen;
;;;86     
;;;87       ICMP_STATS_INC(icmp.recv);
000004  4f66              LDR      r7,|L2.416|
000006  4605              MOV      r5,r0                 ;78
000008  468b              MOV      r11,r1                ;78
00000a  f8b70062          LDRH     r0,[r7,#0x62]  ; lwip_stats
00000e  1c40              ADDS     r0,r0,#1
000010  f8a70062          STRH     r0,[r7,#0x62]
;;;88       snmp_inc_icmpinmsgs();
;;;89     
;;;90     
;;;91       iphdr = (struct ip_hdr *)p->payload;
;;;92       hlen = IPH_HL(iphdr) * 4;
000014  686c              LDR      r4,[r5,#4]
000016  7820              LDRB     r0,[r4,#0]
000018  0700              LSLS     r0,r0,#28
00001a  ea4f6890          LSR      r8,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
00001e  f1c80100          RSB      r1,r8,#0
000022  4689              MOV      r9,r1
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       pbuf_header
00002a  2800              CMP      r0,#0
00002c  d170              BNE      |L2.272|
00002e  8928              LDRH     r0,[r5,#8]
000030  2804              CMP      r0,#4
                  |L2.50|
000032  d36d              BCC      |L2.272|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
;;;95         goto lenerr;
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
000034  6868              LDR      r0,[r5,#4]
000036  7800              LDRB     r0,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
000038  2800              CMP      r0,#0
00003a  d027              BEQ      |L2.140|
00003c  2808              CMP      r0,#8
00003e  d006              BEQ      |L2.78|
;;;103      case ICMP_ER:
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
;;;107      case ICMP_ECHO:
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
;;;114            accepted = 0;
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
;;;120            accepted = 0;
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
;;;126            ICMP_STATS_INC(icmp.err);
;;;127            pbuf_free(p);
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
;;;153            goto memerr;
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
;;;157          if (r == NULL) {
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
;;;166            goto memerr;
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;172            goto memerr;
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
;;;178        } else {
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;193    #if CHECKSUM_GEN_ICMP
;;;194        /* adjust the checksum */
;;;195        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;196          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;197        } else {
;;;198          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;199        }
;;;200    #else /* CHECKSUM_GEN_ICMP */
;;;201        iecho->chksum = 0;
;;;202    #endif /* CHECKSUM_GEN_ICMP */
;;;203    
;;;204        /* Set the correct TTL and recalculate the header checksum. */
;;;205        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;206        IPH_CHKSUM_SET(iphdr, 0);
;;;207    #if CHECKSUM_GEN_IP
;;;208        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;209    #endif /* CHECKSUM_GEN_IP */
;;;210    
;;;211        ICMP_STATS_INC(icmp.xmit);
;;;212        /* increase number of messages attempted to send */
;;;213        snmp_inc_icmpoutmsgs();
;;;214        /* increase number of echo replies attempted to send */
;;;215        snmp_inc_icmpoutechoreps();
;;;216    
;;;217        if(pbuf_header(p, hlen)) {
;;;218          LWIP_ASSERT("Can't move over header in packet", 0);
;;;219        } else {
;;;220          err_t ret;
;;;221          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;222          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
;;;223                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;224          if (ret != ERR_OK) {
;;;225            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;226          }
;;;227        }
;;;228        break;
;;;229      default:
;;;230        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;231                    (s16_t)type, (s16_t)code));
;;;232        ICMP_STATS_INC(icmp.proterr);
000040  f8370f70          LDRH     r0,[r7,#0x70]!  ; lwip_stats
000044  1c40              ADDS     r0,r0,#1
000046  f827090a          STRH     r0,[r7],#-0xa
;;;233        ICMP_STATS_INC(icmp.drop);
00004a  8838              LDRH     r0,[r7,#0]  ; lwip_stats
00004c  e01c              B        |L2.136|
                  |L2.78|
00004e  4955              LDR      r1,|L2.420|
000050  2601              MOVS     r6,#1                 ;110
000052  6808              LDR      r0,[r1,#0]            ;113  ; current_iphdr_dest
000054  f3c01203          UBFX     r2,r0,#4,#4           ;113
000058  2a0e              CMP      r2,#0xe               ;113
00005a  d100              BNE      |L2.94|
00005c  2600              MOVS     r6,#0                 ;114
                  |L2.94|
00005e  468a              MOV      r10,r1                ;119
000060  4659              MOV      r1,r11                ;119
000062  f7fffffe          BL       ip4_addr_isbroadcast
000066  b968              CBNZ     r0,|L2.132|
000068  b166              CBZ      r6,|L2.132|
00006a  8928              LDRH     r0,[r5,#8]            ;133
00006c  2808              CMP      r0,#8                 ;133
00006e  d3e0              BCC      |L2.50|
000070  4628              MOV      r0,r5                 ;137
000072  f7fffffe          BL       inet_chksum_pbuf
000076  b150              CBZ      r0,|L2.142|
000078  4628              MOV      r0,r5                 ;139
00007a  f7fffffe          BL       pbuf_free
00007e  f8370f68          LDRH     r0,[r7,#0x68]!        ;140  ; lwip_stats
000082  e088              B        |L2.406|
                  |L2.132|
000084  f8370f74          LDRH     r0,[r7,#0x74]!        ;126  ; lwip_stats
                  |L2.136|
000088  1c40              ADDS     r0,r0,#1              ;126
00008a  8038              STRH     r0,[r7,#0]            ;126
                  |L2.140|
00008c  e073              B        |L2.374|
                  |L2.142|
00008e  2122              MOVS     r1,#0x22              ;145
000090  4628              MOV      r0,r5                 ;145
000092  f7fffffe          BL       pbuf_header
000096  2800              CMP      r0,#0                 ;145
000098  d030              BEQ      |L2.252|
00009a  4641              MOV      r1,r8                 ;151
00009c  4628              MOV      r0,r5                 ;151
00009e  f7fffffe          BL       pbuf_header
0000a2  b118              CBZ      r0,|L2.172|
0000a4  a040              ADR      r0,|L2.424|
0000a6  f7fffffe          BL       __2printf
                  |L2.170|
0000aa  e7fe              B        |L2.170|
                  |L2.172|
0000ac  8929              LDRH     r1,[r5,#8]            ;156
0000ae  2200              MOVS     r2,#0                 ;156
0000b0  2002              MOVS     r0,#2                 ;156
0000b2  f7fffffe          BL       pbuf_alloc
0000b6  0006              MOVS     r6,r0                 ;156
0000b8  d068              BEQ      |L2.396|
0000ba  8971              LDRH     r1,[r6,#0xa]          ;161
0000bc  f1080008          ADD      r0,r8,#8              ;161
0000c0  4281              CMP      r1,r0                 ;161
0000c2  d203              BCS      |L2.204|
0000c4  a045              ADR      r0,|L2.476|
0000c6  f7fffffe          BL       __2printf
                  |L2.202|
0000ca  e7fe              B        |L2.202|
                  |L2.204|
0000cc  4629              MOV      r1,r5                 ;164
0000ce  4630              MOV      r0,r6                 ;164
0000d0  f7fffffe          BL       pbuf_copy
0000d4  b118              CBZ      r0,|L2.222|
0000d6  a04f              ADR      r0,|L2.532|
0000d8  f7fffffe          BL       __2printf
                  |L2.220|
0000dc  e7fe              B        |L2.220|
                  |L2.222|
0000de  4649              MOV      r1,r9                 ;168
0000e0  4630              MOV      r0,r6                 ;170
0000e2  6874              LDR      r4,[r6,#4]            ;170
0000e4  f7fffffe          BL       pbuf_header
0000e8  b118              CBZ      r0,|L2.242|
0000ea  a054              ADR      r0,|L2.572|
0000ec  f7fffffe          BL       __2printf
                  |L2.240|
0000f0  e7fe              B        |L2.240|
                  |L2.242|
0000f2  4628              MOV      r0,r5                 ;175
0000f4  f7fffffe          BL       pbuf_free
0000f8  4635              MOV      r5,r6                 ;177
0000fa  e00a              B        |L2.274|
                  |L2.252|
0000fc  f06f0121          MVN      r1,#0x21              ;180
000100  4628              MOV      r0,r5                 ;180
000102  f7fffffe          BL       pbuf_header
000106  b120              CBZ      r0,|L2.274|
000108  a04c              ADR      r0,|L2.572|
00010a  f7fffffe          BL       __2printf
                  |L2.270|
00010e  e7fe              B        |L2.270|
                  |L2.272|
000110  e036              B        |L2.384|
                  |L2.274|
000112  6868              LDR      r0,[r5,#4]            ;190
000114  f8da1000          LDR      r1,[r10,#0]           ;190  ; current_iphdr_dest
000118  60e1              STR      r1,[r4,#0xc]          ;190
00011a  4955              LDR      r1,|L2.624|
00011c  2600              MOVS     r6,#0                 ;192
00011e  f64f72f7          MOV      r2,#0xfff7            ;195
000122  6809              LDR      r1,[r1,#0]            ;191  ; current_iphdr_src
000124  6121              STR      r1,[r4,#0x10]         ;191
000126  7006              STRB     r6,[r0,#0]            ;192
000128  8841              LDRH     r1,[r0,#2]            ;195
00012a  4291              CMP      r1,r2                 ;195
00012c  d301              BCC      |L2.306|
00012e  3109              ADDS     r1,r1,#9              ;195
000130  e000              B        |L2.308|
                  |L2.306|
000132  3108              ADDS     r1,r1,#8              ;196
                  |L2.308|
000134  8041              STRH     r1,[r0,#2]            ;198
000136  20ff              MOVS     r0,#0xff              ;205
000138  7220              STRB     r0,[r4,#8]            ;205
00013a  8166              STRH     r6,[r4,#0xa]          ;206
00013c  2114              MOVS     r1,#0x14              ;208
00013e  4620              MOV      r0,r4                 ;208
000140  f7fffffe          BL       inet_chksum
000144  8160              STRH     r0,[r4,#0xa]          ;208
000146  f8370f60          LDRH     r0,[r7,#0x60]!        ;211  ; lwip_stats
00014a  4641              MOV      r1,r8                 ;217
00014c  1c40              ADDS     r0,r0,#1              ;211
00014e  8038              STRH     r0,[r7,#0]            ;211
000150  4628              MOV      r0,r5                 ;217
000152  f7fffffe          BL       pbuf_header
000156  b118              CBZ      r0,|L2.352|
000158  a046              ADR      r0,|L2.628|
00015a  f7fffffe          BL       __2printf
                  |L2.350|
00015e  e7fe              B        |L2.350|
                  |L2.352|
000160  2101              MOVS     r1,#1                 ;222
000162  e9cd6100          STRD     r6,r1,[sp,#0]         ;222
000166  23ff              MOVS     r3,#0xff              ;222
000168  2200              MOVS     r2,#0                 ;222
00016a  f8cdb008          STR      r11,[sp,#8]           ;222
00016e  490d              LDR      r1,|L2.420|
000170  4628              MOV      r0,r5                 ;222
000172  f7fffffe          BL       ip_output_if
                  |L2.374|
;;;234      }
;;;235      pbuf_free(p);
000176  4628              MOV      r0,r5
000178  e8bd4ffe          POP      {r1-r11,lr}
00017c  f7ffbffe          B.W      pbuf_free
                  |L2.384|
;;;236      return;
;;;237    lenerr:
;;;238      pbuf_free(p);
000180  4628              MOV      r0,r5
000182  f7fffffe          BL       pbuf_free
;;;239      ICMP_STATS_INC(icmp.lenerr);
000186  f8370f6a          LDRH     r0,[r7,#0x6a]!  ; lwip_stats
;;;240      snmp_inc_icmpinerrors();
;;;241      return;
00018a  e004              B        |L2.406|
                  |L2.396|
;;;242    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;243    memerr:
;;;244      pbuf_free(p);
00018c  4628              MOV      r0,r5
00018e  f7fffffe          BL       pbuf_free
;;;245      ICMP_STATS_INC(icmp.err);
000192  f8370f74          LDRH     r0,[r7,#0x74]!  ; lwip_stats
                  |L2.406|
000196  1c40              ADDS     r0,r0,#1
000198  8038              STRH     r0,[r7,#0]
;;;246      snmp_inc_icmpinerrors();
;;;247      return;
;;;248    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;249    }
00019a  e8bd8ffe          POP      {r1-r11,pc}
;;;250    
                          ENDP

00019e  0000              DCW      0x0000
                  |L2.416|
                          DCD      lwip_stats
                  |L2.420|
                          DCD      current_iphdr_dest
                  |L2.424|
0001a8  69636d70          DCB      "icmp_input: moving p->payload to ip header failed\n",0
0001ac  5f696e70
0001b0  75743a20
0001b4  6d6f7669
0001b8  6e672070
0001bc  2d3e7061
0001c0  796c6f61
0001c4  6420746f
0001c8  20697020
0001cc  68656164
0001d0  65722066
0001d4  61696c65
0001d8  640a00  
0001db  00                DCB      0
                  |L2.476|
0001dc  63686563          DCB      "check that first pbuf can hold struct the ICMP header",0
0001e0  6b207468
0001e4  61742066
0001e8  69727374
0001ec  20706275
0001f0  66206361
0001f4  6e20686f
0001f8  6c642073
0001fc  74727563
000200  74207468
000204  65204943
000208  4d502068
00020c  65616465
000210  7200    
000212  00                DCB      0
000213  00                DCB      0
                  |L2.532|
000214  69636d70          DCB      "icmp_input: copying to new pbuf failed\n",0
000218  5f696e70
00021c  75743a20
000220  636f7079
000224  696e6720
000228  746f206e
00022c  65772070
000230  62756620
000234  6661696c
000238  65640a00
                  |L2.572|
00023c  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
000240  5f696e70
000244  75743a20
000248  72657374
00024c  6f72696e
000250  67206f72
000254  6967696e
000258  616c2070
00025c  2d3e7061
000260  796c6f61
000264  64206661
000268  696c6564
00026c  0a00    
00026e  00                DCB      0
00026f  00                DCB      0
                  |L2.624|
                          DCD      current_iphdr_src
                  |L2.628|
000274  43616e27          DCB      "Can't move over header in packet",0
000278  74206d6f
00027c  7665206f
000280  76657220
000284  68656164
000288  65722069
00028c  6e207061
000290  636b6574
000294  00      
000295  00                DCB      0
000296  00                DCB      0
000297  00                DCB      0

                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=2

                  icmp_send_response PROC
;;;290    static void
;;;291    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;292    {
000004  4691              MOV      r9,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;293      struct pbuf *q;
;;;294      struct ip_hdr *iphdr;
;;;295      /* we can use the echo header here */
;;;296      struct icmp_echo_hdr *icmphdr;
;;;297      ip_addr_t iphdr_src;
;;;298    
;;;299      /* ICMP header + IP header + 8 bytes of data */
;;;300      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00000a  2200              MOVS     r2,#0
00000c  2124              MOVS     r1,#0x24
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       pbuf_alloc
000014  0005              MOVS     r5,r0
;;;301                     PBUF_RAM);
;;;302      if (q == NULL) {
000016  d02f              BEQ      |L3.120|
;;;303        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
;;;304        return;
;;;305      }
;;;306      LWIP_ASSERT("check that first pbuf can hold icmp message",
000018  8968              LDRH     r0,[r5,#0xa]
00001a  2824              CMP      r0,#0x24
00001c  d203              BCS      |L3.38|
00001e  a017              ADR      r0,|L3.124|
000020  f7fffffe          BL       __2printf
                  |L3.36|
000024  e7fe              B        |L3.36|
                  |L3.38|
;;;307                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;308    
;;;309      iphdr = (struct ip_hdr *)p->payload;
;;;310      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;311      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;312      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;315    
;;;316      icmphdr = (struct icmp_echo_hdr *)q->payload;
;;;317      icmphdr->type = type;
000026  686c              LDR      r4,[r5,#4]
000028  f8d78004          LDR      r8,[r7,#4]            ;316
;;;318      icmphdr->code = code;
;;;319      icmphdr->id = 0;
;;;320      icmphdr->seqno = 0;
;;;321    
;;;322      /* copy fields from original packet */
;;;323      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
00002c  221c              MOVS     r2,#0x1c
00002e  7026              STRB     r6,[r4,#0]            ;317
000030  f8849001          STRB     r9,[r4,#1]            ;318
000034  2600              MOVS     r6,#0                 ;319
000036  80a6              STRH     r6,[r4,#4]            ;319
000038  80e6              STRH     r6,[r4,#6]            ;320
00003a  6868              LDR      r0,[r5,#4]
00003c  6879              LDR      r1,[r7,#4]
00003e  3008              ADDS     r0,r0,#8
000040  f7fffffe          BL       __aeabi_memcpy
;;;324              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;325    
;;;326      /* calculate checksum */
;;;327      icmphdr->chksum = 0;
000044  8066              STRH     r6,[r4,#2]
;;;328      icmphdr->chksum = inet_chksum(icmphdr, q->len);
000046  8969              LDRH     r1,[r5,#0xa]
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       inet_chksum
00004e  8060              STRH     r0,[r4,#2]
;;;329      ICMP_STATS_INC(icmp.xmit);
000050  4815              LDR      r0,|L3.168|
;;;330      /* increase number of messages attempted to send */
;;;331      snmp_inc_icmpoutmsgs();
;;;332      /* increase number of destination unreachable messages attempted to send */
;;;333      snmp_inc_icmpouttimeexcds();
;;;334      ip_addr_copy(iphdr_src, iphdr->src);
;;;335      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
000052  23ff              MOVS     r3,#0xff
000054  aa02              ADD      r2,sp,#8
000056  f8301f60          LDRH     r1,[r0,#0x60]!        ;329  ; lwip_stats
00005a  1c49              ADDS     r1,r1,#1              ;329
00005c  8001              STRH     r1,[r0,#0]            ;329
00005e  f8d8000c          LDR      r0,[r8,#0xc]          ;334
000062  9002              STR      r0,[sp,#8]
000064  2001              MOVS     r0,#1
000066  e9cd6000          STRD     r6,r0,[sp,#0]
00006a  2100              MOVS     r1,#0
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       ip_output
;;;336      pbuf_free(q);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       pbuf_free
                  |L3.120|
;;;337    }
000078  e8bd83fe          POP      {r1-r9,pc}
;;;338    
                          ENDP

                  |L3.124|
00007c  63686563          DCB      "check that first pbuf can hold icmp message",0
000080  6b207468
000084  61742066
000088  69727374
00008c  20706275
000090  66206361
000094  6e20686f
000098  6c642069
00009c  636d7020
0000a0  6d657373
0000a4  61676500
                  |L3.168|
                          DCD      lwip_stats

                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=1

                  icmp_time_exceeded PROC
;;;274    void
;;;275    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  460a              MOV      r2,r1
;;;276    {
;;;277      icmp_send_response(p, ICMP_TE, t);
000002  210b              MOVS     r1,#0xb
000004  f7ffbffe          B.W      icmp_send_response
;;;278    }
;;;279    
                          ENDP

