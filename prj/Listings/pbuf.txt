; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\pbuf.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\pbuf.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\app -I..\board -I..\cmsis -I..\lwip\src -I..\lwip\src\api -I..\lwip\src\arch -I..\lwip\src\core -I..\lwip\src\core\snmp -I..\lwip\src\include -I..\lwip\src\include\lwip -I..\lwip\src\include\ipv4 -I..\lwip\src\include\ipv4\lwip -I..\lwip\src\include\posix -I..\lwip\src\include\posix\sys -I..\lwip\src\netif -I..\lwip\src\netif\ppp -I..\stm_lib\inc -I..\stm_lib\src -I.\RTE\_lwip -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\pbuf.crf ..\lwip\src\core\pbuf.c]
                          THUMB

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=2

                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
000004  4617              MOV      r7,r2
000006  460d              MOV      r5,r1
000008  b148              CBZ      r0,|L1.30|
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
00000a  2801              CMP      r0,#1
00000c  d009              BEQ      |L1.34|
00000e  2802              CMP      r0,#2
000010  d009              BEQ      |L1.38|
000012  2803              CMP      r0,#3
000014  d009              BEQ      |L1.42|
;;;216      case PBUF_TRANSPORT:
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
;;;219        break;
;;;220      case PBUF_IP:
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
;;;223        break;
;;;224      case PBUF_LINK:
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
;;;227        break;
;;;228      case PBUF_RAW:
;;;229        offset = 0;
;;;230        break;
;;;231      default:
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
000016  a05f              ADR      r0,|L1.404|
000018  f7fffffe          BL       __2printf
                  |L1.28|
00001c  e7fe              B        |L1.28|
                  |L1.30|
00001e  2636              MOVS     r6,#0x36              ;218
000020  e004              B        |L1.44|
                  |L1.34|
000022  2622              MOVS     r6,#0x22              ;222
000024  e002              B        |L1.44|
                  |L1.38|
000026  260e              MOVS     r6,#0xe               ;226
000028  e000              B        |L1.44|
                  |L1.42|
00002a  2600              MOVS     r6,#0                 ;229
                  |L1.44|
00002c  f04f0a01          MOV      r10,#1                ;208
000030  f04f0900          MOV      r9,#0                 ;208
;;;233        return NULL;
;;;234      }
;;;235    
;;;236      switch (type) {
000034  2f00              CMP      r7,#0
000036  d07d              BEQ      |L1.308|
000038  2f01              CMP      r7,#1
                  |L1.58|
00003a  d073              BEQ      |L1.292|
00003c  2f02              CMP      r7,#2
00003e  d0fc              BEQ      |L1.58|
000040  2f03              CMP      r7,#3
000042  d003              BEQ      |L1.76|
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;241        if (p == NULL) {
;;;242          PBUF_POOL_IS_EMPTY();
;;;243          return NULL;
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
000044  a05a              ADR      r0,|L1.432|
000046  f7fffffe          BL       __2printf
                  |L1.74|
00004a  e7fe              B        |L1.74|
                  |L1.76|
00004c  2009              MOVS     r0,#9                 ;239
00004e  f7fffffe          BL       memp_malloc
000052  f8dfb178          LDR      r11,|L1.460|
000056  0004              MOVS     r4,r0                 ;239
000058  d00c              BEQ      |L1.116|
00005a  19a0              ADDS     r0,r4,r6              ;249
00005c  3013              ADDS     r0,r0,#0x13           ;249
00005e  f0200103          BIC      r1,r0,#3              ;249
000062  7327              STRB     r7,[r4,#0xc]          ;245
000064  e9c49100          STRD     r9,r1,[r4,#0]         ;250
000068  0788              LSLS     r0,r1,#30             ;250
00006a  d006              BEQ      |L1.122|
00006c  a058              ADR      r0,|L1.464|
00006e  f7fffffe          BL       __2printf
                  |L1.114|
000072  e7fe              B        |L1.114|
                  |L1.116|
000074  f88ba000          STRB     r10,[r11,#0]          ;250
000078  e036              B        |L1.232|
                  |L1.122|
00007a  1cf6              ADDS     r6,r6,#3              ;253
00007c  f0260003          BIC      r0,r6,#3              ;255
000080  f5c06284          RSB      r2,r0,#0x420          ;255
000084  8125              STRH     r5,[r4,#8]            ;253
000086  42aa              CMP      r2,r5                 ;255
000088  dd01              BLE      |L1.142|
00008a  4628              MOV      r0,r5                 ;255
00008c  e000              B        |L1.144|
                  |L1.142|
00008e  4610              MOV      r0,r2                 ;255
                  |L1.144|
000090  180b              ADDS     r3,r1,r0              ;256
000092  f5046886          ADD      r8,r4,#0x430          ;256
000096  8160              STRH     r0,[r4,#0xa]          ;255
000098  4543              CMP      r3,r8                 ;256
00009a  d903              BLS      |L1.164|
00009c  a058              ADR      r0,|L1.512|
00009e  f7fffffe          BL       __2printf
                  |L1.162|
0000a2  e7fe              B        |L1.162|
                  |L1.164|
0000a4  2a00              CMP      r2,#0                 ;259
0000a6  dc03              BGT      |L1.176|
0000a8  a062              ADR      r0,|L1.564|
0000aa  f7fffffe          BL       __2printf
                  |L1.174|
0000ae  e7fe              B        |L1.174|
                  |L1.176|
0000b0  f8a4a00e          STRH     r10,[r4,#0xe]         ;262
0000b4  4626              MOV      r6,r4                 ;267
0000b6  1a2d              SUBS     r5,r5,r0              ;269
0000b8  e039              B        |L1.302|
                  |L1.186|
0000ba  2009              MOVS     r0,#9                 ;272
0000bc  f7fffffe          BL       memp_malloc
0000c0  b168              CBZ      r0,|L1.222|
0000c2  7307              STRB     r7,[r0,#0xc]          ;280
0000c4  f880900d          STRB     r9,[r0,#0xd]          ;281
0000c8  f8c09000          STR      r9,[r0,#0]            ;284
0000cc  f64f71ff          MOV      r1,#0xffff            ;286
0000d0  6030              STR      r0,[r6,#0]            ;286
0000d2  428d              CMP      r5,r1                 ;286
0000d4  db0b              BLT      |L1.238|
0000d6  a064              ADR      r0,|L1.616|
0000d8  f7fffffe          BL       __2printf
                  |L1.220|
0000dc  e7fe              B        |L1.220|
                  |L1.222|
0000de  f88ba000          STRB     r10,[r11,#0]          ;286
0000e2  4620              MOV      r0,r4                 ;276
0000e4  f7fffffe          BL       pbuf_free
                  |L1.232|
0000e8  2000              MOVS     r0,#0                 ;278
                  |L1.234|
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
0000ea  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.238|
0000ee  b2a9              UXTH     r1,r5                 ;287
0000f0  f44f6284          MOV      r2,#0x420             ;289
0000f4  8101              STRH     r1,[r0,#8]            ;287
0000f6  4291              CMP      r1,r2                 ;289
0000f8  d300              BCC      |L1.252|
0000fa  4611              MOV      r1,r2                 ;289
                  |L1.252|
0000fc  8141              STRH     r1,[r0,#0xa]          ;289
0000fe  f1000210          ADD      r2,r0,#0x10           ;290
000102  6042              STR      r2,[r0,#4]            ;291
000104  0792              LSLS     r2,r2,#30             ;291
000106  d003              BEQ      |L1.272|
000108  a05c              ADR      r0,|L1.636|
00010a  f7fffffe          BL       __2printf
                  |L1.270|
00010e  e7fe              B        |L1.270|
                  |L1.272|
000110  8963              LDRH     r3,[r4,#0xa]          ;293
000112  6862              LDR      r2,[r4,#4]            ;293
000114  4413              ADD      r3,r3,r2              ;293
000116  4543              CMP      r3,r8                 ;293
000118  d905              BLS      |L1.294|
00011a  a039              ADR      r0,|L1.512|
00011c  f7fffffe          BL       __2printf
                  |L1.288|
000120  e7fe              B        |L1.288|
000122  e007              B        |L1.308|
                  |L1.292|
000124  e024              B        |L1.368|
                  |L1.294|
000126  f8a0a00e          STRH     r10,[r0,#0xe]         ;296
00012a  1a6d              SUBS     r5,r5,r1              ;298
00012c  4606              MOV      r6,r0                 ;300
                  |L1.302|
00012e  2d00              CMP      r5,#0                 ;271
000130  dcc3              BGT      |L1.186|
000132  e029              B        |L1.392|
                  |L1.308|
000134  f1060013          ADD      r0,r6,#0x13           ;308
000138  f0200103          BIC      r1,r0,#3              ;308
00013c  1ce8              ADDS     r0,r5,#3              ;308
00013e  f0200003          BIC      r0,r0,#3              ;308
000142  4408              ADD      r0,r0,r1              ;308
000144  b280              UXTH     r0,r0                 ;308
000146  f7fffffe          BL       mem_malloc
00014a  1e04              SUBS     r4,r0,#0              ;308
00014c  d0cd              BEQ      |L1.234|
00014e  19a0              ADDS     r0,r4,r6              ;313
000150  3013              ADDS     r0,r0,#0x13           ;313
000152  f0200003          BIC      r0,r0,#3              ;313
000156  6060              STR      r0,[r4,#4]            ;314
000158  8125              STRH     r5,[r4,#8]            ;314
00015a  8165              STRH     r5,[r4,#0xa]          ;314
00015c  f8c49000          STR      r9,[r4,#0]            ;316
000160  f884900c          STRB     r9,[r4,#0xc]          ;316
000164  0780              LSLS     r0,r0,#30             ;318
000166  d00f              BEQ      |L1.392|
000168  a050              ADR      r0,|L1.684|
00016a  f7fffffe          BL       __2printf
                  |L1.366|
00016e  e7fe              B        |L1.366|
                  |L1.368|
000170  2008              MOVS     r0,#8                 ;326
000172  f7fffffe          BL       memp_malloc
000176  1e04              SUBS     r4,r0,#0              ;326
000178  d0b7              BEQ      |L1.234|
00017a  f8c49004          STR      r9,[r4,#4]            ;335
00017e  8125              STRH     r5,[r4,#8]            ;335
000180  8165              STRH     r5,[r4,#0xa]          ;335
000182  f8c49000          STR      r9,[r4,#0]            ;337
000186  7327              STRB     r7,[r4,#0xc]          ;337
                  |L1.392|
000188  f8a4a00e          STRH     r10,[r4,#0xe]         ;344
00018c  f884900d          STRB     r9,[r4,#0xd]          ;346
000190  4620              MOV      r0,r4                 ;348
000192  e7aa              B        |L1.234|
;;;350    
                          ENDP

                  |L1.404|
000194  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
000198  5f616c6c
00019c  6f633a20
0001a0  62616420
0001a4  70627566
0001a8  206c6179
0001ac  657200  
0001af  00                DCB      0
                  |L1.432|
0001b0  70627566          DCB      "pbuf_alloc: erroneous type",0
0001b4  5f616c6c
0001b8  6f633a20
0001bc  6572726f
0001c0  6e656f75
0001c4  73207479
0001c8  706500  
0001cb  00                DCB      0
                  |L1.460|
                          DCD      ||.data||
                  |L1.464|
0001d0  70627566          DCB      "pbuf_alloc: pbuf p->payload properly aligned",0
0001d4  5f616c6c
0001d8  6f633a20
0001dc  70627566
0001e0  20702d3e
0001e4  7061796c
0001e8  6f616420
0001ec  70726f70
0001f0  65726c79
0001f4  20616c69
0001f8  676e6564
0001fc  00      
0001fd  00                DCB      0
0001fe  00                DCB      0
0001ff  00                DCB      0
                  |L1.512|
000200  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
000204  6b20702d
000208  3e706179
00020c  6c6f6164
000210  202b2070
000214  2d3e6c65
000218  6e20646f
00021c  6573206e
000220  6f74206f
000224  76657266
000228  6c6f7720
00022c  70627566
000230  00      
000231  00                DCB      0
000232  00                DCB      0
000233  00                DCB      0
                  |L1.564|
000234  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
000238  5f504f4f
00023c  4c5f4255
000240  4653495a
000244  45206d75
000248  73742062
00024c  65206269
000250  67676572
000254  20746861
000258  6e204d45
00025c  4d5f414c
000260  49474e4d
000264  454e5400
                  |L1.616|
000268  72656d5f          DCB      "rem_len < max_u16_t",0
00026c  6c656e20
000270  3c206d61
000274  785f7531
000278  365f7400
                  |L1.636|
00027c  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
000280  5f616c6c
000284  6f633a20
000288  70627566
00028c  20712d3e
000290  7061796c
000294  6f616420
000298  70726f70
00029c  65726c79
0002a0  20616c69
0002a4  676e6564
0002a8  00      
0002a9  00                DCB      0
0002aa  00                DCB      0
0002ab  00                DCB      0
                  |L1.684|
0002ac  70627566          DCB      "pbuf_alloc: pbuf->payload properly aligned",0
0002b0  5f616c6c
0002b4  6f633a20
0002b8  70627566
0002bc  2d3e7061
0002c0  796c6f61
0002c4  64207072
0002c8  6f706572
0002cc  6c792061
0002d0  6c69676e
0002d4  656400  
0002d7  00                DCB      0

                          AREA ||i.pbuf_alloced_custom||, CODE, READONLY, ALIGN=2

                  pbuf_alloced_custom PROC
;;;366    struct pbuf*
;;;367    pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
000000  b570              PUSH     {r4-r6,lr}
;;;368                        void *payload_mem, u16_t payload_mem_len)
;;;369    {
000002  e9dd4504          LDRD     r4,r5,[sp,#0x10]
000006  b148              CBZ      r0,|L2.28|
;;;370      u16_t offset;
;;;371      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));
;;;372    
;;;373      /* determine header offset */
;;;374      switch (l) {
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L2.32|
00000c  2802              CMP      r0,#2
00000e  d009              BEQ      |L2.36|
000010  2803              CMP      r0,#3
000012  d009              BEQ      |L2.40|
;;;375      case PBUF_TRANSPORT:
;;;376        /* add room for transport (often TCP) layer header */
;;;377        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
;;;378        break;
;;;379      case PBUF_IP:
;;;380        /* add room for IP layer header */
;;;381        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
;;;382        break;
;;;383      case PBUF_LINK:
;;;384        /* add room for link layer header */
;;;385        offset = PBUF_LINK_HLEN;
;;;386        break;
;;;387      case PBUF_RAW:
;;;388        offset = 0;
;;;389        break;
;;;390      default:
;;;391        LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
000014  a011              ADR      r0,|L2.92|
000016  f7fffffe          BL       __2printf
                  |L2.26|
00001a  e7fe              B        |L2.26|
                  |L2.28|
00001c  2036              MOVS     r0,#0x36              ;377
00001e  e004              B        |L2.42|
                  |L2.32|
000020  2022              MOVS     r0,#0x22              ;381
000022  e002              B        |L2.42|
                  |L2.36|
000024  200e              MOVS     r0,#0xe               ;385
000026  e000              B        |L2.42|
                  |L2.40|
000028  2000              MOVS     r0,#0                 ;388
                  |L2.42|
00002a  1cc0              ADDS     r0,r0,#3              ;388
;;;392        return NULL;
;;;393      }
;;;394    
;;;395      if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
00002c  f0200003          BIC      r0,r0,#3
000030  1846              ADDS     r6,r0,r1
000032  42ae              CMP      r6,r5
000034  d901              BLS      |L2.58|
;;;396        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
;;;397        return NULL;
000036  2000              MOVS     r0,#0
;;;398      }
;;;399    
;;;400      p->pbuf.next = NULL;
;;;401      if (payload_mem != NULL) {
;;;402        p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
;;;403      } else {
;;;404        p->pbuf.payload = NULL;
;;;405      }
;;;406      p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
;;;407      p->pbuf.len = p->pbuf.tot_len = length;
;;;408      p->pbuf.type = type;
;;;409      p->pbuf.ref = 1;
;;;410      return &p->pbuf;
;;;411    }
000038  bd70              POP      {r4-r6,pc}
                  |L2.58|
00003a  2500              MOVS     r5,#0                 ;400
00003c  601d              STR      r5,[r3,#0]            ;401
00003e  b114              CBZ      r4,|L2.70|
000040  4420              ADD      r0,r0,r4              ;402
000042  6058              STR      r0,[r3,#4]            ;402
000044  e000              B        |L2.72|
                  |L2.70|
000046  605d              STR      r5,[r3,#4]            ;404
                  |L2.72|
000048  2002              MOVS     r0,#2                 ;406
00004a  7358              STRB     r0,[r3,#0xd]          ;406
00004c  8119              STRH     r1,[r3,#8]            ;407
00004e  8159              STRH     r1,[r3,#0xa]          ;407
000050  731a              STRB     r2,[r3,#0xc]          ;408
000052  2001              MOVS     r0,#1                 ;409
000054  81d8              STRH     r0,[r3,#0xe]          ;409
000056  4618              MOV      r0,r3                 ;410
000058  bd70              POP      {r4-r6,pc}
;;;412    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
                          ENDP

00005a  0000              DCW      0x0000
                  |L2.92|
00005c  70627566          DCB      "pbuf_alloced_custom: bad pbuf layer",0
000060  5f616c6c
000064  6f636564
000068  5f637573
00006c  746f6d3a
000070  20626164
000074  20706275
000078  66206c61
00007c  79657200

                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  b510              PUSH     {r4,lr}
;;;746    {
000002  b100              CBZ      r0,|L3.6|
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000004  b949              CBNZ     r1,|L3.26|
                  |L3.6|
000006  e8bd4010          POP      {r4,lr}
00000a  a00c              ADR      r0,|L3.60|
00000c  f7ffbffe          B.W      __2printf
                  |L3.16|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
000010  8903              LDRH     r3,[r0,#8]
000012  890c              LDRH     r4,[r1,#8]
000014  4423              ADD      r3,r3,r4
000016  8103              STRH     r3,[r0,#8]
000018  4610              MOV      r0,r2
                  |L3.26|
00001a  6802              LDR      r2,[r0,#0]            ;753
00001c  2a00              CMP      r2,#0                 ;753
00001e  d1f7              BNE      |L3.16|
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
000020  8902              LDRH     r2,[r0,#8]
000022  8943              LDRH     r3,[r0,#0xa]
000024  429a              CMP      r2,r3
000026  d003              BEQ      |L3.48|
000028  a012              ADR      r0,|L3.116|
00002a  f7fffffe          BL       __2printf
                  |L3.46|
00002e  e7fe              B        |L3.46|
                  |L3.48|
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
000030  890b              LDRH     r3,[r1,#8]
000032  441a              ADD      r2,r2,r3
000034  8102              STRH     r2,[r0,#8]
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
000036  6001              STR      r1,[r0,#0]
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
000038  bd10              POP      {r4,pc}
;;;768    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
00003c  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000040  3d204e55
000044  4c4c2920
000048  26262028
00004c  7420213d
000050  204e554c
000054  4c292028
000058  70726f67
00005c  72616d6d
000060  65722076
000064  696f6c61
000068  74657320
00006c  41504929
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L3.116|
000074  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
000078  6f745f6c
00007c  656e203d
000080  3d20702d
000084  3e6c656e
000088  20286f66
00008c  206c6173
000090  74207062
000094  75662069
000098  6e206368
00009c  61696e29
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=1

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  b510              PUSH     {r4,lr}
;;;787    {
000002  460c              MOV      r4,r1
;;;788      pbuf_cat(h, t);
000004  f7fffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
000008  4620              MOV      r0,r4
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
;;;792    }
;;;793    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=1

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
000000  2100              MOVS     r1,#0
;;;705    {
000002  e002              B        |L5.10|
                  |L5.4|
000004  1c49              ADDS     r1,r1,#1
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
;;;709      while (p != NULL) {
;;;710        ++len;
;;;711        p = p->next;
000006  6800              LDR      r0,[r0,#0]
000008  b2c9              UXTB     r1,r1                 ;710
                  |L5.10|
00000a  2800              CMP      r0,#0                 ;709
00000c  d1fa              BNE      |L5.4|
;;;712      }
;;;713      return len;
00000e  4608              MOV      r0,r1
;;;714    }
000010  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=2

                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  b570              PUSH     {r4-r6,lr}
;;;1011   {
000002  4604              MOV      r4,r0
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
000004  6800              LDR      r0,[r0,#0]
000006  460b              MOV      r3,r1                 ;1011
000008  b170              CBZ      r0,|L6.40|
;;;1015       return p;
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
00000a  8921              LDRH     r1,[r4,#8]
00000c  2200              MOVS     r2,#0
00000e  4618              MOV      r0,r3
000010  f7fffffe          BL       pbuf_alloc
000014  0005              MOVS     r5,r0
;;;1018     if (q == NULL) {
000016  d007              BEQ      |L6.40|
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       pbuf_copy
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
00001e  b128              CBZ      r0,|L6.44|
000020  a005              ADR      r0,|L6.56|
000022  f7fffffe          BL       __2printf
                  |L6.38|
000026  e7fe              B        |L6.38|
                  |L6.40|
000028  4620              MOV      r0,r4                 ;1020
;;;1024     pbuf_free(p);
;;;1025     return q;
;;;1026   }
00002a  bd70              POP      {r4-r6,pc}
                  |L6.44|
00002c  4620              MOV      r0,r4                 ;1024
00002e  f7fffffe          BL       pbuf_free
000032  4628              MOV      r0,r5                 ;1025
000034  bd70              POP      {r4-r6,pc}
;;;1027   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
000038  70627566          DCB      "pbuf_copy failed",0
00003c  5f636f70
000040  79206661
000044  696c6564
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;853    {
;;;854      u16_t offset_to=0, offset_from=0, len;
000004  f04f0600          MOV      r6,#0
000008  460c              MOV      r4,r1                 ;853
00000a  0005              MOVS     r5,r0                 ;853
00000c  4637              MOV      r7,r6
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
00000e  f06f090d          MVN      r9,#0xd
000012  d004              BEQ      |L7.30|
000014  b11c              CBZ      r4,|L7.30|
000016  8928              LDRH     r0,[r5,#8]
000018  8921              LDRH     r1,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  d201              BCS      |L7.34|
                  |L7.30|
00001e  a028              ADR      r0,|L7.192|
000020  e039              B        |L7.150|
                  |L7.34|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
000022  f06f0a05          MVN      r10,#5
                  |L7.38|
000026  8968              LDRH     r0,[r5,#0xa]          ;867
000028  8961              LDRH     r1,[r4,#0xa]          ;867
00002a  1b80              SUBS     r0,r0,r6              ;867
00002c  1bc9              SUBS     r1,r1,r7              ;867
00002e  4288              CMP      r0,r1                 ;867
000030  db01              BLT      |L7.54|
000032  b288              UXTH     r0,r1                 ;869
000034  e000              B        |L7.56|
                  |L7.54|
000036  b280              UXTH     r0,r0                 ;872
                  |L7.56|
000038  4680              MOV      r8,r0                 ;872
00003a  6860              LDR      r0,[r4,#4]            ;874
00003c  4642              MOV      r2,r8                 ;874
00003e  19c1              ADDS     r1,r0,r7              ;874
000040  6868              LDR      r0,[r5,#4]            ;874
000042  4430              ADD      r0,r0,r6              ;874
000044  f7fffffe          BL       __aeabi_memcpy
000048  eb060008          ADD      r0,r6,r8              ;875
00004c  b286              UXTH     r6,r0                 ;875
00004e  eb070008          ADD      r0,r7,r8              ;876
000052  b287              UXTH     r7,r0                 ;876
000054  8968              LDRH     r0,[r5,#0xa]          ;877
000056  42b0              CMP      r0,r6                 ;877
000058  d203              BCS      |L7.98|
00005a  a025              ADR      r0,|L7.240|
00005c  f7fffffe          BL       __2printf
                  |L7.96|
000060  e7fe              B        |L7.96|
                  |L7.98|
000062  8961              LDRH     r1,[r4,#0xa]          ;878
000064  42b9              CMP      r1,r7                 ;878
000066  d203              BCS      |L7.112|
000068  a027              ADR      r0,|L7.264|
00006a  f7fffffe          BL       __2printf
                  |L7.110|
00006e  e7fe              B        |L7.110|
                  |L7.112|
000070  d802              BHI      |L7.120|
000072  6824              LDR      r4,[r4,#0]            ;882
000074  f04f0700          MOV      r7,#0                 ;881
                  |L7.120|
000078  42b0              CMP      r0,r6                 ;884
00007a  d102              BNE      |L7.130|
00007c  682d              LDR      r5,[r5,#0]            ;887
00007e  2600              MOVS     r6,#0                 ;886
000080  b13d              CBZ      r5,|L7.146|
                  |L7.130|
000082  b16c              CBZ      r4,|L7.160|
000084  8960              LDRH     r0,[r4,#0xa]          ;891
000086  8921              LDRH     r1,[r4,#8]            ;891
000088  4288              CMP      r0,r1                 ;891
00008a  d109              BNE      |L7.160|
00008c  6820              LDR      r0,[r4,#0]
00008e  b970              CBNZ     r0,|L7.174|
000090  e006              B        |L7.160|
                  |L7.146|
000092  b19c              CBZ      r4,|L7.188|
000094  a023              ADR      r0,|L7.292|
                  |L7.150|
000096  f7fffffe          BL       __2printf
00009a  4648              MOV      r0,r9                 ;888
                  |L7.156|
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
00009c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.160|
0000a0  b155              CBZ      r5,|L7.184|
0000a2  8968              LDRH     r0,[r5,#0xa]          ;896
0000a4  8929              LDRH     r1,[r5,#8]            ;896
0000a6  4288              CMP      r0,r1                 ;896
0000a8  d106              BNE      |L7.184|
0000aa  6828              LDR      r0,[r5,#0]            ;898
0000ac  b120              CBZ      r0,|L7.184|
                  |L7.174|
0000ae  a021              ADR      r0,|L7.308|
0000b0  f7fffffe          BL       __2printf
0000b4  4650              MOV      r0,r10                ;898
0000b6  e7f1              B        |L7.156|
                  |L7.184|
0000b8  2c00              CMP      r4,#0                 ;901
0000ba  d1b4              BNE      |L7.38|
                  |L7.188|
0000bc  2000              MOVS     r0,#0                 ;903
0000be  e7ed              B        |L7.156|
;;;905    
                          ENDP

                  |L7.192|
0000c0  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
0000c4  5f636f70
0000c8  793a2074
0000cc  61726765
0000d0  74206e6f
0000d4  74206269
0000d8  6720656e
0000dc  6f756768
0000e0  20746f20
0000e4  686f6c64
0000e8  20736f75
0000ec  72636500
                  |L7.240|
0000f0  6f666673          DCB      "offset_to <= p_to->len",0
0000f4  65745f74
0000f8  6f203c3d
0000fc  20705f74
000100  6f2d3e6c
000104  656e00  
000107  00                DCB      0
                  |L7.264|
000108  6f666673          DCB      "offset_from <= p_from->len",0
00010c  65745f66
000110  726f6d20
000114  3c3d2070
000118  5f66726f
00011c  6d2d3e6c
000120  656e00  
000123  00                DCB      0
                  |L7.292|
000124  705f746f          DCB      "p_to != NULL",0
000128  20213d20
00012c  4e554c4c
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L7.308|
000134  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
000138  5f636f70
00013c  79282920
000140  646f6573
000144  206e6f74
000148  20616c6c
00014c  6f772070
000150  61636b65
000154  74207175
000158  65756573
00015c  210a00  
00015f  00                DCB      0

                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;919    {
000004  4616              MOV      r6,r2
000006  4689              MOV      r9,r1
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
000008  f04f0800          MOV      r8,#0
00000c  b128              CBZ      r0,|L8.26|
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
00000e  f1b90f00          CMP      r9,#0
000012  d004              BEQ      |L8.30|
;;;927    
;;;928      left = 0;
000014  2700              MOVS     r7,#0
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
000016  4604              MOV      r4,r0
000018  e025              B        |L8.102|
                  |L8.26|
00001a  a015              ADR      r0,|L8.112|
00001c  e000              B        |L8.32|
                  |L8.30|
00001e  a01c              ADR      r0,|L8.144|
                  |L8.32|
000020  f7fffffe          BL       __2printf
000024  2000              MOVS     r0,#0                 ;926
                  |L8.38|
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L8.42|
00002a  b12b              CBZ      r3,|L8.56|
00002c  8960              LDRH     r0,[r4,#0xa]          ;936
00002e  4298              CMP      r0,r3                 ;936
000030  d802              BHI      |L8.56|
000032  1a18              SUBS     r0,r3,r0              ;938
000034  b283              UXTH     r3,r0                 ;938
000036  e015              B        |L8.100|
                  |L8.56|
000038  8960              LDRH     r0,[r4,#0xa]          ;941
00003a  1ac0              SUBS     r0,r0,r3              ;941
00003c  b285              UXTH     r5,r0                 ;941
00003e  42b5              CMP      r5,r6                 ;942
000040  d900              BLS      |L8.68|
000042  4635              MOV      r5,r6                 ;943
                  |L8.68|
000044  6860              LDR      r0,[r4,#4]            ;945
000046  462a              MOV      r2,r5                 ;945
000048  18c1              ADDS     r1,r0,r3              ;945
00004a  eb090007          ADD      r0,r9,r7              ;945
00004e  f7fffffe          BL       __aeabi_memcpy
000052  eb080005          ADD      r0,r8,r5              ;946
000056  fa1ff880          UXTH     r8,r0                 ;946
00005a  1978              ADDS     r0,r7,r5              ;947
00005c  b287              UXTH     r7,r0                 ;947
00005e  1b70              SUBS     r0,r6,r5              ;948
000060  b286              UXTH     r6,r0                 ;948
000062  2300              MOVS     r3,#0                 ;949
                  |L8.100|
000064  6824              LDR      r4,[r4,#0]            ;935
                  |L8.102|
000066  b10e              CBZ      r6,|L8.108|
000068  2c00              CMP      r4,#0                 ;935
00006a  d1de              BNE      |L8.42|
                  |L8.108|
00006c  4640              MOV      r0,r8                 ;952
00006e  e7da              B        |L8.38|
;;;954    
                          ENDP

                  |L8.112|
000070  70627566          DCB      "pbuf_copy_partial: invalid buf",0
000074  5f636f70
000078  795f7061
00007c  72746961
000080  6c3a2069
000084  6e76616c
000088  69642062
00008c  756600  
00008f  00                DCB      0
                  |L8.144|
000090  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
000094  5f636f70
000098  795f7061
00009c  72746961
0000a0  6c3a2069
0000a4  6e76616c
0000a8  69642064
0000ac  61746170
0000b0  747200  
0000b3  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=2

                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;804    {
000002  4604              MOV      r4,r0
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
000004  2001              MOVS     r0,#1
000006  6825              LDR      r5,[r4,#0]            ;804
000008  b18d              CBZ      r5,|L9.46|
;;;807      /* tail */
;;;808      q = p->next;
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
00000a  8920              LDRH     r0,[r4,#8]
00000c  8961              LDRH     r1,[r4,#0xa]
00000e  1a40              SUBS     r0,r0,r1
000010  8929              LDRH     r1,[r5,#8]
000012  4288              CMP      r0,r1
000014  d003              BEQ      |L9.30|
000016  a00c              ADR      r0,|L9.72|
000018  f7fffffe          BL       __2printf
                  |L9.28|
00001c  e7fe              B        |L9.28|
                  |L9.30|
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
00001e  8128              STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
000020  2000              MOVS     r0,#0
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
000022  6020              STR      r0,[r4,#0]
000024  8960              LDRH     r0,[r4,#0xa]
000026  8120              STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
;;;821        tail_gone = pbuf_free(q);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       pbuf_free
                  |L9.46|
;;;822        if (tail_gone > 0) {
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
00002e  8921              LDRH     r1,[r4,#8]
000030  8962              LDRH     r2,[r4,#0xa]
000032  4291              CMP      r1,r2
000034  d003              BEQ      |L9.62|
000036  a00d              ADR      r0,|L9.108|
000038  f7fffffe          BL       __2printf
                  |L9.60|
00003c  e7fe              B        |L9.60|
                  |L9.62|
;;;830      return ((tail_gone > 0) ? NULL : q);
00003e  b108              CBZ      r0,|L9.68|
000040  2000              MOVS     r0,#0
;;;831    }
000042  bd70              POP      {r4-r6,pc}
                  |L9.68|
000044  4628              MOV      r0,r5                 ;830
000046  bd70              POP      {r4-r6,pc}
;;;832    
                          ENDP

                  |L9.72|
000048  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
00004c  6f745f6c
000050  656e203d
000054  3d20702d
000058  3e6c656e
00005c  202b2071
000060  2d3e746f
000064  745f6c65
000068  6e00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L9.108|
00006c  702d3e74          DCB      "p->tot_len == p->len",0
000070  6f745f6c
000074  656e203d
000078  3d20702d
00007c  3e6c656e
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=2

                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;619    {
000002  b158              CBZ      r0,|L10.28|
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
000004  7b01              LDRB     r1,[r0,#0xc]
000006  b169              CBZ      r1,|L10.36|
000008  2901              CMP      r1,#1
00000a  d00b              BEQ      |L10.36|
00000c  2902              CMP      r1,#2
00000e  d009              BEQ      |L10.36|
000010  2903              CMP      r1,#3
000012  d007              BEQ      |L10.36|
000014  a01b              ADR      r0,|L10.132|
000016  f7fffffe          BL       __2printf
                  |L10.26|
00001a  e7fe              B        |L10.26|
                  |L10.28|
00001c  a01f              ADR      r0,|L10.156|
00001e  f7fffffe          BL       __2printf
                  |L10.34|
000022  e7fe              B        |L10.34|
                  |L10.36|
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
000024  2400              MOVS     r4,#0
                  |L10.38|
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
000026  89c1              LDRH     r1,[r0,#0xe]
000028  b129              CBZ      r1,|L10.54|
00002a  1e49              SUBS     r1,r1,#1
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
00002c  0409              LSLS     r1,r1,#16
00002e  0c09              LSRS     r1,r1,#16
000030  81c1              STRH     r1,[r0,#0xe]
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
000032  d004              BEQ      |L10.62|
000034  e01c              B        |L10.112|
                  |L10.54|
000036  a01c              ADR      r0,|L10.168|
000038  f7fffffe          BL       __2printf
                  |L10.60|
00003c  e7fe              B        |L10.60|
                  |L10.62|
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
00003e  7b42              LDRB     r2,[r0,#0xd]
000040  7b01              LDRB     r1,[r0,#0xc]          ;659
000042  6805              LDR      r5,[r0,#0]
000044  0792              LSLS     r2,r2,#30
000046  d507              BPL      |L10.88|
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
000048  6901              LDR      r1,[r0,#0x10]
00004a  b109              CBZ      r1,|L10.80|
;;;665            pc->custom_free_function(p);
00004c  4788              BLX      r1
;;;666          } else
00004e  e00b              B        |L10.104|
                  |L10.80|
000050  a01b              ADR      r0,|L10.192|
000052  f7fffffe          BL       __2printf
                  |L10.86|
000056  e7fe              B        |L10.86|
                  |L10.88|
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
000058  2903              CMP      r1,#3
00005a  d00b              BEQ      |L10.116|
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
00005c  2901              CMP      r1,#1
00005e  d00c              BEQ      |L10.122|
000060  2902              CMP      r1,#2
000062  d00a              BEQ      |L10.122|
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
000064  f7fffffe          BL       mem_free
                  |L10.104|
000068  1c64              ADDS     r4,r4,#1
;;;678            }
;;;679          }
;;;680          count++;
00006a  b2e4              UXTB     r4,r4
;;;681          /* proceed to next pbuf */
;;;682          p = q;
00006c  0028              MOVS     r0,r5
00006e  d1da              BNE      |L10.38|
                  |L10.112|
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
000070  4620              MOV      r0,r4
;;;694    }
000072  bd70              POP      {r4-r6,pc}
                  |L10.116|
000074  4601              MOV      r1,r0                 ;671
000076  2009              MOVS     r0,#9                 ;671
000078  e001              B        |L10.126|
                  |L10.122|
00007a  4601              MOV      r1,r0                 ;674
00007c  2008              MOVS     r0,#8                 ;674
                  |L10.126|
00007e  f7fffffe          BL       memp_free
000082  e7f1              B        |L10.104|
;;;695    
                          ENDP

                  |L10.132|
000084  70627566          DCB      "pbuf_free: sane type",0
000088  5f667265
00008c  653a2073
000090  616e6520
000094  74797065
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L10.156|
00009c  7020213d          DCB      "p != NULL",0
0000a0  204e554c
0000a4  4c00    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L10.168|
0000a8  70627566          DCB      "pbuf_free: p->ref > 0",0
0000ac  5f667265
0000b0  653a2070
0000b4  2d3e7265
0000b8  66203e20
0000bc  3000    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L10.192|
0000c0  70632d3e          DCB      "pc->custom_free_function != NULL",0
0000c4  63757374
0000c8  6f6d5f66
0000cc  7265655f
0000d0  66756e63
0000d4  74696f6e
0000d8  20213d20
0000dc  4e554c4c
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.pbuf_free_ooseq||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;117    void
;;;118    pbuf_free_ooseq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;119    {
;;;120      struct tcp_pcb* pcb;
;;;121      SYS_ARCH_DECL_PROTECT(old_level);
;;;122    
;;;123      SYS_ARCH_PROTECT(old_level);
;;;124      pbuf_free_ooseq_pending = 0;
000002  4808              LDR      r0,|L11.36|
000004  2500              MOVS     r5,#0
000006  7005              STRB     r5,[r0,#0]
;;;125      SYS_ARCH_UNPROTECT(old_level);
;;;126    
;;;127      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000008  4807              LDR      r0,|L11.40|
00000a  6804              LDR      r4,[r0,#0]            ;119  ; tcp_active_pcbs
00000c  e006              B        |L11.28|
                  |L11.14|
;;;128        if (NULL != pcb->ooseq) {
00000e  6f60              LDR      r0,[r4,#0x74]
000010  b118              CBZ      r0,|L11.26|
;;;129          /** Free the ooseq pbufs of one PCB only */
;;;130          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
;;;131          tcp_segs_free(pcb->ooseq);
000012  f7fffffe          BL       tcp_segs_free
;;;132          pcb->ooseq = NULL;
;;;133          return;
000016  6765              STR      r5,[r4,#0x74]
;;;134        }
;;;135      }
;;;136    }
000018  bd70              POP      {r4-r6,pc}
                  |L11.26|
00001a  68e4              LDR      r4,[r4,#0xc]          ;127
                  |L11.28|
00001c  2c00              CMP      r4,#0                 ;127
00001e  d1f6              BNE      |L11.14|
000020  bd70              POP      {r4-r6,pc}
;;;137    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      ||.data||
                  |L11.40|
                          DCD      tcp_active_pcbs

                          AREA ||i.pbuf_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_get_at PROC
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
000000  e002              B        |L12.8|
                  |L12.2|
;;;1078   {
;;;1079     u16_t copy_from = offset;
;;;1080     struct pbuf* q = p;
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
;;;1084       copy_from -= q->len;
000002  1a89              SUBS     r1,r1,r2
;;;1085       q = q->next;
000004  6800              LDR      r0,[r0,#0]
000006  b289              UXTH     r1,r1                 ;1084
                  |L12.8|
000008  2800              CMP      r0,#0                 ;1083
00000a  d004              BEQ      |L12.22|
00000c  8942              LDRH     r2,[r0,#0xa]          ;1083
00000e  428a              CMP      r2,r1                 ;1083
000010  d9f7              BLS      |L12.2|
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
;;;1089       return ((u8_t*)q->payload)[copy_from];
000012  6840              LDR      r0,[r0,#4]
000014  5c40              LDRB     r0,[r0,r1]
                  |L12.22|
;;;1090     }
;;;1091     return 0;
;;;1092   }
000016  4770              BX       lr
;;;1093   
                          ENDP


                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=2

                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  b510              PUSH     {r4,lr}
;;;512    {
000002  b160              CBZ      r0,|L13.30|
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
000004  2900              CMP      r1,#0
000006  d00e              BEQ      |L13.38|
;;;519        return 0;
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
000008  da0f              BGE      |L13.42|
;;;523        increment_magnitude = -header_size_increment;
00000a  f1c10200          RSB      r2,r1,#0
00000e  b293              UXTH     r3,r2
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
000010  8942              LDRH     r2,[r0,#0xa]
000012  429a              CMP      r2,r3
000014  d20a              BCS      |L13.44|
000016  a018              ADR      r0,|L13.120|
000018  f7fffffe          BL       __2printf
00001c  e029              B        |L13.114|
                  |L13.30|
00001e  a01e              ADR      r0,|L13.152|
000020  f7fffffe          BL       __2printf
                  |L13.36|
000024  e7fe              B        |L13.36|
                  |L13.38|
000026  2000              MOVS     r0,#0                 ;519
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
000028  bd10              POP      {r4,pc}
                  |L13.42|
00002a  b28b              UXTH     r3,r1                 ;527
                  |L13.44|
00002c  7b02              LDRB     r2,[r0,#0xc]          ;540
00002e  6844              LDR      r4,[r0,#4]            ;545
000030  b14a              CBZ      r2,|L13.70|
000032  2a03              CMP      r2,#3                 ;545
000034  d007              BEQ      |L13.70|
000036  2a02              CMP      r2,#2                 ;559
000038  d00d              BEQ      |L13.86|
00003a  2a01              CMP      r2,#1                 ;559
00003c  d00b              BEQ      |L13.86|
00003e  a019              ADR      r0,|L13.164|
000040  f7fffffe          BL       __2printf
                  |L13.68|
000044  e7fe              B        |L13.68|
                  |L13.70|
000046  1a62              SUBS     r2,r4,r1              ;547
000048  f1000310          ADD      r3,r0,#0x10           ;549
00004c  6042              STR      r2,[r0,#4]            ;549
00004e  429a              CMP      r2,r3                 ;549
000050  d208              BCS      |L13.100|
000052  6044              STR      r4,[r0,#4]            ;556
000054  e00d              B        |L13.114|
                  |L13.86|
000056  2900              CMP      r1,#0                 ;561
000058  da0b              BGE      |L13.114|
00005a  8942              LDRH     r2,[r0,#0xa]          ;561
00005c  429a              CMP      r2,r3                 ;561
00005e  d308              BCC      |L13.114|
000060  1a62              SUBS     r2,r4,r1              ;563
000062  6042              STR      r2,[r0,#4]            ;563
                  |L13.100|
000064  8942              LDRH     r2,[r0,#0xa]          ;575
000066  440a              ADD      r2,r2,r1              ;575
000068  8142              STRH     r2,[r0,#0xa]          ;575
00006a  8902              LDRH     r2,[r0,#8]            ;576
00006c  4411              ADD      r1,r1,r2              ;576
00006e  8101              STRH     r1,[r0,#8]            ;576
000070  e7d9              B        |L13.38|
                  |L13.114|
000072  2001              MOVS     r0,#1                 ;567
000074  bd10              POP      {r4,pc}
;;;583    
                          ENDP

000076  0000              DCW      0x0000
                  |L13.120|
000078  696e6372          DCB      "increment_magnitude <= p->len",0
00007c  656d656e
000080  745f6d61
000084  676e6974
000088  75646520
00008c  3c3d2070
000090  2d3e6c65
000094  6e00    
000096  00                DCB      0
000097  00                DCB      0
                  |L13.152|
000098  7020213d          DCB      "p != NULL",0
00009c  204e554c
0000a0  4c00    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L13.164|
0000a4  62616420          DCB      "bad pbuf type",0
0000a8  70627566
0000ac  20747970
0000b0  6500    
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.pbuf_memcmp||, CODE, READONLY, ALIGN=1

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1105   {
000002  4617              MOV      r7,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;1106     u16_t start = offset;
;;;1107     struct pbuf* q = p;
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
;;;1111       start -= q->len;
;;;1112       q = q->next;
000008  e002              B        |L14.16|
                  |L14.10|
00000a  1a30              SUBS     r0,r6,r0              ;1111
00000c  682d              LDR      r5,[r5,#0]
00000e  b286              UXTH     r6,r0                 ;1111
                  |L14.16|
000010  b1ad              CBZ      r5,|L14.62|
000012  8968              LDRH     r0,[r5,#0xa]          ;1110
000014  42b0              CMP      r0,r6                 ;1110
000016  d9f8              BLS      |L14.10|
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
000018  2400              MOVS     r4,#0
00001a  e00c              B        |L14.54|
                  |L14.28|
;;;1118         u8_t a = pbuf_get_at(q, start + i);
00001c  1930              ADDS     r0,r6,r4
00001e  b281              UXTH     r1,r0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       pbuf_get_at
;;;1119         u8_t b = ((u8_t*)s2)[i];
000026  5d39              LDRB     r1,[r7,r4]
;;;1120         if (a != b) {
000028  f1040401          ADD      r4,r4,#1
00002c  4288              CMP      r0,r1
00002e  d001              BEQ      |L14.52|
;;;1121           return i+1;
000030  b2a0              UXTH     r0,r4
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
;;;1127   }
000032  bdf0              POP      {r4-r7,pc}
                  |L14.52|
000034  b2a4              UXTH     r4,r4                 ;1117
                  |L14.54|
000036  429c              CMP      r4,r3                 ;1117
000038  d3f0              BCC      |L14.28|
00003a  2000              MOVS     r0,#0                 ;1124
00003c  bdf0              POP      {r4-r7,pc}
                  |L14.62|
00003e  f64f70ff          MOV      r0,#0xffff            ;1126
000042  bdf0              POP      {r4-r7,pc}
;;;1128   
                          ENDP


                          AREA ||i.pbuf_memfind||, CODE, READONLY, ALIGN=1

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1141   {
000004  4607              MOV      r7,r0
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
000006  8900              LDRH     r0,[r0,#8]
000008  4616              MOV      r6,r2                 ;1141
00000a  4688              MOV      r8,r1                 ;1141
00000c  1b81              SUBS     r1,r0,r6
00000e  b28d              UXTH     r5,r1
;;;1144     if (p->tot_len >= mem_len + start_offset) {
000010  18d1              ADDS     r1,r2,r3
000012  4288              CMP      r0,r1
000014  d30c              BCC      |L15.48|
;;;1145       for(i = start_offset; i <= max; ) {
000016  461c              MOV      r4,r3
000018  e008              B        |L15.44|
                  |L15.26|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
00001a  4633              MOV      r3,r6
00001c  4642              MOV      r2,r8
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       pbuf_memcmp
;;;1147         if (plus == 0) {
000026  b138              CBZ      r0,|L15.56|
;;;1148           return i;
;;;1149         } else {
;;;1150           i += plus;
000028  4420              ADD      r0,r0,r4
00002a  b284              UXTH     r4,r0
                  |L15.44|
00002c  42ac              CMP      r4,r5                 ;1145
00002e  d9f4              BLS      |L15.26|
                  |L15.48|
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
000030  f64f70ff          MOV      r0,#0xffff
                  |L15.52|
;;;1155   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L15.56|
000038  4620              MOV      r0,r4                 ;1148
00003a  e7fb              B        |L15.52|
;;;1156   
                          ENDP


                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=2

                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  b570              PUSH     {r4-r6,lr}
;;;431    {
000002  b158              CBZ      r0,|L16.28|
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
000004  7b02              LDRB     r2,[r0,#0xc]
000006  2a03              CMP      r2,#3
000008  d00c              BEQ      |L16.36|
00000a  2a01              CMP      r2,#1
00000c  d00a              BEQ      |L16.36|
00000e  b14a              CBZ      r2,|L16.36|
000010  2a02              CMP      r2,#2
000012  d007              BEQ      |L16.36|
000014  a020              ADR      r0,|L16.152|
000016  f7fffffe          BL       __2printf
                  |L16.26|
00001a  e7fe              B        |L16.26|
                  |L16.28|
00001c  a025              ADR      r0,|L16.180|
00001e  f7fffffe          BL       __2printf
                  |L16.34|
000022  e7fe              B        |L16.34|
                  |L16.36|
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
000024  8902              LDRH     r2,[r0,#8]
000026  428a              CMP      r2,r1
000028  d930              BLS      |L16.140|
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
00002a  1a8a              SUBS     r2,r1,r2
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
00002c  460d              MOV      r5,r1
;;;454      q = p;
00002e  4604              MOV      r4,r0
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
000030  f64f71ff          MOV      r1,#0xffff
000034  e00c              B        |L16.80|
                  |L16.54|
000036  1a28              SUBS     r0,r5,r0              ;458
000038  b285              UXTH     r5,r0                 ;458
00003a  428a              CMP      r2,r1
00003c  db03              BLT      |L16.70|
00003e  a023              ADR      r0,|L16.204|
000040  f7fffffe          BL       __2printf
                  |L16.68|
000044  e7fe              B        |L16.68|
                  |L16.70|
;;;461        q->tot_len += (u16_t)grow;
000046  8920              LDRH     r0,[r4,#8]
000048  4410              ADD      r0,r0,r2
00004a  8120              STRH     r0,[r4,#8]
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
00004c  6824              LDR      r4,[r4,#0]
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
00004e  b12c              CBZ      r4,|L16.92|
                  |L16.80|
000050  8960              LDRH     r0,[r4,#0xa]          ;456
000052  42a8              CMP      r0,r5                 ;456
000054  d3ef              BCC      |L16.54|
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
000056  7b20              LDRB     r0,[r4,#0xc]
000058  b120              CBZ      r0,|L16.100|
00005a  e00f              B        |L16.124|
                  |L16.92|
00005c  a020              ADR      r0,|L16.224|
00005e  f7fffffe          BL       __2printf
                  |L16.98|
000062  e7fe              B        |L16.98|
                  |L16.100|
000064  8960              LDRH     r0,[r4,#0xa]
000066  42a8              CMP      r0,r5
000068  d008              BEQ      |L16.124|
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
00006a  88a0              LDRH     r0,[r4,#4]
00006c  1b00              SUBS     r0,r0,r4
00006e  4428              ADD      r0,r0,r5
000070  b281              UXTH     r1,r0
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       mem_trim
000078  0004              MOVS     r4,r0
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
00007a  d008              BEQ      |L16.142|
                  |L16.124|
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
00007c  8165              STRH     r5,[r4,#0xa]
;;;478      q->tot_len = q->len;
00007e  8125              STRH     r5,[r4,#8]
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
000080  6820              LDR      r0,[r4,#0]
000082  b108              CBZ      r0,|L16.136|
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
000084  f7fffffe          BL       pbuf_free
                  |L16.136|
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
000088  2000              MOVS     r0,#0
;;;487    
;;;488    }
00008a  6020              STR      r0,[r4,#0]
                  |L16.140|
00008c  bd70              POP      {r4-r6,pc}
                  |L16.142|
00008e  a01a              ADR      r0,|L16.248|
000090  f7fffffe          BL       __2printf
                  |L16.148|
000094  e7fe              B        |L16.148|
;;;489    
                          ENDP

000096  0000              DCW      0x0000
                  |L16.152|
000098  70627566          DCB      "pbuf_realloc: sane p->type",0
00009c  5f726561
0000a0  6c6c6f63
0000a4  3a207361
0000a8  6e652070
0000ac  2d3e7479
0000b0  706500  
0000b3  00                DCB      0
                  |L16.180|
0000b4  70627566          DCB      "pbuf_realloc: p != NULL",0
0000b8  5f726561
0000bc  6c6c6f63
0000c0  3a207020
0000c4  213d204e
0000c8  554c4c00
                  |L16.204|
0000cc  67726f77          DCB      "grow < max_u16_t",0
0000d0  203c206d
0000d4  61785f75
0000d8  31365f74
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L16.224|
0000e0  70627566          DCB      "pbuf_realloc: q != NULL",0
0000e4  5f726561
0000e8  6c6c6f63
0000ec  3a207120
0000f0  213d204e
0000f4  554c4c00
                  |L16.248|
0000f8  6d656d5f          DCB      "mem_trim returned q == NULL",0
0000fc  7472696d
000100  20726574
000104  75726e65
000108  64207120
00010c  3d3d204e
000110  554c4c00

                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=1

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
000000  2800              CMP      r0,#0
;;;724    {
000002  d002              BEQ      |L17.10|
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
;;;728        SYS_ARCH_PROTECT(old_level);
;;;729        ++(p->ref);
000004  89c1              LDRH     r1,[r0,#0xe]
000006  1c49              ADDS     r1,r1,#1
000008  81c1              STRH     r1,[r0,#0xe]
                  |L17.10|
;;;730        SYS_ARCH_UNPROTECT(old_level);
;;;731      }
;;;732    }
00000a  4770              BX       lr
;;;733    
                          ENDP


                          AREA ||i.pbuf_strstr||, CODE, READONLY, ALIGN=1

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
000000  b570              PUSH     {r4-r6,lr}
;;;1169   {
000002  4605              MOV      r5,r0
000004  000c              MOVS     r4,r1
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
000006  f64f76ff          MOV      r6,#0xffff
00000a  d009              BEQ      |L18.32|
00000c  7820              LDRB     r0,[r4,#0]
00000e  b138              CBZ      r0,|L18.32|
000010  8928              LDRH     r0,[r5,#8]
000012  42b0              CMP      r0,r6
000014  d004              BEQ      |L18.32|
;;;1172       return 0xFFFF;
;;;1173     }
;;;1174     substr_len = strlen(substr);
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       strlen
;;;1175     if (substr_len >= 0xFFFF) {
00001c  42b0              CMP      r0,r6
00001e  d301              BCC      |L18.36|
                  |L18.32|
;;;1176       return 0xFFFF;
000020  4630              MOV      r0,r6
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  b282              UXTH     r2,r0                 ;1178
000026  4621              MOV      r1,r4                 ;1178
000028  4628              MOV      r0,r5                 ;1178
00002a  e8bd4070          POP      {r4-r6,lr}            ;1178
00002e  2300              MOVS     r3,#0                 ;1178
000030  f7ffbffe          B.W      pbuf_memfind
                          ENDP


                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
000004  4690              MOV      r8,r2
000006  4689              MOV      r9,r1
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
000008  4616              MOV      r6,r2
;;;971      u16_t copied_total = 0;
00000a  2700              MOVS     r7,#0
00000c  b148              CBZ      r0,|L19.34|
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
00000e  f1b90f00          CMP      r9,#0
000012  d008              BEQ      |L19.38|
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
000014  8902              LDRH     r2,[r0,#8]
000016  42b2              CMP      r2,r6
000018  d209              BCS      |L19.46|
;;;977        return ERR_ARG;
00001a  f06f000d          MVN      r0,#0xd
                  |L19.30|
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L19.34|
000022  a013              ADR      r0,|L19.112|
000024  e000              B        |L19.40|
                  |L19.38|
000026  a018              ADR      r0,|L19.136|
                  |L19.40|
000028  f7fffffe          BL       __2printf
00002c  e01e              B        |L19.108|
                  |L19.46|
00002e  4604              MOV      r4,r0                 ;981
000030  e010              B        |L19.84|
                  |L19.50|
000032  b1bc              CBZ      r4,|L19.100|
000034  8960              LDRH     r0,[r4,#0xa]          ;984
000036  4635              MOV      r5,r6                 ;983
000038  42a8              CMP      r0,r5                 ;984
00003a  d200              BCS      |L19.62|
00003c  4605              MOV      r5,r0                 ;986
                  |L19.62|
00003e  eb090107          ADD      r1,r9,r7              ;989
000042  462a              MOV      r2,r5                 ;989
000044  6860              LDR      r0,[r4,#4]            ;989
000046  f7fffffe          BL       __aeabi_memcpy
00004a  1b70              SUBS     r0,r6,r5              ;990
00004c  b286              UXTH     r6,r0                 ;990
00004e  1978              ADDS     r0,r7,r5              ;991
000050  6824              LDR      r4,[r4,#0]            ;981
000052  b287              UXTH     r7,r0                 ;991
                  |L19.84|
000054  2e00              CMP      r6,#0                 ;981
000056  d1ec              BNE      |L19.50|
000058  4547              CMP      r7,r8                 ;993
00005a  d007              BEQ      |L19.108|
00005c  a011              ADR      r0,|L19.164|
00005e  f7fffffe          BL       __2printf
                  |L19.98|
000062  e7fe              B        |L19.98|
                  |L19.100|
000064  a015              ADR      r0,|L19.188|
000066  f7fffffe          BL       __2printf
                  |L19.106|
00006a  e7fe              B        |L19.106|
                  |L19.108|
00006c  2000              MOVS     r0,#0                 ;994
00006e  e7d6              B        |L19.30|
;;;996    
                          ENDP

                  |L19.112|
000070  70627566          DCB      "pbuf_take: invalid buf",0
000074  5f74616b
000078  653a2069
00007c  6e76616c
000080  69642062
000084  756600  
000087  00                DCB      0
                  |L19.136|
000088  70627566          DCB      "pbuf_take: invalid dataptr",0
00008c  5f74616b
000090  653a2069
000094  6e76616c
000098  69642064
00009c  61746170
0000a0  747200  
0000a3  00                DCB      0
                  |L19.164|
0000a4  64696420          DCB      "did not copy all data",0
0000a8  6e6f7420
0000ac  636f7079
0000b0  20616c6c
0000b4  20646174
0000b8  6100    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L19.188|
0000bc  70627566          DCB      "pbuf_take: invalid pbuf",0
0000c0  5f74616b
0000c4  653a2069
0000c8  6e76616c
0000cc  69642070
0000d0  62756600

                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00
